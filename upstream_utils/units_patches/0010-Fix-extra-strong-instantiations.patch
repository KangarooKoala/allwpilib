From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joseph Eng <91924258+KangarooKoala@users.noreply.github.com>
Date: Fri, 23 Jan 2026 18:00:26 -0800
Subject: [PATCH 10/11] Fix extra strong<> instantiations

Add SFINAE to decibel operator-(dimensionless, dimensioned)
Add SFINAE to operator/(dimensionless, dimensioned)
Add SFINAE to operator/(scalar, dimensioned)
---
 include/units/core.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/include/units/core.h b/include/units/core.h
index 088bd1ad69ee4d25889a2612f2456db2944bf18b..4d3c8f18ca89f68f0fe59c47cc8a9070298a6a74 100644
--- a/include/units/core.h
+++ b/include/units/core.h
@@ -3343,7 +3343,7 @@ namespace units
 	}
 
 	/// Division of a dimensionless unit by a unit type with a linear scale
-	template<DimensionlessUnitType UnitTypeLhs, DimensionedUnitType UnitTypeRhs>
+	template<DimensionlessUnitType UnitTypeLhs, DimensionedUnitType UnitTypeRhs, std::enable_if_t<traits::is_dimensionless_unit_v<UnitTypeLhs>, int> = 0>
 		requires(traits::has_linear_scale_v<UnitTypeLhs, UnitTypeRhs> && traits::is_dimensionless_unit_v<UnitTypeLhs>)
 	constexpr auto operator/(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs) noexcept -> unit<traits::strong_t<inverse<typename traits::unit_traits<UnitTypeRhs>::conversion_factor>>,
 		std::common_type_t<typename UnitTypeLhs::underlying_type, typename UnitTypeRhs::underlying_type>>
@@ -3363,7 +3363,7 @@ namespace units
 	}
 
 	/// Division of a dimensionless by a unit type with a linear scale
-	template<UnitType UnitTypeRhs, ArithmeticType T>
+	template<UnitType UnitTypeRhs, ArithmeticType T, std::enable_if_t<ArithmeticType<T>, int> = 0>
 		requires(traits::has_linear_scale_v<UnitTypeRhs>)
 	constexpr auto operator/(T lhs, const UnitTypeRhs& rhs) noexcept
 		-> unit<traits::strong_t<inverse<typename traits::unit_traits<UnitTypeRhs>::conversion_factor>>, std::common_type_t<T, typename UnitTypeRhs::underlying_type>>
@@ -3691,7 +3691,7 @@ namespace units
 	}
 
 	/// Subtraction between unit types with a decibel_scale and dimensionless dB units
-	template<DimensionlessUnitType UnitTypeLhs, DimensionedUnitType UnitTypeRhs>
+	template<DimensionlessUnitType UnitTypeLhs, DimensionedUnitType UnitTypeRhs, std::enable_if_t<traits::has_decibel_scale_v<UnitTypeLhs, UnitTypeRhs>, int> = 0>
 		requires(traits::has_decibel_scale_v<UnitTypeLhs, UnitTypeRhs>)
 	constexpr auto operator-(const UnitTypeLhs& lhs, const UnitTypeRhs& rhs) noexcept -> unit<traits::strong_t<inverse<typename traits::unit_traits<UnitTypeRhs>::conversion_factor>>,
 		std::common_type_t<typename UnitTypeLhs::underlying_type, typename UnitTypeRhs::underlying_type>, decibel_scale>
