diff --git a/wpimath/src/main/native/cpp/MathShared.cpp b/wpimath/src/main/native/cpp/MathShared.cpp
index a9cae0b311..f6e19d729f 100644
--- a/wpimath/src/main/native/cpp/MathShared.cpp
+++ b/wpimath/src/main/native/cpp/MathShared.cpp
@@ -21,9 +21,7 @@ class DefaultMathShared : public MathShared {
   void ReportWarningV(fmt::string_view format, fmt::format_args args) override {
   }
   void ReportUsage(std::string_view resource, std::string_view data) override {}
-  mp::quantity<mp::s> GetTimestamp() override {
-    return wpi::Now() * 1.0e-6 * mp::s;
-  }
+  mp::quantity<mp::s> GetTimestamp() override { return wpi::Now() * mp::µs; }
 };
 }  // namespace
 
diff --git a/wpimath/src/main/native/include/frc/ComputerVisionUtil.h b/wpimath/src/main/native/include/frc/ComputerVisionUtil.h
index d7b59d27af..9a901ab17b 100644
--- a/wpimath/src/main/native/include/frc/ComputerVisionUtil.h
+++ b/wpimath/src/main/native/include/frc/ComputerVisionUtil.h
@@ -27,7 +27,7 @@ namespace frc {
  *   variable if the camera is mounted to a turret. If the camera was mounted 3
  *   inches in front of the "origin" (usually physical center) of the robot,
  *   this would be frc::Transform3d{3.0 * mp::in, 0.0 * mp::in, 0.0 * mp::in,
- * frc::Rotation3d{}}.
+ *   frc::Rotation3d{}}.
  * @return The robot's field-relative pose.
  */
 WPILIB_DLLEXPORT
diff --git a/wpimath/src/main/native/include/frc/MathUtil.h b/wpimath/src/main/native/include/frc/MathUtil.h
index ab19caa515..8e604b0ff6 100644
--- a/wpimath/src/main/native/include/frc/MathUtil.h
+++ b/wpimath/src/main/native/include/frc/MathUtil.h
@@ -30,7 +30,21 @@ namespace frc {
  */
 template <typename T>
   requires std::is_arithmetic_v<T> || mp::Quantity<T>
-constexpr T ApplyDeadband(T value, T deadband, T maxMagnitude = T{1.0}) {
+constexpr T ApplyDeadband(
+    T value, T deadband, T maxMagnitude = [] {
+      if constexpr (std::is_arithmetic_v<T>) {
+        return T{1.0};
+      } else {
+        return 1.0 * T::unit;
+      }
+    }()) {
+  constexpr T zero = [] {
+    if constexpr (std::is_arithmetic_v<T>) {
+      return T{0.0};
+    } else {
+      return 0.0 * T::unit;
+    }
+  }();
   T magnitude;
   if constexpr (std::is_arithmetic_v<T>) {
     magnitude = gcem::abs(value);
@@ -39,10 +53,10 @@ constexpr T ApplyDeadband(T value, T deadband, T maxMagnitude = T{1.0}) {
   }
 
   if (magnitude < deadband) {
-    return T{0.0};
+    return zero;
   }
 
-  if (value > T{0.0}) {
+  if (value > zero) {
     // Map deadband to 0 and map max to max with a linear relationship.
     //
     //   y - y₁ = m(x - x₁)
@@ -112,7 +126,14 @@ constexpr T ApplyDeadband(T value, T deadband, T maxMagnitude = T{1.0}) {
  */
 template <typename T>
   requires std::is_arithmetic_v<T> || mp::Quantity<T>
-constexpr T CopySignPow(T value, double exponent, T maxMagnitude = T{1.0}) {
+constexpr T CopySignPow(
+    T value, double exponent, T maxMagnitude = [] {
+      if constexpr (std::is_arithmetic_v<T>) {
+        return T{1.0};
+      } else {
+        return 1.0 * T::unit;
+      }
+    }()) {
   if constexpr (std::is_arithmetic_v<T>) {
     return gcem::copysign(
         gcem::pow(gcem::abs(value) / maxMagnitude, exponent) * maxMagnitude,
diff --git a/wpimath/src/main/native/include/frc/StateSpaceUtil.h b/wpimath/src/main/native/include/frc/StateSpaceUtil.h
index 439349a1c8..3cc6033d69 100644
--- a/wpimath/src/main/native/include/frc/StateSpaceUtil.h
+++ b/wpimath/src/main/native/include/frc/StateSpaceUtil.h
@@ -17,6 +17,7 @@
 
 #include "frc/EigenCore.h"
 #include "frc/geometry/Pose2d.h"
+#include "frc/units.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h b/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h
index bb1a2b4ef3..6e011d59d3 100644
--- a/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h
+++ b/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h
@@ -19,11 +19,11 @@ namespace frc {
  */
 class WPILIB_DLLEXPORT ArmFeedforward {
  public:
-  using Angle = mp::rad;
-  using Velocity = units::compound_unit<Angle, units::inverse<mp::s>>;
-  using Acceleration = units::compound_unit<Velocity, units::inverse<mp::s>>;
-  using kv_unit = units::compound_unit<mp::V, units::inverse<Velocity>>;
-  using ka_unit = units::compound_unit<mp::V, units::inverse<Acceleration>>;
+  inline static constexpr auto Angle = mp::rad;
+  inline static constexpr auto Velocity = Angle / mp::s;
+  inline static constexpr auto Acceleration = Velocity / mp::s;
+  inline static constexpr auto kv_unit = mp::V / Velocity;
+  inline static constexpr auto ka_unit = mp::V / Acceleration;
 
   /**
    * Creates a new ArmFeedforward with the specified gains.
diff --git a/wpimath/src/main/native/include/frc/controller/ElevatorFeedforward.h b/wpimath/src/main/native/include/frc/controller/ElevatorFeedforward.h
index 3137d58a6a..b3db2537b4 100644
--- a/wpimath/src/main/native/include/frc/controller/ElevatorFeedforward.h
+++ b/wpimath/src/main/native/include/frc/controller/ElevatorFeedforward.h
@@ -19,11 +19,11 @@ namespace frc {
  */
 class ElevatorFeedforward {
  public:
-  using Distance = mp::m;
-  using Velocity = units::compound_unit<Distance, units::inverse<mp::s>>;
-  using Acceleration = units::compound_unit<Velocity, units::inverse<mp::s>>;
-  using kv_unit = units::compound_unit<mp::V, units::inverse<Velocity>>;
-  using ka_unit = units::compound_unit<mp::V, units::inverse<Acceleration>>;
+  inline static constexpr auto Distance = mp::m;
+  inline static constexpr auto Velocity = Distance / mp::s;
+  inline static constexpr auto Acceleration = Velocity / mp::s;
+  inline static constexpr auto kv_unit = mp::V / Velocity;
+  inline static constexpr auto ka_unit = mp::V / Acceleration;
 
   /**
    * Creates a new ElevatorFeedforward with the specified gains.
@@ -128,7 +128,7 @@ class ElevatorFeedforward {
       mp::quantity<Velocity> currentVelocity,
       mp::quantity<Velocity> nextVelocity) const {
     // See wpimath/algorithms.md#Elevator_feedforward for derivation
-    if (kA < decltype(kA)(1e-9)) {
+    if (kA < 1e-9 * decltype(kA)::unit) {
       return kS * wpi::sgn(nextVelocity) + kG + kV * nextVelocity;
     } else {
       double A = -mp::value(kV) / mp::value(kA);
diff --git a/wpimath/src/main/native/include/frc/controller/ProfiledPIDController.h b/wpimath/src/main/native/include/frc/controller/ProfiledPIDController.h
index bf8dbba1d3..12a103f55d 100644
--- a/wpimath/src/main/native/include/frc/controller/ProfiledPIDController.h
+++ b/wpimath/src/main/native/include/frc/controller/ProfiledPIDController.h
@@ -28,15 +28,15 @@ int IncrementAndGetProfiledPIDControllerInstances();
  * Implements a PID control loop whose setpoint is constrained by a trapezoid
  * profile.
  */
-template <class Distance>
+template <mp::Unit auto Distance>
 class ProfiledPIDController
     : public wpi::Sendable,
       public wpi::SendableHelper<ProfiledPIDController<Distance>> {
  public:
   using Distance_t = mp::quantity<Distance>;
-  using Velocity = units::compound_unit<Distance, units::inverse<mp::s>>;
+  inline static constexpr auto Velocity = Distance / mp::s;
   using Velocity_t = mp::quantity<Velocity>;
-  using Acceleration = units::compound_unit<Velocity, units::inverse<mp::s>>;
+  inline static constexpr auto Acceleration = Velocity / mp::s;
   using Acceleration_t = mp::quantity<Acceleration>;
   using State = typename TrapezoidProfile<Distance>::State;
   using Constraints = typename TrapezoidProfile<Distance>::Constraints;
@@ -199,7 +199,7 @@ class ProfiledPIDController
    *
    * @param goal The desired unprofiled setpoint.
    */
-  constexpr void SetGoal(Distance_t goal) { m_goal = {goal, Velocity_t{0}}; }
+  constexpr void SetGoal(Distance_t goal) { m_goal = {goal, 0.0 * Velocity}; }
 
   /**
    * Gets the goal for the ProfiledPIDController.
@@ -294,9 +294,10 @@ class ProfiledPIDController
    * @param positionTolerance Position error which is tolerable.
    * @param velocityTolerance Velocity error which is tolerable.
    */
-  constexpr void SetTolerance(Distance_t positionTolerance,
-                              Velocity_t velocityTolerance = Velocity_t{
-                                  std::numeric_limits<double>::infinity()}) {
+  constexpr void SetTolerance(
+      Distance_t positionTolerance,
+      Velocity_t velocityTolerance = std::numeric_limits<double>::infinity() *
+                                     Velocity) {
     m_controller.SetTolerance(mp::value(positionTolerance),
                               mp::value(velocityTolerance));
   }
@@ -307,14 +308,14 @@ class ProfiledPIDController
    * @return The error.
    */
   constexpr Distance_t GetPositionError() const {
-    return Distance_t{m_controller.GetError()};
+    return m_controller.GetError() * Distance;
   }
 
   /**
    * Returns the change in error per second.
    */
   constexpr Velocity_t GetVelocityError() const {
-    return Velocity_t{m_controller.GetErrorDerivative()};
+    return m_controller.GetErrorDerivative() * Velocity;
   }
 
   /**
@@ -409,7 +410,7 @@ class ProfiledPIDController
    * velocity is assumed to be zero.
    */
   constexpr void Reset(Distance_t measuredPosition) {
-    Reset(measuredPosition, Velocity_t{0});
+    Reset(measuredPosition, 0.0 * Velocity);
   }
 
   void InitSendable(wpi::SendableBuilder& builder) override {
@@ -428,24 +429,24 @@ class ProfiledPIDController
         [this] { return mp::value(GetConstraints().maxVelocity); },
         [this](double value) {
           SetConstraints(
-              Constraints{Velocity_t{value}, GetConstraints().maxAcceleration});
+              Constraints{value * Velocity, GetConstraints().maxAcceleration});
         });
     builder.AddDoubleProperty(
         "maxAcceleration",
         [this] { return mp::value(GetConstraints().maxAcceleration); },
         [this](double value) {
           SetConstraints(
-              Constraints{GetConstraints().maxVelocity, Acceleration_t{value}});
+              Constraints{GetConstraints().maxVelocity, value * Acceleration});
         });
     builder.AddDoubleProperty(
         "goal", [this] { return mp::value(GetGoal().position); },
-        [this](double value) { SetGoal(Distance_t{value}); });
+        [this](double value) { SetGoal(value * Distance); });
   }
 
  private:
   PIDController m_controller;
-  Distance_t m_minimumInput{0};
-  Distance_t m_maximumInput{0};
+  Distance_t m_minimumInput = 0.0 * Distance;
+  Distance_t m_maximumInput = 0.0 * Distance;
 
   typename frc::TrapezoidProfile<Distance>::Constraints m_constraints;
   TrapezoidProfile<Distance> m_profile;
diff --git a/wpimath/src/main/native/include/frc/controller/SimpleMotorFeedforward.h b/wpimath/src/main/native/include/frc/controller/SimpleMotorFeedforward.h
index 1af5fcc2d0..2ef43f582c 100644
--- a/wpimath/src/main/native/include/frc/controller/SimpleMotorFeedforward.h
+++ b/wpimath/src/main/native/include/frc/controller/SimpleMotorFeedforward.h
@@ -16,14 +16,15 @@ namespace frc {
  * A helper class that computes feedforward voltages for a simple
  * permanent-magnet DC motor.
  */
-template <class Distance>
-  requires units::length_unit<Distance> || units::angle_unit<Distance>
+template <mp::Unit auto Distance>
+  requires mp::UnitOf<decltype(Distance), mp::length> ||
+           mp::UnitOf<decltype(Distance), mp::angle>
 class SimpleMotorFeedforward {
  public:
-  using Velocity = units::compound_unit<Distance, units::inverse<mp::s>>;
-  using Acceleration = units::compound_unit<Velocity, units::inverse<mp::s>>;
-  using kv_unit = units::compound_unit<mp::V, units::inverse<Velocity>>;
-  using ka_unit = units::compound_unit<mp::V, units::inverse<Acceleration>>;
+  inline static constexpr auto Velocity = Distance / mp::s;
+  inline static constexpr auto Acceleration = Velocity / mp::s;
+  inline static constexpr auto kv_unit = mp::V / Velocity;
+  inline static constexpr auto ka_unit = mp::V / Acceleration;
 
   /**
    * Creates a new SimpleMotorFeedforward with the specified gains.
@@ -88,7 +89,7 @@ class SimpleMotorFeedforward {
       mp::quantity<Velocity> currentVelocity,
       mp::quantity<Velocity> nextVelocity) const {
     // See wpimath/algorithms.md#Simple_motor_feedforward for derivation
-    if (kA < decltype(kA)(1e-9)) {
+    if (kA < 1e-9 * ka_unit) {
       return kS * wpi::sgn(nextVelocity) + kV * nextVelocity;
     } else {
       double A = -mp::value(kV) / mp::value(kA);
diff --git a/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h b/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h
index 029629e233..d6552b3909 100644
--- a/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h
+++ b/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h
@@ -15,9 +15,14 @@
 // frc::SimpleMotorFeedforward<mp::m> or
 // frc::SimpleMotorFeedforward<mp::rad>
 
-template <class Distance>
-  requires units::length_unit<Distance> || units::angle_unit<Distance>
+template <mp::Unit auto Distance>
+  requires mp::UnitOf<decltype(Distance), mp::length> ||
+           mp::UnitOf<decltype(Distance), mp::angle>
 struct wpi::Protobuf<frc::SimpleMotorFeedforward<Distance>> {
+  // Because all instantiations of
+  // wpi::Protobuf<frc::SimpleMotorFeedforward<Distance>> use the same
+  // MessageStruct type, it doesn't matter if we use Distance or
+  // mp::get_base_unit(Distance) in InputStream and OutputStream.
   using MessageStruct = wpi_proto_ProtobufSimpleMotorFeedforward;
   using InputStream =
       wpi::ProtoInputStream<frc::SimpleMotorFeedforward<Distance>>;
@@ -26,9 +31,8 @@ struct wpi::Protobuf<frc::SimpleMotorFeedforward<Distance>> {
 
   static std::optional<frc::SimpleMotorFeedforward<Distance>> Unpack(
       InputStream& stream) {
-    using BaseUnit =
-        units::unit<std::ratio<1>, units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = frc::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        frc::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     wpi_proto_ProtobufSimpleMotorFeedforward msg;
     if (!stream.Decode(msg)) {
       return {};
@@ -44,9 +48,8 @@ struct wpi::Protobuf<frc::SimpleMotorFeedforward<Distance>> {
 
   static bool Pack(OutputStream& stream,
                    const frc::SimpleMotorFeedforward<Distance>& value) {
-    using BaseUnit =
-        units::unit<std::ratio<1>, units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = frc::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        frc::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     wpi_proto_ProtobufSimpleMotorFeedforward msg{
         .ks = mp::value(value.GetKs().in(mp::V)),
         .kv = mp::value(value.GetKv().in(BaseFeedforward::kv_unit)),
diff --git a/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h b/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h
index c4846a83d3..aec82afb15 100644
--- a/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h
+++ b/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h
@@ -13,8 +13,9 @@
 // frc::SimpleMotorFeedforward<mp::m> or
 // frc::SimpleMotorFeedforward<mp::rad>
 
-template <class Distance>
-  requires units::length_unit<Distance> || units::angle_unit<Distance>
+template <mp::Unit auto Distance>
+  requires mp::UnitOf<decltype(Distance), mp::length> ||
+           mp::UnitOf<decltype(Distance), mp::angle>
 struct wpi::Struct<frc::SimpleMotorFeedforward<Distance>> {
   static constexpr std::string_view GetTypeName() {
     return "SimpleMotorFeedforward";
@@ -26,9 +27,8 @@ struct wpi::Struct<frc::SimpleMotorFeedforward<Distance>> {
 
   static frc::SimpleMotorFeedforward<Distance> Unpack(
       std::span<const uint8_t> data) {
-    using BaseUnit =
-        units::unit<std::ratio<1>, units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = frc::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        frc::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     constexpr size_t kKsOff = 0;
     constexpr size_t kKvOff = kKsOff + 8;
     constexpr size_t kKaOff = kKvOff + 8;
@@ -41,9 +41,8 @@ struct wpi::Struct<frc::SimpleMotorFeedforward<Distance>> {
 
   static void Pack(std::span<uint8_t> data,
                    const frc::SimpleMotorFeedforward<Distance>& value) {
-    using BaseUnit =
-        units::unit<std::ratio<1>, units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = frc::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        frc::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     constexpr size_t kKsOff = 0;
     constexpr size_t kKvOff = kKsOff + 8;
     constexpr size_t kKaOff = kKvOff + 8;
diff --git a/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h b/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h
index ce26f995ee..8ec0911bd9 100644
--- a/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h
+++ b/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h
@@ -21,11 +21,11 @@ namespace frc {
  *
  * @see TrapezoidProfile
  */
-template <class Unit>
+template <mp::Unit auto Unit>
 class SlewRateLimiter {
  public:
   using Unit_t = mp::quantity<Unit>;
-  using Rate = units::compound_unit<Unit, units::inverse<mp::s>>;
+  inline static constexpr auto Rate = Unit / mp::s;
   using Rate_t = mp::quantity<Rate>;
 
   /**
@@ -41,7 +41,7 @@ class SlewRateLimiter {
    * @param initialValue The initial value of the input.
    */
   SlewRateLimiter(Rate_t positiveRateLimit, Rate_t negativeRateLimit,
-                  Unit_t initialValue = Unit_t{0})
+                  Unit_t initialValue = 0.0 * Unit)
       : m_positiveRateLimit{positiveRateLimit},
         m_negativeRateLimit{negativeRateLimit},
         m_prevVal{initialValue},
diff --git a/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h b/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h
index 08043795d7..2d284b830d 100644
--- a/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h
+++ b/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h
@@ -38,8 +38,7 @@ struct WPILIB_DLLEXPORT DifferentialDriveWheelSpeeds {
    * @param attainableMaxSpeed The absolute max speed that a wheel can reach.
    */
   constexpr void Desaturate(mp::quantity<mp::m / mp::s> attainableMaxSpeed) {
-    auto realMaxSpeed =
-        std::max(mp::abs(left), mp::abs(right));
+    auto realMaxSpeed = std::max(mp::abs(left), mp::abs(right));
 
     if (realMaxSpeed > attainableMaxSpeed) {
       left = left / realMaxSpeed * attainableMaxSpeed;
diff --git a/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h b/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h
index 7d395fe744..11003efea7 100644
--- a/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h
+++ b/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h
@@ -36,7 +36,6 @@
 #include <wpi/SymbolExports.h>
 
 #include "frc/spline/Spline.h"
-#include "frc/units-usc.h"
 #include "frc/units.h"
 
 namespace frc {
@@ -124,8 +123,8 @@ class WPILIB_DLLEXPORT SplineParameterizer {
 
  private:
   // Constraints for spline parameterization.
-  static inline constexpr mp::quantity<mp::m> kMaxDx = 5.0 * mp::in;
-  static inline constexpr mp::quantity<mp::m> kMaxDy = 0.05 * mp::in;
+  static inline constexpr mp::quantity<mp::m> kMaxDx = 15.0 * mp::cm;
+  static inline constexpr mp::quantity<mp::m> kMaxDy = 0.15 * mp::cm;
   static inline constexpr mp::quantity<mp::rad> kMaxDtheta = 0.0872 * mp::rad;
 
   struct StackContents {
diff --git a/wpimath/src/main/native/include/frc/system/plant/DCMotor.h b/wpimath/src/main/native/include/frc/system/plant/DCMotor.h
index f39cc85a28..1b6ebabe10 100644
--- a/wpimath/src/main/native/include/frc/system/plant/DCMotor.h
+++ b/wpimath/src/main/native/include/frc/system/plant/DCMotor.h
@@ -15,10 +15,8 @@ namespace frc {
  */
 class WPILIB_DLLEXPORT DCMotor {
  public:
-  using radians_per_second_per_volt_t = units::unit_t<
-      units::compound_unit<mp::rad / mp::s, units::inverse<mp::V>>>;
-  using newton_meters_per_ampere_t = units::unit_t<
-      units::compound_unit<units::newton_meters, units::inverse<mp::A>>>;
+  using radians_per_second_per_volt_t = mp::quantity<mp::rad / mp::s / mp::V>;
+  using newton_meters_per_ampere_t = mp::quantity<mp::N * mp::m / mp::A>;
 
   /// Voltage at which the motor constants were measured.
   mp::quantity<mp::V> nominalVoltage;
diff --git a/wpimath/src/main/native/include/frc/system/plant/LinearSystemId.h b/wpimath/src/main/native/include/frc/system/plant/LinearSystemId.h
index 803032460a..91eadda356 100644
--- a/wpimath/src/main/native/include/frc/system/plant/LinearSystemId.h
+++ b/wpimath/src/main/native/include/frc/system/plant/LinearSystemId.h
@@ -20,14 +20,11 @@ namespace frc {
  */
 class WPILIB_DLLEXPORT LinearSystemId {
  public:
-  template <typename Distance>
-  using Velocity_t =
-      units::unit_t<units::compound_unit<Distance, units::inverse<mp::s>>>;
+  template <mp::Unit auto Distance>
+  using Velocity_t = mp::quantity<Distance / mp::s>;
 
-  template <typename Distance>
-  using Acceleration_t = units::unit_t<units::compound_unit<
-      units::compound_unit<Distance, units::inverse<mp::s>>,
-      units::inverse<mp::s>>>;
+  template <mp::Unit auto Distance>
+  using Acceleration_t = mp::quantity<Distance / mp::s2>;
 
   /**
    * Create a state-space model of the elevator system. The states of the system
@@ -115,15 +112,15 @@ class WPILIB_DLLEXPORT LinearSystemId {
    * @see <a
    * href="https://github.com/wpilibsuite/sysid">https://github.com/wpilibsuite/sysid</a>
    */
-  template <typename Distance>
-    requires std::same_as<mp::m, Distance> || std::same_as<mp::rad, Distance>
+  template <mp::Unit auto Distance>
+    requires(Distance == mp::m) || (Distance == mp::rad)
   static constexpr LinearSystem<1, 1, 1> IdentifyVelocitySystem(
-      mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
-      mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA) {
-    if (kV < decltype(kV){0}) {
+      mp::quantity<mp::V / Velocity_t<Distance>::unit> kV,
+      mp::quantity<mp::V / Acceleration_t<Distance>::unit> kA) {
+    if (kV < 0.0 * decltype(kV)::unit) {
       throw std::domain_error("Kv must be greater than or equal to zero.");
     }
-    if (kA <= decltype(kA){0}) {
+    if (kA <= 0.0 * decltype(kA)::unit) {
       throw std::domain_error("Ka must be greater than zero.");
     }
 
@@ -157,15 +154,15 @@ class WPILIB_DLLEXPORT LinearSystemId {
    * @see <a
    * href="https://github.com/wpilibsuite/sysid">https://github.com/wpilibsuite/sysid</a>
    */
-  template <typename Distance>
-    requires std::same_as<mp::m, Distance> || std::same_as<mp::rad, Distance>
+  template <mp::Unit auto Distance>
+    requires(Distance == mp::m) || (Distance == mp::rad)
   static constexpr LinearSystem<2, 1, 2> IdentifyPositionSystem(
-      mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
-      mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA) {
-    if (kV < decltype(kV){0}) {
+      mp::quantity<mp::V / Velocity_t<Distance>::unit> kV,
+      mp::quantity<mp::V / Acceleration_t<Distance>::unit> kA) {
+    if (kV < 0.0 * decltype(kV)::unit) {
       throw std::domain_error("Kv must be greater than or equal to zero.");
     }
-    if (kA <= decltype(kA){0}) {
+    if (kA <= 0.0 * decltype(kA)::unit) {
       throw std::domain_error("Ka must be greater than zero.");
     }
 
@@ -204,16 +201,16 @@ class WPILIB_DLLEXPORT LinearSystemId {
       mp::quantity<mp::V / (mp::m / mp::s2)> kALinear,
       mp::quantity<mp::V / (mp::m / mp::s)> kVAngular,
       mp::quantity<mp::V / (mp::m / mp::s2)> kAAngular) {
-    if (kVLinear <= decltype(kVLinear){0}) {
+    if (kVLinear <= 0.0 * decltype(kVLinear)::unit) {
       throw std::domain_error("Kv,linear must be greater than zero.");
     }
-    if (kALinear <= decltype(kALinear){0}) {
+    if (kALinear <= 0.0 * decltype(kALinear)::unit) {
       throw std::domain_error("Ka,linear must be greater than zero.");
     }
-    if (kVAngular <= decltype(kVAngular){0}) {
+    if (kVAngular <= 0.0 * decltype(kVAngular)::unit) {
       throw std::domain_error("Kv,angular must be greater than zero.");
     }
-    if (kAAngular <= decltype(kAAngular){0}) {
+    if (kAAngular <= 0.0 * decltype(kAAngular)::unit) {
       throw std::domain_error("Ka,angular must be greater than zero.");
     }
 
@@ -268,16 +265,16 @@ class WPILIB_DLLEXPORT LinearSystemId {
       mp::quantity<mp::V / (mp::rad / mp::s)> kVAngular,
       mp::quantity<mp::V / (mp::rad / mp::s2)> kAAngular,
       mp::quantity<mp::m> trackwidth) {
-    if (kVLinear <= decltype(kVLinear){0}) {
+    if (kVLinear <= 0.0 * decltype(kVLinear)::unit) {
       throw std::domain_error("Kv,linear must be greater than zero.");
     }
-    if (kALinear <= decltype(kALinear){0}) {
+    if (kALinear <= 0.0 * decltype(kALinear)::unit) {
       throw std::domain_error("Ka,linear must be greater than zero.");
     }
-    if (kVAngular <= decltype(kVAngular){0}) {
+    if (kVAngular <= 0.0 * decltype(kVAngular)::unit) {
       throw std::domain_error("Kv,angular must be greater than zero.");
     }
-    if (kAAngular <= decltype(kAAngular){0}) {
+    if (kAAngular <= 0.0 * decltype(kAAngular)::unit) {
       throw std::domain_error("Ka,angular must be greater than zero.");
     }
     if (trackwidth <= 0.0 * mp::m) {
@@ -380,15 +377,15 @@ class WPILIB_DLLEXPORT LinearSystemId {
    *
    * @throws std::domain_error if kV < 0 or kA <= 0.
    */
-  template <typename Distance>
-    requires std::same_as<mp::m, Distance> || std::same_as<mp::rad, Distance>
+  template <mp::Unit auto Distance>
+    requires(Distance == mp::m) || (Distance == mp::rad)
   static constexpr LinearSystem<2, 1, 2> DCMotorSystem(
-      mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
-      mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA) {
-    if (kV < decltype(kV){0}) {
+      mp::quantity<mp::V / Velocity_t<Distance>::unit> kV,
+      mp::quantity<mp::V / Acceleration_t<Distance>::unit> kA) {
+    if (kV < 0.0 * decltype(kV)::unit) {
       throw std::domain_error("Kv must be greater than or equal to zero.");
     }
-    if (kA <= decltype(kA){0}) {
+    if (kA <= 0.0 * decltype(kA)::unit) {
       throw std::domain_error("Ka must be greater than zero.");
     }
 
diff --git a/wpimath/src/main/native/include/frc/trajectory/ExponentialProfile.h b/wpimath/src/main/native/include/frc/trajectory/ExponentialProfile.h
index 60e2023676..cc5cadbe7f 100644
--- a/wpimath/src/main/native/include/frc/trajectory/ExponentialProfile.h
+++ b/wpimath/src/main/native/include/frc/trajectory/ExponentialProfile.h
@@ -36,20 +36,19 @@ namespace frc {
  * `Calculate()` and to determine when the profile has completed via
  * `IsFinished()`.
  */
-template <class Distance, class Input>
+template <mp::Unit auto Distance, mp::Unit auto Input>
 class ExponentialProfile {
  public:
   using Distance_t = mp::quantity<Distance>;
-  using Velocity = units::compound_unit<Distance, units::inverse<mp::s>>;
+  inline static constexpr auto Velocity = Distance / mp::s;
   using Velocity_t = mp::quantity<Velocity>;
-  using Acceleration = units::compound_unit<Velocity, units::inverse<mp::s>>;
+  inline static constexpr auto Acceleration = Velocity / mp::s;
   using Input_t = mp::quantity<Input>;
-  using A_t = mp::quantity<units::inverse<mp::s>>;
-  using B_t =
-      mp::quantity<units::compound_unit<Acceleration, units::inverse<Input>>>;
-  using KV = units::compound_unit<Input, units::inverse<Velocity>>;
+  using A_t = mp::quantity<mp::one / mp::s>;
+  using B_t = mp::quantity<Acceleration / Input>;
+  inline static constexpr auto KV = Input / Velocity;
   using kV_t = mp::quantity<KV>;
-  using KA = units::compound_unit<Input, units::inverse<Acceleration>>;
+  inline static constexpr auto KA = Input / Acceleration;
   using kA_t = mp::quantity<KA>;
 
   /**
@@ -107,23 +106,23 @@ class ExponentialProfile {
     constexpr Velocity_t MaxVelocity() const { return -maxInput * B / A; }
 
     /// Maximum unsigned input voltage.
-    Input_t maxInput{0};
+    Input_t maxInput = 0.0 * Input;
 
     /// The State-Space 1x1 system matrix.
-    A_t A{0};
+    A_t A = 0.0 / mp::s;
 
     /// The State-Space 1x1 input matrix.
-    B_t B{0};
+    B_t B = 0.0 * Acceleration / Input;
   };
 
   /** Profile state. */
   class State {
    public:
     /// The position at this state.
-    Distance_t position{0};
+    Distance_t position = 0.0 * Distance;
 
     /// The velocity at this state.
-    Velocity_t velocity{0};
+    Velocity_t velocity = 0.0 * Velocity;
 
     constexpr bool operator==(const State&) const = default;
   };
@@ -277,7 +276,7 @@ class ExponentialProfile {
     // For cases 1 and 3, we want to subtract epsilon from the inflection point
     // velocity For cases 2 and 4, we want to add epsilon to the inflection
     // point velocity. For case 5, we have reached inflection point velocity.
-    auto epsilon = Velocity_t(1e-9);
+    auto epsilon = 1e-9 * Velocity;
     if (mp::abs(u_dir * m_constraints.MaxVelocity() -
                 inflectionPoint.velocity) < epsilon) {
       auto solvableV = inflectionPoint.velocity;
@@ -428,7 +427,7 @@ class ExponentialProfile {
     if (-1e-9 < mp::value(c) && mp::value(c) < 0) {
       // numeric instability - the heuristic gets it right but c is around
       // -1e-13
-      return Velocity_t(0);
+      return 0.0 * Velocity;
     }
 
     return u_dir * mp::sqrt(-c / a);
@@ -462,8 +461,8 @@ class ExponentialProfile {
       return xf < x_forward;
     }
 
-    auto a = v0 >= Velocity_t(0);
-    auto b = vf >= Velocity_t(0);
+    auto a = v0 >= 0.0 * Velocity;
+    auto b = vf >= 0.0 * Velocity;
     auto c = xf >= x_forward;
     auto d = xf >= x_reverse;
 
diff --git a/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h b/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h
index 901e3e737d..e019af088b 100644
--- a/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h
+++ b/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h
@@ -42,13 +42,13 @@ namespace frc {
  * `Calculate()` and to determine when the profile has completed via
  * `IsFinished()`.
  */
-template <class Distance>
+template <mp::Unit auto Distance>
 class TrapezoidProfile {
  public:
   using Distance_t = mp::quantity<Distance>;
-  using Velocity = units::compound_unit<Distance, units::inverse<mp::s>>;
+  inline static constexpr auto Velocity = Distance / mp::s;
   using Velocity_t = mp::quantity<Velocity>;
-  using Acceleration = units::compound_unit<Velocity, units::inverse<mp::s>>;
+  inline static constexpr auto Acceleration = Velocity / mp::s;
   using Acceleration_t = mp::quantity<Acceleration>;
 
   /**
@@ -57,10 +57,10 @@ class TrapezoidProfile {
   class Constraints {
    public:
     /// Maximum velocity.
-    Velocity_t maxVelocity{0};
+    Velocity_t maxVelocity = 0.0 * Velocity;
 
     /// Maximum acceleration.
-    Acceleration_t maxAcceleration{0};
+    Acceleration_t maxAcceleration = 0.0 * Acceleration;
 
     /**
      * Default constructor.
@@ -84,7 +84,8 @@ class TrapezoidProfile {
         wpi::math::MathSharedStore::ReportUsage("TrapezoidProfile", "");
       }
 
-      if (maxVelocity < Velocity_t{0} || maxAcceleration < Acceleration_t{0}) {
+      if (maxVelocity < 0.0 * Velocity ||
+          maxAcceleration < 0.0 * Acceleration) {
         throw std::domain_error("Constraints must be non-negative");
       }
     }
@@ -96,10 +97,10 @@ class TrapezoidProfile {
   class State {
    public:
     /// The position at this state.
-    Distance_t position{0};
+    Distance_t position = 0.0 * Distance;
 
     /// The velocity at this state.
-    Velocity_t velocity{0};
+    Velocity_t velocity = 0.0 * Velocity;
 
     constexpr bool operator==(const State&) const = default;
   };
@@ -162,10 +163,10 @@ class TrapezoidProfile {
         accelerationTime * accelerationTime * m_constraints.maxAcceleration;
 
     // Handle the case where the profile never reaches full speed
-    if (fullSpeedDist < Distance_t{0}) {
+    if (fullSpeedDist < 0.0 * Distance) {
       accelerationTime =
           mp::sqrt(fullTrapezoidDist / m_constraints.maxAcceleration);
-      fullSpeedDist = Distance_t{0};
+      fullSpeedDist = 0.0 * Distance;
     }
 
     m_endAccel = accelerationTime - cutoffBegin;
@@ -226,7 +227,7 @@ class TrapezoidProfile {
 
     Distance_t distToTarget = mp::abs(target - position);
 
-    if (distToTarget < Distance_t{1e-6}) {
+    if (distToTarget < 1e-6 * Distance) {
       return 0.0 * mp::s;
     }
 
@@ -246,11 +247,11 @@ class TrapezoidProfile {
 
     if (accelDist > distToTarget) {
       accelDist = distToTarget;
-      fullSpeedDist = Distance_t{0};
-      decelDist = Distance_t{0};
+      fullSpeedDist = 0.0 * Distance;
+      decelDist = 0.0 * Distance;
     } else if (accelDist + fullSpeedDist > distToTarget) {
       fullSpeedDist = distToTarget - accelDist;
-      decelDist = Distance_t{0};
+      decelDist = 0.0 * Distance;
     } else {
       decelDist = distToTarget - fullSpeedDist - accelDist;
     }
diff --git a/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h b/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h
index 881fddb03c..82a16f8cc4 100644
--- a/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h
+++ b/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h
@@ -40,7 +40,7 @@ class WPILIB_DLLEXPORT CentripetalAccelerationConstraint
     // We have to multiply by rad here to get the units to cancel out nicely.
     // The units library defines a unit for radians although it is technically
     // unitless.
-    return mp::sqrt(m_maxCentripetalAcceleration / mp::abs(curvature) * 1.0 *
+    return mp::sqrt(m_maxCentripetalAcceleration / mp::abs(curvature) *
                     mp::rad);
   }
 
diff --git a/wpimath/src/test/native/cpp/FormatterTest.cpp b/wpimath/src/test/native/cpp/FormatterTest.cpp
index d56d053534..b67214d18a 100644
--- a/wpimath/src/test/native/cpp/FormatterTest.cpp
+++ b/wpimath/src/test/native/cpp/FormatterTest.cpp
@@ -2,6 +2,7 @@
 // Open Source Software; you can modify and/or share it under the terms of
 // the WPILib BSD license file in the root directory of this project.
 
+#include <string_view>
 #include <vector>
 
 #include <fmt/format.h>
@@ -44,5 +45,6 @@ TEST(FormatterTest, Eigen) {
 }
 
 TEST(FormatterTest, Units) {
-  EXPECT_EQ("4 mps", fmt::format("{}", 4.0 * mp::m / mp::s));
+  using namespace std::literals;
+  EXPECT_EQ("4\0 m/s\0"sv, fmt::format("{}", 4.0 * mp::m / mp::s));
 }
diff --git a/wpimath/src/test/native/cpp/controller/ArmFeedforwardTest.cpp b/wpimath/src/test/native/cpp/controller/ArmFeedforwardTest.cpp
index 78f6d8bb48..ffbee6b3d0 100644
--- a/wpimath/src/test/native/cpp/controller/ArmFeedforwardTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/ArmFeedforwardTest.cpp
@@ -87,26 +87,26 @@ TEST(ArmFeedforwardTest, Calculate) {
   frc::ArmFeedforward armFF{Ks, Kg, Kv, Ka};
 
   // Calculate(angle, angular velocity)
-  EXPECT_NEAR(mp::value(armFF.Calculate(std::numbers::pi / 3 * 1.0 * mp::rad,
+  EXPECT_NEAR(mp::value(armFF.Calculate(std::numbers::pi / 3.0 * mp::rad,
                                         0.0 * mp::rad / mp::s)),
               0.5, 0.002);
-  EXPECT_NEAR(mp::value(armFF.Calculate(std::numbers::pi / 3 * 1.0 * mp::rad,
+  EXPECT_NEAR(mp::value(armFF.Calculate(std::numbers::pi / 3.0 * mp::rad,
                                         1.0 * mp::rad / mp::s)),
               2.5, 0.002);
 
   // Calculate(currentAngle, currentVelocity, nextAngle, dt)
-  CalculateAndSimulate(
-      armFF, Ks, Kv, Ka, Kg, std::numbers::pi / 3 * 1.0 * mp::rad,
-      1.0 * mp::rad / mp::s, 1.05 * mp::rad / mp::s, 20.0 * mp::ms);
-  CalculateAndSimulate(
-      armFF, Ks, Kv, Ka, Kg, std::numbers::pi / 3 * 1.0 * mp::rad,
-      1.0 * mp::rad / mp::s, 0.95 * mp::rad / mp::s, 20.0 * mp::ms);
-  CalculateAndSimulate(
-      armFF, Ks, Kv, Ka, Kg, -std::numbers::pi / 3 * 1.0 * mp::rad,
-      1.0 * mp::rad / mp::s, 1.05 * mp::rad / mp::s, 20.0 * mp::ms);
-  CalculateAndSimulate(
-      armFF, Ks, Kv, Ka, Kg, -std::numbers::pi / 3 * 1.0 * mp::rad,
-      1.0 * mp::rad / mp::s, 0.95 * mp::rad / mp::s, 20.0 * mp::ms);
+  CalculateAndSimulate(armFF, Ks, Kv, Ka, Kg, std::numbers::pi / 3.0 * mp::rad,
+                       1.0 * mp::rad / mp::s, 1.05 * mp::rad / mp::s,
+                       20.0 * mp::ms);
+  CalculateAndSimulate(armFF, Ks, Kv, Ka, Kg, std::numbers::pi / 3.0 * mp::rad,
+                       1.0 * mp::rad / mp::s, 0.95 * mp::rad / mp::s,
+                       20.0 * mp::ms);
+  CalculateAndSimulate(armFF, Ks, Kv, Ka, Kg, -std::numbers::pi / 3.0 * mp::rad,
+                       1.0 * mp::rad / mp::s, 1.05 * mp::rad / mp::s,
+                       20.0 * mp::ms);
+  CalculateAndSimulate(armFF, Ks, Kv, Ka, Kg, -std::numbers::pi / 3.0 * mp::rad,
+                       1.0 * mp::rad / mp::s, 0.95 * mp::rad / mp::s,
+                       20.0 * mp::ms);
 }
 
 TEST(ArmFeedforwardTest, CalculateIllConditionedModel) {
@@ -149,7 +149,7 @@ TEST(ArmFeedforwardTest, AchievableVelocity) {
   frc::ArmFeedforward armFF{Ks, Kg, Kv, Ka};
 
   EXPECT_NEAR(mp::value(armFF.MaxAchievableVelocity(
-                  12.0 * mp::V, std::numbers::pi / 3 * 1.0 * mp::rad,
+                  12.0 * mp::V, std::numbers::pi / 3.0 * mp::rad,
                   1.0 * mp::rad / mp::s2)),
               6, 0.002);
   EXPECT_NEAR(mp::value(armFF.MinAchievableVelocity(
@@ -166,19 +166,19 @@ TEST(ArmFeedforwardTest, AchievableAcceleration) {
   frc::ArmFeedforward armFF{Ks, Kg, Kv, Ka};
 
   EXPECT_NEAR(mp::value(armFF.MaxAchievableAcceleration(
-                  12.0 * mp::V, std::numbers::pi / 3 * 1.0 * mp::rad,
+                  12.0 * mp::V, std::numbers::pi / 3.0 * mp::rad,
                   1.0 * mp::rad / mp::s)),
               4.75, 0.002);
   EXPECT_NEAR(mp::value(armFF.MaxAchievableAcceleration(
-                  12.0 * mp::V, std::numbers::pi / 3 * 1.0 * mp::rad,
+                  12.0 * mp::V, std::numbers::pi / 3.0 * mp::rad,
                   -1.0 * mp::rad / mp::s)),
               6.75, 0.002);
   EXPECT_NEAR(mp::value(armFF.MinAchievableAcceleration(
-                  12.0 * mp::V, std::numbers::pi / 3 * 1.0 * mp::rad,
+                  12.0 * mp::V, std::numbers::pi / 3.0 * mp::rad,
                   1.0 * mp::rad / mp::s)),
               -7.25, 0.002);
   EXPECT_NEAR(mp::value(armFF.MinAchievableAcceleration(
-                  12.0 * mp::V, std::numbers::pi / 3 * 1.0 * mp::rad,
+                  12.0 * mp::V, std::numbers::pi / 3.0 * mp::rad,
                   -1.0 * mp::rad / mp::s)),
               -5.25, 0.002);
 }
diff --git a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
index bfb3ae39c6..3425e72ccf 100644
--- a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
@@ -16,10 +16,10 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
   constexpr auto maxA = 2.0 * mp::m / mp::s2;
   constexpr auto maxAlpha = 2.0 * mp::rad / mp::s2;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   DifferentialDriveAccelerationLimiter accelLimiter{plant, trackwidth, maxA,
                                                     maxAlpha};
@@ -111,16 +111,16 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
   constexpr auto trackwidth = 0.9 * mp::m;
   constexpr auto dt = 5.0 * mp::ms;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
 
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   // Limits are so high, they don't get hit, so states of constrained and
   // unconstrained systems should match
   DifferentialDriveAccelerationLimiter accelLimiter{
-      plant, trackwidth, 1e3 * mp::m / mp::s2, 1e3 * mp::rad / mp::s2};
+      plant, trackwidth, 1'000.0 * mp::m / mp::s2, 1'000.0 * mp::rad / mp::s2};
 
   Vectord<2> x{0.0, 0.0};
   Vectord<2> xAccelLimiter{0.0, 0.0};
@@ -179,10 +179,10 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
   constexpr auto maxA = 2.0 * mp::m / mp::s2;
   constexpr auto maxAlpha = 2.0 * mp::rad / mp::s2;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   DifferentialDriveAccelerationLimiter accelLimiter{plant, trackwidth, minA,
                                                     maxA, maxAlpha};
@@ -241,10 +241,10 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
 }
 
 TEST(DifferentialDriveAccelerationLimiterTest, MinAccelGreaterThanMaxAccel) {
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
   EXPECT_NO_THROW({
     DifferentialDriveAccelerationLimiter accelLimiter(
         plant, 1.0 * mp::m, 1.0 * mp::m / mp::s2, 1.0 * mp::rad / mp::s2);
diff --git a/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp b/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
index aba3b0f0f7..bc5b2b63c2 100644
--- a/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
@@ -13,10 +13,11 @@ namespace frc {
 TEST(ImplicitModelFollowerTest, SameModel) {
   constexpr auto dt = 5.0 * mp::ms;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   ImplicitModelFollower<2, 2> imf{plant, plant};
 
@@ -57,15 +58,15 @@ TEST(ImplicitModelFollowerTest, SameModel) {
 TEST(ImplicitModelFollowerTest, SlowerRefModel) {
   constexpr auto dt = 5.0 * mp::ms;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
 
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   // Linear acceleration is slower, but angular acceleration is the same
   auto plantRef = LinearSystemId::IdentifyDrivetrainSystem(
-      Kv_t{1.0}, Ka_t{2.0}, Kv_t{1.0}, Ka_t{1.0});
+      1.0 * Kv_unit, 2.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   ImplicitModelFollower<2, 2> imf{plant, plantRef};
 
diff --git a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
index d4c598c2b5..a7be41b013 100644
--- a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
@@ -11,8 +11,7 @@
 
 using namespace frc;
 
-template <typename Distance>
-  requires(units::traits::is_unit_v<Distance>)
+template <mp::Unit auto Distance>
 struct SimpleMotorFeedforwardProtoTestData {
   using Type = SimpleMotorFeedforward<Distance>;
 
diff --git a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
index adda5b9bd5..c9b1732220 100644
--- a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
@@ -11,8 +11,7 @@
 
 using namespace frc;
 
-template <typename Distance>
-  requires(units::traits::is_unit_v<Distance>)
+template <mp::Unit auto Distance>
 struct SimpleMotorFeedforwardStructTestData {
   using Type = SimpleMotorFeedforward<Distance>;
 
diff --git a/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp b/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
index 2cb2117514..c58501e5d0 100644
--- a/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
@@ -94,7 +94,7 @@ TEST(MerweUKFTest, DriveInit) {
 }
 
 TEST(MerweUKFTest, DriveConvergence) {
-  constexpr auto dt = 5.0 * mp::ms;
+  constexpr mp::quantity<mp::s> dt = 5.0 * mp::ms;
   constexpr auto rb = 0.8382 * mp::m / 2.0;  // Robot radius
 
   frc::MerweUKF<5, 2, 3> observer{DriveDynamics,
@@ -164,13 +164,15 @@ TEST(MerweUKFTest, DriveConvergence) {
 
   );
 
+  // Increase in rotation error caused by change to spline parameterizer
+  // constants
   auto finalPosition = trajectory.Sample(trajectory.TotalTime());
   EXPECT_NEAR(mp::value(finalPosition.pose.Translation().X()), observer.Xhat(0),
               0.055);
   EXPECT_NEAR(mp::value(finalPosition.pose.Translation().Y()), observer.Xhat(1),
               0.15);
   EXPECT_NEAR(mp::value(finalPosition.pose.Rotation().Radians()),
-              observer.Xhat(2), 0.000005);
+              observer.Xhat(2), 0.000015);
   EXPECT_NEAR(0.0, observer.Xhat(3), 0.1);
   EXPECT_NEAR(0.0, observer.Xhat(4), 0.1);
 }
diff --git a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
index f2412078f4..b674d905c6 100644
--- a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
@@ -94,7 +94,7 @@ TEST(S3UKFTest, DriveInit) {
 }
 
 TEST(S3UKFTest, DriveConvergence) {
-  constexpr auto dt = 5.0 * mp::ms;
+  constexpr mp::quantity<mp::s> dt = 5.0 * mp::ms;
   constexpr auto rb = 0.8382 * mp::m / 2.0;  // Robot radius
 
   frc::S3UKF<5, 2, 3> observer{DriveDynamics,
diff --git a/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
index 6d0aca0010..b87646d772 100644
--- a/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
@@ -91,6 +91,10 @@ TEST(Rotation2dTest, ToMatrix) {
   EXPECT_EQ(before, after);
 }
 
+constexpr bool IsNear(mp::quantity<mp::rad> lhs, mp::quantity<mp::rad> rhs) {
+  return lhs >= rhs - 1e-12 * mp::rad && lhs <= rhs + 1e-12 * mp::rad;
+}
+
 TEST(Rotation2dTest, Constexpr) {
   constexpr Rotation2d defaultCtor;
   constexpr Rotation2d radianCtor{5.0 * mp::rad};
@@ -104,8 +108,8 @@ TEST(Rotation2dTest, Constexpr) {
 
   static_assert(defaultCtor.Radians() == 0.0 * mp::rad);
   static_assert(degreeCtor.Degrees() == -90.0 * mp::deg);
-  static_assert(negated.Radians() == -5.0 * mp::rad + 1_tr);
-  static_assert(multiplied.Radians() == 10.0 * mp::rad - 2_tr);
+  static_assert(IsNear(negated.Radians(), -5.0 * mp::rad + 1.0 * mp::rev));
+  static_assert(IsNear(multiplied.Radians(), 10.0 * mp::rad - 2.0 * mp::rev));
   static_assert(subtracted == rotation45);
   static_assert(radianCtor != degreeCtor);
 }
diff --git a/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp
index 0023a04b1c..f0f0cfc564 100644
--- a/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp
@@ -107,7 +107,7 @@ TEST(Translation2dTest, Inequality) {
 }
 
 TEST(Translation2dTest, PolarConstructor) {
-  Translation2d one{std::sqrt(2) * 1.0 * mp::m, Rotation2d{45.0 * mp::deg}};
+  Translation2d one{std::sqrt(2) * mp::m, Rotation2d{45.0 * mp::deg}};
   EXPECT_DOUBLE_EQ(1.0, mp::value(one.X()));
   EXPECT_DOUBLE_EQ(1.0, mp::value(one.Y()));
 
diff --git a/wpimath/src/test/native/cpp/system/LinearSystemIDTest.cpp b/wpimath/src/test/native/cpp/system/LinearSystemIDTest.cpp
index b271fa232e..0aec6db7c3 100644
--- a/wpimath/src/test/native/cpp/system/LinearSystemIDTest.cpp
+++ b/wpimath/src/test/native/cpp/system/LinearSystemIDTest.cpp
@@ -82,10 +82,10 @@ TEST(LinearSystemIDTest, IdentifyPositionSystem) {
 
 #if __GNUC__ <= 11
   auto model = frc::LinearSystemId::IdentifyPositionSystem<mp::m>(
-      kv * 1.0 * mp::V / (mp::m / mp::s), ka * 1.0 * mp::V / (mp::m / mp::s2));
+      kv * mp::V / (mp::m / mp::s), ka * mp::V / (mp::m / mp::s2));
 #else
   constexpr auto model = frc::LinearSystemId::IdentifyPositionSystem<mp::m>(
-      kv * 1.0 * mp::V / (mp::m / mp::s), ka * 1.0 * mp::V / (mp::m / mp::s2));
+      kv * mp::V / (mp::m / mp::s), ka * mp::V / (mp::m / mp::s2));
 #endif
 
   ASSERT_TRUE(model.A().isApprox(
@@ -102,10 +102,10 @@ TEST(LinearSystemIDTest, IdentifyVelocitySystem) {
 
 #if __GNUC__ <= 11
   auto model = frc::LinearSystemId::IdentifyVelocitySystem<mp::m>(
-      kv * 1.0 * mp::V / (mp::m / mp::s), ka * 1.0 * mp::V / (mp::m / mp::s2));
+      kv * mp::V / (mp::m / mp::s), ka * mp::V / (mp::m / mp::s2));
 #else
   constexpr auto model = frc::LinearSystemId::IdentifyVelocitySystem<mp::m>(
-      kv * 1.0 * mp::V / (mp::m / mp::s), ka * 1.0 * mp::V / (mp::m / mp::s2));
+      kv * mp::V / (mp::m / mp::s), ka * mp::V / (mp::m / mp::s2));
 #endif
 
   ASSERT_TRUE(model.A().isApprox(frc::Matrixd<1, 1>{-kv / ka}, 0.001));
