diff --git a/apriltag/src/test/native/cpp/AprilTagJsonTest.cpp b/apriltag/src/test/native/cpp/AprilTagJsonTest.cpp
index a9beb4ce5..7388a2a8c 100644
--- a/apriltag/src/test/native/cpp/AprilTagJsonTest.cpp
+++ b/apriltag/src/test/native/cpp/AprilTagJsonTest.cpp
@@ -9,6 +9,7 @@
 #include "wpi/apriltag/AprilTag.hpp"
 #include "wpi/apriltag/AprilTagFieldLayout.hpp"
 #include "wpi/math/geometry/Pose3d.hpp"
+#include "wpi/units-usc.hpp"
 #include "wpi/util/json.hpp"
 
 using namespace wpi::apriltag;
diff --git a/apriltag/src/test/native/cpp/AprilTagPoseSetOriginTest.cpp b/apriltag/src/test/native/cpp/AprilTagPoseSetOriginTest.cpp
index ed8c27f42..f2a7d18ec 100644
--- a/apriltag/src/test/native/cpp/AprilTagPoseSetOriginTest.cpp
+++ b/apriltag/src/test/native/cpp/AprilTagPoseSetOriginTest.cpp
@@ -9,6 +9,7 @@
 #include "wpi/apriltag/AprilTag.hpp"
 #include "wpi/apriltag/AprilTagFieldLayout.hpp"
 #include "wpi/math/geometry/Pose3d.hpp"
+#include "wpi/units-usc.hpp"
 #include "wpi/util/json.hpp"
 
 using namespace wpi::apriltag;
diff --git a/apriltag/src/test/native/cpp/LoadConfigTest.cpp b/apriltag/src/test/native/cpp/LoadConfigTest.cpp
index b7499b8f3..4779a062d 100644
--- a/apriltag/src/test/native/cpp/LoadConfigTest.cpp
+++ b/apriltag/src/test/native/cpp/LoadConfigTest.cpp
@@ -8,6 +8,7 @@
 
 #include "wpi/apriltag/AprilTagFieldLayout.hpp"
 #include "wpi/apriltag/AprilTagFields.hpp"
+#include "wpi/units-usc.hpp"
 
 namespace wpi::apriltag {
 
diff --git a/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp b/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp
index 10df86ca5..4334fb571 100644
--- a/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp
+++ b/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp
@@ -16,8 +16,7 @@
 
 namespace wpi::cmd::sysid {
 
-using ramp_rate_t = wpi::units::unit_t<wpi::units::compound_unit<
-    mp::V, wpi::units::inverse<mp::s>>>;
+using ramp_rate_t = mp::quantity<mp::V / mp::s>;
 
 /** Hardware-independent configuration for a SysId test routine. */
 class Config {
diff --git a/glass/src/lib/native/cpp/other/Field2D.cpp b/glass/src/lib/native/cpp/other/Field2D.cpp
index 3a330c440..b4357cedf 100644
--- a/glass/src/lib/native/cpp/other/Field2D.cpp
+++ b/glass/src/lib/native/cpp/other/Field2D.cpp
@@ -272,9 +272,9 @@ static DisplayUnits gDisplayUnits = kDisplayMeters;
 static double ConvertDisplayLength(mp::quantity<mp::m> v) {
   switch (gDisplayUnits) {
     case kDisplayFeet:
-      return mp::value(v.convert<wpi::units::feet>());
+      return mp::value(v.in(mp::ft));
     case kDisplayInches:
-      return mp::value(v.convert<wpi::units::inches>());
+      return mp::value(v.in(mp::in));
     case kDisplayMeters:
     default:
       return mp::value(v);
diff --git a/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp b/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp
index df3be984e..7edc08732 100644
--- a/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp
+++ b/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp
@@ -87,7 +87,7 @@ class UnitSubscriber : public Subscriber {
    * @return value
    */
   ValueType Get(ParamType defaultValue) const {
-    return T{::wpi::nt::GetDouble(m_subHandle, mp::value(defaultValue))};
+    return ::wpi::nt::GetDouble(m_subHandle, mp::value(defaultValue)) * T::unit;
   }
 
   /**
@@ -300,7 +300,9 @@ class UnitTopic final : public Topic {
    *
    * @return True if unit matches, false if not matching or topic not published.
    */
-  bool IsMatchingUnit() const { return GetProperty("unit") == T{}.name(); }
+  bool IsMatchingUnit() const {
+    return GetProperty("unit") == mp::name(T::unit);
+  }
 
   /**
    * Create a new subscriber to the topic.
@@ -369,7 +371,7 @@ class UnitTopic final : public Topic {
   [[nodiscard]]
   PublisherType Publish(const PubSubOptions& options = kDefaultPubSubOptions) {
     return UnitPublisher<T>{::wpi::nt::PublishEx(
-        m_handle, NT_DOUBLE, "double", {{"unit", T{}.name()}}, options)};
+        m_handle, NT_DOUBLE, "double", {{"unit", mp::name(T::unit)}}, options)};
   }
 
   /**
@@ -395,7 +397,7 @@ class UnitTopic final : public Topic {
       std::string_view typeString, const wpi::util::json& properties,
       const PubSubOptions& options = kDefaultPubSubOptions) {
     wpi::util::json props = properties;
-    props["unit"] = T{}.name();
+    props["unit"] = mp::name(T::unit);
     return UnitPublisher<T>{
         ::wpi::nt::PublishEx(m_handle, NT_DOUBLE, typeString, props, options)};
   }
diff --git a/tools/sysid/src/main/native/cpp/analysis/FeedbackAnalysis.cpp b/tools/sysid/src/main/native/cpp/analysis/FeedbackAnalysis.cpp
index 4009fae2b..96a44b783 100644
--- a/tools/sysid/src/main/native/cpp/analysis/FeedbackAnalysis.cpp
+++ b/tools/sysid/src/main/native/cpp/analysis/FeedbackAnalysis.cpp
@@ -14,8 +14,8 @@
 
 using namespace sysid;
 
-using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
+inline constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+inline constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
 using Matrix1d = Eigen::Matrix<double, 1, 1>;
 
 FeedbackGains sysid::CalculatePositionFeedbackGains(
@@ -43,7 +43,7 @@ FeedbackGains sysid::CalculatePositionFeedbackGains(
 
   auto system =
       wpi::math::LinearSystemId::IdentifyPositionSystem<mp::m>(
-          Kv_t{Kv}, Ka_t{Ka});
+          Kv * Kv_unit, Ka * Ka_unit);
 
   wpi::math::LinearQuadraticRegulator<2, 1> controller{
       system, {params.qp, params.qv}, {params.r}, preset.period};
@@ -72,7 +72,7 @@ FeedbackGains sysid::CalculateVelocityFeedbackGains(
 
   auto system =
       wpi::math::LinearSystemId::IdentifyVelocitySystem<mp::m>(
-          Kv_t{Kv}, Ka_t{Ka});
+          Kv * Kv_unit, Ka * Ka_unit);
   wpi::math::LinearQuadraticRegulator<1, 1> controller{
       system, {params.qv}, {params.r}, preset.period};
   controller.LatencyCompensate(system, preset.period, preset.measurementDelay);
diff --git a/tools/sysid/src/main/native/cpp/view/DataSelector.cpp b/tools/sysid/src/main/native/cpp/view/DataSelector.cpp
index 387443bc5..da3bd2025 100644
--- a/tools/sysid/src/main/native/cpp/view/DataSelector.cpp
+++ b/tools/sysid/src/main/native/cpp/view/DataSelector.cpp
@@ -252,8 +252,13 @@ static void AddSamples(std::vector<MotorData::Run::Sample<T>>& samples,
       [](const auto& datapoint, double val) { return datapoint.first < val; });
 
   for (auto it = begin; it != end; ++it) {
-    samples.emplace_back(it->first * 1.0e-6 * mp::s,
-                         T{it->second});
+    if constexpr (mp::Quantity<T>) {
+      samples.emplace_back(it->first * 1.0e-6 * mp::s,
+                           it->second * T::unit);
+    } else {
+      samples.emplace_back(it->first * 1.0e-6 * mp::s,
+                           T{it->second});
+    }
   }
 }
 
diff --git a/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp b/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp
index 9fadb8e4e..821e2e09e 100644
--- a/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp
+++ b/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp
@@ -38,9 +38,8 @@ ElevatorSim::ElevatorSim(const wpi::math::DCMotor& gearbox, double gearing,
                   gearbox, minHeight, maxHeight, simulateGravity,
                   startingHeight, measurementStdDevs) {}
 
-template <typename Distance>
-  requires std::same_as<mp::m, Distance> ||
-           std::same_as<mp::rad, Distance>
+template <mp::Unit auto Distance>
+  requires(mp::m == Distance) || (mp::rad == Distance)
 ElevatorSim::ElevatorSim(mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
                          mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA,
                          const wpi::math::DCMotor& gearbox,
@@ -89,9 +88,8 @@ mp::quantity<mp::A> ElevatorSim::GetCurrentDraw() const {
   // is spinning 10x faster than the output.
 
   double kA = 1.0 / m_plant.B(1, 0);
-  using Kv_t = wpi::units::unit_t<wpi::units::compound_unit<
-      mp::V, wpi::units::inverse<mp::m / mp::s>>>;
-  Kv_t Kv = Kv_t{kA * m_plant.A(1, 1)};
+  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
+  Kv_t Kv = kA * m_plant.A(1, 1) * Kv_t::unit;
   mp::quantity<mp::m / mp::s> velocity =
       m_x(1) * mp::m / mp::s;
   mp::quantity<mp::rad / mp::s> motorVelocity = velocity * Kv * m_gearbox.Kv;
diff --git a/wpilibc/src/main/native/cpp/simulation/RoboRioSim.cpp b/wpilibc/src/main/native/cpp/simulation/RoboRioSim.cpp
index 1a711d480..83bf466ab 100644
--- a/wpilibc/src/main/native/cpp/simulation/RoboRioSim.cpp
+++ b/wpilibc/src/main/native/cpp/simulation/RoboRioSim.cpp
@@ -123,12 +123,12 @@ std::unique_ptr<CallbackStore> RoboRioSim::RegisterCPUTempCallback(
   return store;
 }
 
-wpi::units::celsius_t RoboRioSim::GetCPUTemp() {
-  return wpi::units::celsius_t{HALSIM_GetRoboRioCPUTemp()};
+mp::quantity_point<mp::deg_C> RoboRioSim::GetCPUTemp() {
+  return mp::absolute<mp::deg_C>(HALSIM_GetRoboRioCPUTemp());
 }
 
-void RoboRioSim::SetCPUTemp(wpi::units::celsius_t cpuTemp) {
-  HALSIM_SetRoboRioCPUTemp(mp::value(cpuTemp));
+void RoboRioSim::SetCPUTemp(mp::quantity_point<mp::deg_C> cpuTemp) {
+  HALSIM_SetRoboRioCPUTemp(mp::value(cpuTemp.quantity_from_zero()));
 }
 
 std::unique_ptr<CallbackStore> RoboRioSim::RegisterTeamNumberCallback(
diff --git a/wpilibc/src/main/native/cpp/system/RobotController.cpp b/wpilibc/src/main/native/cpp/system/RobotController.cpp
index e514a1c06..e0f984a34 100644
--- a/wpilibc/src/main/native/cpp/system/RobotController.cpp
+++ b/wpilibc/src/main/native/cpp/system/RobotController.cpp
@@ -155,11 +155,11 @@ void RobotController::SetBrownoutVoltage(mp::quantity<mp::V> brownoutVoltage) {
   WPILIB_CheckErrorStatus(status, "SetBrownoutVoltage");
 }
 
-wpi::units::celsius_t RobotController::GetCPUTemp() {
+mp::quantity_point<mp::deg_C> RobotController::GetCPUTemp() {
   int32_t status = 0;
   double retVal = HAL_GetCPUTemp(&status);
   WPILIB_CheckErrorStatus(status, "GetCPUTemp");
-  return wpi::units::celsius_t{retVal};
+  return mp::absolute<mp::deg_C>(retVal);
 }
 
 CANStatus RobotController::GetCANStatus(int busId) {
diff --git a/wpilibc/src/main/native/include/wpi/hardware/pneumatic/PneumaticsBase.hpp b/wpilibc/src/main/native/include/wpi/hardware/pneumatic/PneumaticsBase.hpp
index 094d9a858..7d2768d38 100644
--- a/wpilibc/src/main/native/include/wpi/hardware/pneumatic/PneumaticsBase.hpp
+++ b/wpilibc/src/main/native/include/wpi/hardware/pneumatic/PneumaticsBase.hpp
@@ -9,8 +9,8 @@
 
 #include "wpi/hardware/pneumatic/CompressorConfigType.hpp"
 #include "wpi/hardware/pneumatic/PneumaticsModuleType.hpp"
-#include "wpi/units-usc.hpp"
 #include "wpi/units.hpp"
+#include "wpi/units-usc.hpp"
 
 namespace wpi {
 class Solenoid;
diff --git a/wpilibc/src/main/native/include/wpi/simulation/ElevatorSim.hpp b/wpilibc/src/main/native/include/wpi/simulation/ElevatorSim.hpp
index a6ee90868..afdbd2326 100644
--- a/wpilibc/src/main/native/include/wpi/simulation/ElevatorSim.hpp
+++ b/wpilibc/src/main/native/include/wpi/simulation/ElevatorSim.hpp
@@ -16,15 +16,11 @@ namespace wpi::sim {
  */
 class ElevatorSim : public LinearSystemSim<2, 1, 2> {
  public:
-  template <typename Distance>
-  using Velocity_t = wpi::units::unit_t<wpi::units::compound_unit<
-      Distance, wpi::units::inverse<mp::s>>>;
+  template <mp::Unit auto Distance>
+  using Velocity_t = mp::quantity<Distance / mp::s>;
 
-  template <typename Distance>
-  using Acceleration_t = wpi::units::unit_t<wpi::units::compound_unit<
-      wpi::units::compound_unit<Distance,
-                                wpi::units::inverse<mp::s>>,
-      wpi::units::inverse<mp::s>>>;
+  template <mp::Unit auto Distance>
+  using Acceleration_t = mp::quantity<Distance / mp::s / mp::s>;
 
   /**
    * Constructs a simulated elevator mechanism.
@@ -82,9 +78,8 @@ class ElevatorSim : public LinearSystemSim<2, 1, 2> {
    * @param startingHeight     The starting height of the elevator.
    * @param measurementStdDevs The standard deviation of the measurements.
    */
-  template <typename Distance>
-    requires std::same_as<mp::m, Distance> ||
-             std::same_as<mp::rad, Distance>
+  template <mp::Unit auto Distance>
+    requires(mp::m == Distance) || (mp::rad == Distance)
   ElevatorSim(mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
               mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA,
               const wpi::math::DCMotor& gearbox, mp::quantity<mp::m> minHeight,
diff --git a/wpilibc/src/main/native/include/wpi/simulation/RoboRioSim.hpp b/wpilibc/src/main/native/include/wpi/simulation/RoboRioSim.hpp
index f023eb446..1165060ae 100644
--- a/wpilibc/src/main/native/include/wpi/simulation/RoboRioSim.hpp
+++ b/wpilibc/src/main/native/include/wpi/simulation/RoboRioSim.hpp
@@ -189,14 +189,14 @@ class RoboRioSim {
    *
    * @return the cpu temp.
    */
-  static wpi::units::celsius_t GetCPUTemp();
+  static mp::quantity_point<mp::deg_C> GetCPUTemp();
 
   /**
    * Define the cpu temp.
    *
    * @param cpuTemp the new cpu temp.
    */
-  static void SetCPUTemp(wpi::units::celsius_t cpuTemp);
+  static void SetCPUTemp(mp::quantity_point<mp::deg_C> cpuTemp);
 
   /**
    * Register a callback to be run whenever the team number changes.
diff --git a/wpilibc/src/main/native/include/wpi/sysid/SysIdRoutineLog.hpp b/wpilibc/src/main/native/include/wpi/sysid/SysIdRoutineLog.hpp
index 2e82c135e..69faab69a 100644
--- a/wpilibc/src/main/native/include/wpi/sysid/SysIdRoutineLog.hpp
+++ b/wpilibc/src/main/native/include/wpi/sysid/SysIdRoutineLog.hpp
@@ -58,7 +58,7 @@ class SysIdRoutineLog {
      * @return The motor log (for call chaining).
      */
     MotorLog& voltage(mp::quantity<mp::V> voltage) {
-      return value("voltage", mp::value(voltage), voltage.name());
+      return value("voltage", mp::value(voltage), mp::unit_name(voltage));
     }
 
     /**
@@ -68,7 +68,7 @@ class SysIdRoutineLog {
      * @return The motor log (for call chaining).
      */
     MotorLog& position(mp::quantity<mp::m> position) {
-      return value("position", mp::value(position), position.name());
+      return value("position", mp::value(position), mp::unit_name(position));
     }
 
     /**
@@ -78,7 +78,7 @@ class SysIdRoutineLog {
      * @return The motor log (for call chaining).
      */
     MotorLog& position(mp::quantity<mp::rev> position) {
-      return value("position", mp::value(position), position.name());
+      return value("position", mp::value(position), mp::unit_name(position));
     }
 
     /**
@@ -88,7 +88,7 @@ class SysIdRoutineLog {
      * @return The motor log (for call chaining).
      */
     MotorLog& velocity(mp::quantity<mp::m / mp::s> velocity) {
-      return value("velocity", mp::value(velocity), velocity.name());
+      return value("velocity", mp::value(velocity), mp::unit_name(velocity));
     }
 
     /**
@@ -98,7 +98,7 @@ class SysIdRoutineLog {
      * @return The motor log (for call chaining).
      */
     MotorLog& velocity(mp::quantity<mp::rev / mp::s> velocity) {
-      return value("velocity", mp::value(velocity), velocity.name());
+      return value("velocity", mp::value(velocity), mp::unit_name(velocity));
     }
 
     /**
@@ -111,7 +111,8 @@ class SysIdRoutineLog {
      */
     MotorLog& acceleration(
         mp::quantity<mp::m / mp::s2> acceleration) {
-      return value("acceleration", mp::value(acceleration), acceleration.name());
+      return value("acceleration", mp::value(acceleration),
+                   mp::unit_name(acceleration));
     }
 
     /**
@@ -124,7 +125,8 @@ class SysIdRoutineLog {
      */
     MotorLog& acceleration(
         mp::quantity<mp::rev / mp::s2> acceleration) {
-      return value("acceleration", mp::value(acceleration), acceleration.name());
+      return value("acceleration", mp::value(acceleration),
+                   mp::unit_name(acceleration));
     }
 
     /**
@@ -136,7 +138,7 @@ class SysIdRoutineLog {
      * @return The motor log (for call chaining).
      */
     MotorLog& current(mp::quantity<mp::A> current) {
-      return value("current", mp::value(current), current.name());
+      return value("current", mp::value(current), mp::unit_name(current));
     }
 
    private:
diff --git a/wpilibc/src/main/native/include/wpi/system/RobotController.hpp b/wpilibc/src/main/native/include/wpi/system/RobotController.hpp
index 134eca888..379d8495a 100644
--- a/wpilibc/src/main/native/include/wpi/system/RobotController.hpp
+++ b/wpilibc/src/main/native/include/wpi/system/RobotController.hpp
@@ -191,7 +191,7 @@ class RobotController {
    *
    * @return current CPU temperature
    */
-  static wpi::units::celsius_t GetCPUTemp();
+  static mp::quantity_point<mp::deg_C> GetCPUTemp();
 
   /**
    * Get the current status of the CAN bus.
diff --git a/wpilibc/src/test/native/cpp/UnitNetworkTablesTest.cpp b/wpilibc/src/test/native/cpp/UnitNetworkTablesTest.cpp
index afd9b68e7..6fde43832 100644
--- a/wpilibc/src/test/native/cpp/UnitNetworkTablesTest.cpp
+++ b/wpilibc/src/test/native/cpp/UnitNetworkTablesTest.cpp
@@ -23,7 +23,7 @@ TEST_F(UnitNetworkTablesTest, Publish) {
       wpi::nt::UnitTopic<mp::quantity<mp::m>>{inst.GetTopic("meterTest")};
   auto pub = topic.Publish();
   pub.Set(2.0 * mp::m);
-  ASSERT_EQ(topic.GetProperty("unit"), "meter");
+  ASSERT_EQ(topic.GetProperty("unit"), "m");
   ASSERT_TRUE(topic.IsMatchingUnit());
 }
 
diff --git a/wpilibc/src/test/native/cpp/simulation/RoboRioSimTest.cpp b/wpilibc/src/test/native/cpp/simulation/RoboRioSimTest.cpp
index f54efb784..b1a5908fb 100644
--- a/wpilibc/src/test/native/cpp/simulation/RoboRioSimTest.cpp
+++ b/wpilibc/src/test/native/cpp/simulation/RoboRioSimTest.cpp
@@ -97,11 +97,11 @@ TEST(RoboRioSimTest, SetCPUTemp) {
       RoboRioSim::RegisterCPUTempCallback(callback.GetCallback(), false);
   constexpr double kCPUTemp = 100.0;
 
-  RoboRioSim::SetCPUTemp(wpi::units::celsius_t{kCPUTemp});
+  RoboRioSim::SetCPUTemp(mp::absolute<mp::deg_C>(kCPUTemp));
   EXPECT_TRUE(callback.WasTriggered());
   EXPECT_EQ(kCPUTemp, callback.GetLastValue());
-  EXPECT_EQ(kCPUTemp, mp::value(RoboRioSim::GetCPUTemp()));
-  EXPECT_EQ(kCPUTemp, mp::value(RobotController::GetCPUTemp()));
+  EXPECT_EQ(kCPUTemp, mp::value(RoboRioSim::GetCPUTemp().quantity_from_zero()));
+  EXPECT_EQ(kCPUTemp, mp::value(RobotController::GetCPUTemp().quantity_from_zero()));
 }
 
 TEST(RoboRioSimTest, SetTeamNumber) {
diff --git a/wpilibc/src/test/native/cpp/simulation/SingleJointedArmSimTest.cpp b/wpilibc/src/test/native/cpp/simulation/SingleJointedArmSimTest.cpp
index c9234a7b7..228c2fd57 100644
--- a/wpilibc/src/test/native/cpp/simulation/SingleJointedArmSimTest.cpp
+++ b/wpilibc/src/test/native/cpp/simulation/SingleJointedArmSimTest.cpp
@@ -8,6 +8,8 @@
 
 #include <gtest/gtest.h>
 
+#include "wpi/units-usc.hpp"
+
 TEST(SingleJointedArmTest, Disabled) {
   wpi::sim::SingleJointedArmSim sim(wpi::math::DCMotor::Vex775Pro(2), 300,
                                     3.0 * mp::kg * mp::m2, 30.0 * mp::in, -180.0 * mp::deg, 0.0 * mp::deg, true,
diff --git a/wpilibcExamples/src/main/cpp/examples/ArmSimulation/include/Constants.hpp b/wpilibcExamples/src/main/cpp/examples/ArmSimulation/include/Constants.hpp
index c6092918d..b9a1d26e8 100644
--- a/wpilibcExamples/src/main/cpp/examples/ArmSimulation/include/Constants.hpp
+++ b/wpilibcExamples/src/main/cpp/examples/ArmSimulation/include/Constants.hpp
@@ -6,8 +6,8 @@
 
 #include <numbers>
 
-#include "wpi/units-usc.hpp"
 #include "wpi/units.hpp"
+#include "wpi/units-usc.hpp"
 
 /**
  * The Constants header provides a convenient place for teams to hold robot-wide
diff --git a/wpilibcExamples/src/main/cpp/examples/ElevatorExponentialSimulation/include/Constants.hpp b/wpilibcExamples/src/main/cpp/examples/ElevatorExponentialSimulation/include/Constants.hpp
index 502c92f43..d09fd3a16 100644
--- a/wpilibcExamples/src/main/cpp/examples/ElevatorExponentialSimulation/include/Constants.hpp
+++ b/wpilibcExamples/src/main/cpp/examples/ElevatorExponentialSimulation/include/Constants.hpp
@@ -6,8 +6,8 @@
 
 #include <numbers>
 
-#include "wpi/units-usc.hpp"
 #include "wpi/units.hpp"
+#include "wpi/units-usc.hpp"
 
 /**
  * The Constants header provides a convenient place for teams to hold robot-wide
diff --git a/wpilibcExamples/src/main/cpp/examples/ElevatorSimulation/include/Constants.hpp b/wpilibcExamples/src/main/cpp/examples/ElevatorSimulation/include/Constants.hpp
index 4459e8ddc..2e8720f76 100644
--- a/wpilibcExamples/src/main/cpp/examples/ElevatorSimulation/include/Constants.hpp
+++ b/wpilibcExamples/src/main/cpp/examples/ElevatorSimulation/include/Constants.hpp
@@ -6,8 +6,8 @@
 
 #include <numbers>
 
-#include "wpi/units-usc.hpp"
 #include "wpi/units.hpp"
+#include "wpi/units-usc.hpp"
 
 /**
  * The Constants header provides a convenient place for teams to hold robot-wide
diff --git a/wpilibcExamples/src/main/cpp/examples/RapidReactCommandBot/include/Constants.hpp b/wpilibcExamples/src/main/cpp/examples/RapidReactCommandBot/include/Constants.hpp
index 7379b1233..f96db9e96 100644
--- a/wpilibcExamples/src/main/cpp/examples/RapidReactCommandBot/include/Constants.hpp
+++ b/wpilibcExamples/src/main/cpp/examples/RapidReactCommandBot/include/Constants.hpp
@@ -6,8 +6,8 @@
 
 #include <numbers>
 
-#include "wpi/units-usc.hpp"
 #include "wpi/units.hpp"
+#include "wpi/units-usc.hpp"
 
 namespace DriveConstants {
 inline constexpr int kLeftMotor1Port = 0;
diff --git a/wpilibcExamples/src/main/cpp/examples/RomiReference/include/commands/AutonomousDistance.hpp b/wpilibcExamples/src/main/cpp/examples/RomiReference/include/commands/AutonomousDistance.hpp
index 6029e35a1..41ef42035 100644
--- a/wpilibcExamples/src/main/cpp/examples/RomiReference/include/commands/AutonomousDistance.hpp
+++ b/wpilibcExamples/src/main/cpp/examples/RomiReference/include/commands/AutonomousDistance.hpp
@@ -9,6 +9,7 @@
 #include "subsystems/Drivetrain.hpp"
 #include "wpi/commands2/CommandHelper.hpp"
 #include "wpi/commands2/SequentialCommandGroup.hpp"
+#include "wpi/units-usc.hpp"
 
 class AutonomousDistance
     : public wpi::cmd::CommandHelper<wpi::cmd::SequentialCommandGroup,
diff --git a/wpilibcExamples/src/main/cpp/examples/SysIdRoutine/include/Constants.hpp b/wpilibcExamples/src/main/cpp/examples/SysIdRoutine/include/Constants.hpp
index a9f0eef6b..18fb06bca 100644
--- a/wpilibcExamples/src/main/cpp/examples/SysIdRoutine/include/Constants.hpp
+++ b/wpilibcExamples/src/main/cpp/examples/SysIdRoutine/include/Constants.hpp
@@ -7,8 +7,8 @@
 #include <array>
 #include <numbers>
 
-#include "wpi/units-usc.hpp"
 #include "wpi/units.hpp"
+#include "wpi/units-usc.hpp"
 
 namespace constants {
 namespace drive {
@@ -30,14 +30,10 @@ inline constexpr mp::quantity<mp::m> kEncoderDistancePerPulse =
 
 namespace shooter {
 
-using kv_unit = wpi::units::compound_unit<
-    wpi::units::compound_unit<mp::V, mp::s>,
-    wpi::units::inverse<wpi::units::turns>>;
+inline static constexpr auto kv_unit = mp::V * mp::s / mp::rev;
 using kv_unit_t = mp::quantity<kv_unit>;
 
-using ka_unit = wpi::units::compound_unit<
-    mp::V,
-    wpi::units::inverse<wpi::units::turns_per_second_squared>>;
+inline static constexpr auto ka_unit = mp::V / (mp::rev / mp::s2);
 using ka_unit_t = mp::quantity<ka_unit>;
 
 inline constexpr std::array<int, 2> kEncoderPorts = {4, 5};
diff --git a/wpilibcExamples/src/main/cpp/examples/XRPReference/include/commands/AutonomousDistance.hpp b/wpilibcExamples/src/main/cpp/examples/XRPReference/include/commands/AutonomousDistance.hpp
index 6029e35a1..41ef42035 100644
--- a/wpilibcExamples/src/main/cpp/examples/XRPReference/include/commands/AutonomousDistance.hpp
+++ b/wpilibcExamples/src/main/cpp/examples/XRPReference/include/commands/AutonomousDistance.hpp
@@ -9,6 +9,7 @@
 #include "subsystems/Drivetrain.hpp"
 #include "wpi/commands2/CommandHelper.hpp"
 #include "wpi/commands2/SequentialCommandGroup.hpp"
+#include "wpi/units-usc.hpp"
 
 class AutonomousDistance
     : public wpi::cmd::CommandHelper<wpi::cmd::SequentialCommandGroup,
diff --git a/wpilibcExamples/src/test/cpp/examples/ArmSimulation/cpp/ArmSimulationTest.cpp b/wpilibcExamples/src/test/cpp/examples/ArmSimulation/cpp/ArmSimulationTest.cpp
index cc3970a0a..5f96ab65b 100644
--- a/wpilibcExamples/src/test/cpp/examples/ArmSimulation/cpp/ArmSimulationTest.cpp
+++ b/wpilibcExamples/src/test/cpp/examples/ArmSimulation/cpp/ArmSimulationTest.cpp
@@ -144,5 +144,5 @@ INSTANTIATE_TEST_SUITE_P(
     testing::Values(kDefaultArmSetpoint, 25.0 * mp::deg, 50.0 * mp::deg),
     [](const testing::TestParamInfo<mp::quantity<mp::deg>>& info) {
       return testing::PrintToString(mp::value(info.param))
-          .append(std::string(info.param.abbreviation()));
+          .append(mp::portable_unit_name(info.param));
     });
diff --git a/wpimath/src/main/native/include/wpi/math/controller/ArmFeedforward.hpp b/wpimath/src/main/native/include/wpi/math/controller/ArmFeedforward.hpp
index df17a3be9..293b06ead 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/ArmFeedforward.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/ArmFeedforward.hpp
@@ -18,14 +18,11 @@ namespace wpi::math {
  */
 class WPILIB_DLLEXPORT ArmFeedforward {
  public:
-  using Angle = mp::rad;
-  using Velocity = mp::rad / mp::s;
-  using Acceleration =
-      wpi::units::compound_unit<mp::rad / mp::s, wpi::units::inverse<mp::s>>;
-  using kv_unit =
-      wpi::units::compound_unit<mp::V, wpi::units::inverse<mp::rad / mp::s>>;
-  using ka_unit =
-      wpi::units::compound_unit<mp::V, wpi::units::inverse<Acceleration>>;
+  static constexpr auto Angle = mp::rad;
+  static constexpr auto Velocity = mp::rad / mp::s;
+  static constexpr auto Acceleration = mp::rad / mp::s / mp::s;
+  static constexpr auto kv_unit = mp::V / (mp::rad / mp::s);
+  static constexpr auto ka_unit = mp::V / Acceleration;
 
   /**
    * Creates a new ArmFeedforward with the specified gains.
diff --git a/wpimath/src/main/native/include/wpi/math/controller/ElevatorFeedforward.hpp b/wpimath/src/main/native/include/wpi/math/controller/ElevatorFeedforward.hpp
index 7f4e7994a..3d46fd1e3 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/ElevatorFeedforward.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/ElevatorFeedforward.hpp
@@ -18,15 +18,11 @@ namespace wpi::math {
  */
 class ElevatorFeedforward {
  public:
-  using Distance = mp::m;
-  using Velocity =
-      wpi::units::compound_unit<Distance, wpi::units::inverse<mp::s>>;
-  using Acceleration =
-      wpi::units::compound_unit<Velocity, wpi::units::inverse<mp::s>>;
-  using kv_unit =
-      wpi::units::compound_unit<mp::V, wpi::units::inverse<Velocity>>;
-  using ka_unit =
-      wpi::units::compound_unit<mp::V, wpi::units::inverse<Acceleration>>;
+  static constexpr auto Distance = mp::m;
+  static constexpr auto Velocity = Distance / mp::s;
+  static constexpr auto Acceleration = Velocity / mp::s;
+  static constexpr auto kv_unit = mp::V / Velocity;
+  static constexpr auto ka_unit = mp::V / Acceleration;
 
   /**
    * Creates a new ElevatorFeedforward with the specified gains.
@@ -132,7 +128,7 @@ class ElevatorFeedforward {
       mp::quantity<Velocity> currentVelocity,
       mp::quantity<Velocity> nextVelocity) const {
     // See wpimath/algorithms.md#Elevator_feedforward for derivation
-    if (kA < decltype(kA)(1e-9)) {
+    if (kA < 1e-9 * decltype(kA)::unit) {
       return kS * wpi::util::sgn(nextVelocity) + kG + kV * nextVelocity;
     } else {
       double A = -mp::value(kV) / mp::value(kA);
diff --git a/wpimath/src/main/native/include/wpi/math/controller/ProfiledPIDController.hpp b/wpimath/src/main/native/include/wpi/math/controller/ProfiledPIDController.hpp
index 42948aa07..446fa8336 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/ProfiledPIDController.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/ProfiledPIDController.hpp
@@ -27,17 +27,16 @@ int IncrementAndGetProfiledPIDControllerInstances();
  * Implements a PID control loop whose setpoint is constrained by a trapezoid
  * profile.
  */
-template <class Distance>
+template <auto Distance>
+  requires mp::Unit<decltype(Distance)>
 class ProfiledPIDController
     : public wpi::util::Sendable,
       public wpi::util::SendableHelper<ProfiledPIDController<Distance>> {
  public:
   using Distance_t = mp::quantity<Distance>;
-  using Velocity =
-      wpi::units::compound_unit<Distance, wpi::units::inverse<mp::s>>;
+  static constexpr auto Velocity = Distance / mp::s;
   using Velocity_t = mp::quantity<Velocity>;
-  using Acceleration =
-      wpi::units::compound_unit<Velocity, wpi::units::inverse<mp::s>>;
+  static constexpr auto Acceleration = Velocity / mp::s;
   using Acceleration_t = mp::quantity<Acceleration>;
   using State = typename TrapezoidProfile<Distance>::State;
   using Constraints = typename TrapezoidProfile<Distance>::Constraints;
@@ -201,7 +200,7 @@ class ProfiledPIDController
    *
    * @param goal The desired unprofiled setpoint.
    */
-  constexpr void SetGoal(Distance_t goal) { m_goal = {goal, Velocity_t{0}}; }
+  constexpr void SetGoal(Distance_t goal) { m_goal = {goal, 0.0 * Velocity}; }
 
   /**
    * Gets the goal for the ProfiledPIDController.
@@ -411,7 +410,7 @@ class ProfiledPIDController
    * velocity is assumed to be zero.
    */
   constexpr void Reset(Distance_t measuredPosition) {
-    Reset(measuredPosition, Velocity_t{0});
+    Reset(measuredPosition, 0.0 * Velocity);
   }
 
   void InitSendable(wpi::util::SendableBuilder& builder) override {
@@ -430,24 +429,24 @@ class ProfiledPIDController
         [this] { return mp::value(GetConstraints().maxVelocity); },
         [this](double value) {
           SetConstraints(
-              Constraints{Velocity_t{value}, GetConstraints().maxAcceleration});
+              Constraints{value * Velocity, GetConstraints().maxAcceleration});
         });
     builder.AddDoubleProperty(
         "maxAcceleration",
         [this] { return mp::value(GetConstraints().maxAcceleration); },
         [this](double value) {
           SetConstraints(
-              Constraints{GetConstraints().maxVelocity, Acceleration_t{value}});
+              Constraints{GetConstraints().maxVelocity, value * Acceleration});
         });
     builder.AddDoubleProperty(
         "goal", [this] { return mp::value(GetGoal().position); },
-        [this](double value) { SetGoal(Distance_t{value}); });
+        [this](double value) { SetGoal(value * Distance); });
   }
 
  private:
   PIDController m_controller;
-  Distance_t m_minimumInput{0};
-  Distance_t m_maximumInput{0};
+  Distance_t m_minimumInput = 0.0 * Distance;
+  Distance_t m_maximumInput = 0.0 * Distance;
 
   typename wpi::math::TrapezoidProfile<Distance>::Constraints m_constraints;
   TrapezoidProfile<Distance> m_profile;
diff --git a/wpimath/src/main/native/include/wpi/math/controller/SimpleMotorFeedforward.hpp b/wpimath/src/main/native/include/wpi/math/controller/SimpleMotorFeedforward.hpp
index 721de32c6..c3d4290fa 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/SimpleMotorFeedforward.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/SimpleMotorFeedforward.hpp
@@ -16,18 +16,15 @@ namespace wpi::math {
  * A helper class that computes feedforward voltages for a simple
  * permanent-magnet DC motor.
  */
-template <class Distance>
-  requires wpi::units::length_unit<Distance> || wpi::units::angle_unit<Distance>
+template <auto Distance>
+  requires mp::UnitOf<decltype(Distance), mp::length> ||
+           mp::UnitOf<decltype(Distance), mp::angle>
 class SimpleMotorFeedforward {
  public:
-  using Velocity =
-      wpi::units::compound_unit<Distance, wpi::units::inverse<mp::s>>;
-  using Acceleration =
-      wpi::units::compound_unit<Velocity, wpi::units::inverse<mp::s>>;
-  using kv_unit =
-      wpi::units::compound_unit<mp::V, wpi::units::inverse<Velocity>>;
-  using ka_unit =
-      wpi::units::compound_unit<mp::V, wpi::units::inverse<Acceleration>>;
+  static constexpr auto Velocity = Distance / mp::s;
+  static constexpr auto Acceleration = Velocity / mp::s;
+  static constexpr auto kv_unit = mp::V / Velocity;
+  static constexpr auto ka_unit = mp::V / Acceleration;
 
   /**
    * Creates a new SimpleMotorFeedforward with the specified gains.
@@ -92,7 +89,7 @@ class SimpleMotorFeedforward {
       mp::quantity<Velocity> currentVelocity,
       mp::quantity<Velocity> nextVelocity) const {
     // See wpimath/algorithms.md#Simple_motor_feedforward for derivation
-    if (kA < decltype(kA)(1e-9)) {
+    if (kA < 1e-9 * decltype(kA)::unit) {
       return kS * wpi::util::sgn(nextVelocity) + kV * nextVelocity;
     } else {
       double A = -mp::value(kV) / mp::value(kA);
diff --git a/wpimath/src/main/native/include/wpi/math/controller/proto/SimpleMotorFeedforwardProto.hpp b/wpimath/src/main/native/include/wpi/math/controller/proto/SimpleMotorFeedforwardProto.hpp
index 9d2596b77..2f6424fe7 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/proto/SimpleMotorFeedforwardProto.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/proto/SimpleMotorFeedforwardProto.hpp
@@ -14,9 +14,14 @@
 // wpi::math::SimpleMotorFeedforward<mp::m> or
 // wpi::math::SimpleMotorFeedforward<mp::rad>
 
-template <class Distance>
-  requires wpi::units::length_unit<Distance> || wpi::units::angle_unit<Distance>
+template <mp::Unit auto Distance>
+  requires mp::UnitOf<decltype(Distance), mp::length> ||
+           mp::UnitOf<decltype(Distance), mp::angle>
 struct wpi::util::Protobuf<wpi::math::SimpleMotorFeedforward<Distance>> {
+  // Because all instantiations of
+  // wpi::Protobuf<frc::SimpleMotorFeedforward<Distance>> use the same
+  // MessageStruct type, it doesn't matter if we use Distance or
+  // mp::get_base_unit(Distance) in InputStream and OutputStream.
   using MessageStruct = wpi_proto_ProtobufSimpleMotorFeedforward;
   using InputStream =
       wpi::util::ProtoInputStream<wpi::math::SimpleMotorFeedforward<Distance>>;
@@ -25,10 +30,8 @@ struct wpi::util::Protobuf<wpi::math::SimpleMotorFeedforward<Distance>> {
 
   static std::optional<wpi::math::SimpleMotorFeedforward<Distance>> Unpack(
       InputStream& stream) {
-    using BaseUnit =
-        wpi::units::unit<std::ratio<1>,
-                         wpi::units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = wpi::math::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        wpi::math::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     wpi_proto_ProtobufSimpleMotorFeedforward msg;
     if (!stream.Decode(msg)) {
       return {};
@@ -44,10 +47,8 @@ struct wpi::util::Protobuf<wpi::math::SimpleMotorFeedforward<Distance>> {
 
   static bool Pack(OutputStream& stream,
                    const wpi::math::SimpleMotorFeedforward<Distance>& value) {
-    using BaseUnit =
-        wpi::units::unit<std::ratio<1>,
-                         wpi::units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = wpi::math::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        wpi::math::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     wpi_proto_ProtobufSimpleMotorFeedforward msg{
         .ks = mp::value(value.GetKs()),
         .kv = mp::value(value.GetKv().in(BaseFeedforward::kv_unit)),
diff --git a/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp b/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp
index 0125dbb90..10e45c563 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp
@@ -12,8 +12,9 @@
 // wpi::math::SimpleMotorFeedforward<mp::m> or
 // wpi::math::SimpleMotorFeedforward<mp::rad>
 
-template <class Distance>
-  requires wpi::units::length_unit<Distance> || wpi::units::angle_unit<Distance>
+template <mp::Unit auto Distance>
+  requires mp::UnitOf<decltype(Distance), mp::length> ||
+           mp::UnitOf<decltype(Distance), mp::angle>
 struct wpi::util::Struct<wpi::math::SimpleMotorFeedforward<Distance>> {
   static constexpr std::string_view GetTypeName() {
     return "SimpleMotorFeedforward";
@@ -25,10 +26,8 @@ struct wpi::util::Struct<wpi::math::SimpleMotorFeedforward<Distance>> {
 
   static wpi::math::SimpleMotorFeedforward<Distance> Unpack(
       std::span<const uint8_t> data) {
-    using BaseUnit =
-        wpi::units::unit<std::ratio<1>,
-                         wpi::units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = wpi::math::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        wpi::math::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     constexpr size_t kKsOff = 0;
     constexpr size_t kKvOff = kKsOff + 8;
     constexpr size_t kKaOff = kKvOff + 8;
@@ -43,10 +42,8 @@ struct wpi::util::Struct<wpi::math::SimpleMotorFeedforward<Distance>> {
 
   static void Pack(std::span<uint8_t> data,
                    const wpi::math::SimpleMotorFeedforward<Distance>& value) {
-    using BaseUnit =
-        wpi::units::unit<std::ratio<1>,
-                         wpi::units::traits::base_unit_of<Distance>>;
-    using BaseFeedforward = wpi::math::SimpleMotorFeedforward<BaseUnit>;
+    using BaseFeedforward =
+        wpi::math::SimpleMotorFeedforward<mp::get_base_unit(Distance)>;
     constexpr size_t kKsOff = 0;
     constexpr size_t kKvOff = kKsOff + 8;
     constexpr size_t kKaOff = kKvOff + 8;
diff --git a/wpimath/src/main/native/include/wpi/math/filter/LinearFilter.hpp b/wpimath/src/main/native/include/wpi/math/filter/LinearFilter.hpp
index 5c13e88a8..faf1a21f3 100644
--- a/wpimath/src/main/native/include/wpi/math/filter/LinearFilter.hpp
+++ b/wpimath/src/main/native/include/wpi/math/filter/LinearFilter.hpp
@@ -88,10 +88,10 @@ class LinearFilter {
         m_inputGains(ffGains.begin(), ffGains.end()),
         m_outputGains(fbGains.begin(), fbGains.end()) {
     for (size_t i = 0; i < ffGains.size(); ++i) {
-      m_inputs.emplace_front(0.0);
+      m_inputs.emplace_front(MakeValue(0.0));
     }
     for (size_t i = 0; i < fbGains.size(); ++i) {
-      m_outputs.emplace_front(0.0);
+      m_outputs.emplace_front(MakeValue(0.0));
     }
 
     if (!std::is_constant_evaluated()) {
@@ -353,7 +353,7 @@ class LinearFilter {
    * @return The filtered value at this step
    */
   constexpr T Calculate(T input) {
-    T retVal{0.0};
+    T retVal = MakeValue(0.0);
 
     // Rotate the inputs
     if (m_inputGains.size() > 0) {
@@ -389,7 +389,7 @@ class LinearFilter {
   wpi::util::circular_buffer<T> m_outputs;
   std::vector<double> m_inputGains;
   std::vector<double> m_outputGains;
-  T m_lastOutput{0.0};
+  T m_lastOutput = MakeValue(0.0);
 
   // Usage reporting instances
   inline static int instances = 0;
@@ -406,6 +406,14 @@ class LinearFilter {
       return n * Factorial(n - 1);
     }
   }
+
+  static constexpr T MakeValue(double value) {
+    if constexpr (mp::Quantity<T>) {
+      return value * T::unit;
+    } else {
+      return T{value};
+    }
+  }
 };
 
 }  // namespace wpi::math
diff --git a/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp b/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp
index b16771ff8..c953d5dab 100644
--- a/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp
+++ b/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp
@@ -20,11 +20,12 @@ namespace wpi::math {
  *
  * @see TrapezoidProfile
  */
-template <class Unit>
+template <auto Unit>
+  requires mp::Unit<decltype(Unit)>
 class SlewRateLimiter {
  public:
   using Unit_t = mp::quantity<Unit>;
-  using Rate = wpi::units::compound_unit<Unit, wpi::units::inverse<mp::s>>;
+  static constexpr auto Rate = Unit / mp::s;
   using Rate_t = mp::quantity<Rate>;
 
   /**
@@ -40,7 +41,7 @@ class SlewRateLimiter {
    * @param initialValue The initial value of the input.
    */
   SlewRateLimiter(Rate_t positiveRateLimit, Rate_t negativeRateLimit,
-                  Unit_t initialValue = Unit_t{0})
+                  Unit_t initialValue = 0.0 * Unit)
       : m_positiveRateLimit{positiveRateLimit},
         m_negativeRateLimit{negativeRateLimit},
         m_prevVal{initialValue},
diff --git a/wpimath/src/main/native/include/wpi/math/system/plant/DCMotor.hpp b/wpimath/src/main/native/include/wpi/math/system/plant/DCMotor.hpp
index aec4f4820..917075243 100644
--- a/wpimath/src/main/native/include/wpi/math/system/plant/DCMotor.hpp
+++ b/wpimath/src/main/native/include/wpi/math/system/plant/DCMotor.hpp
@@ -14,11 +14,8 @@ namespace wpi::math {
  */
 class WPILIB_DLLEXPORT DCMotor {
  public:
-  using radians_per_second_per_volt_t = wpi::units::unit_t<
-      wpi::units::compound_unit<mp::rad / mp::s, wpi::units::inverse<mp::V>>>;
-  using newton_meters_per_ampere_t =
-      wpi::units::unit_t<wpi::units::compound_unit<wpi::units::newton_meters,
-                                                   wpi::units::inverse<mp::A>>>;
+  using radians_per_second_per_volt_t = mp::quantity<mp::rad / mp::s / mp::V>;
+  using newton_meters_per_ampere_t = mp::quantity<mp::N * mp::m / mp::A>;
 
   /// Voltage at which the motor constants were measured.
   mp::quantity<mp::V> nominalVoltage;
diff --git a/wpimath/src/main/native/include/wpi/math/system/plant/LinearSystemId.hpp b/wpimath/src/main/native/include/wpi/math/system/plant/LinearSystemId.hpp
index bd3c8088a..da91ef0d7 100644
--- a/wpimath/src/main/native/include/wpi/math/system/plant/LinearSystemId.hpp
+++ b/wpimath/src/main/native/include/wpi/math/system/plant/LinearSystemId.hpp
@@ -20,14 +20,11 @@ namespace wpi::math {
  */
 class WPILIB_DLLEXPORT LinearSystemId {
  public:
-  template <typename Distance>
-  using Velocity_t = wpi::units::unit_t<
-      wpi::units::compound_unit<Distance, wpi::units::inverse<mp::s>>>;
+  template <auto Distance>
+  using Velocity_t = mp::quantity<Distance / mp::s>;
 
-  template <typename Distance>
-  using Acceleration_t = wpi::units::unit_t<wpi::units::compound_unit<
-      wpi::units::compound_unit<Distance, wpi::units::inverse<mp::s>>,
-      wpi::units::inverse<mp::s>>>;
+  template <auto Distance>
+  using Acceleration_t = mp::quantity<Distance / mp::s2>;
 
   /**
    * Create a state-space model of the elevator system. The states of the system
@@ -115,15 +112,15 @@ class WPILIB_DLLEXPORT LinearSystemId {
    * @see <a
    * href="https://github.com/wpilibsuite/allwpilib/tree/main/sysid">https://github.com/wpilibsuite/allwpilib/tree/main/sysid</a>
    */
-  template <typename Distance>
-    requires std::same_as<mp::m, Distance> || std::same_as<mp::rad, Distance>
+  template <auto Distance>
+    requires(mp::m == Distance || mp::rad == Distance)
   static constexpr LinearSystem<1, 1, 1> IdentifyVelocitySystem(
-      mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
-      mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA) {
-    if (kV < decltype(kV){0}) {
+      mp::quantity<mp::V / Velocity_t<Distance>::unit> kV,
+      mp::quantity<mp::V / Acceleration_t<Distance>::unit> kA) {
+    if (kV < 0.0 * decltype(kV)::unit) {
       throw std::domain_error("Kv must be greater than or equal to zero.");
     }
-    if (kA <= decltype(kA){0}) {
+    if (kA <= 0.0 * decltype(kA)::unit) {
       throw std::domain_error("Ka must be greater than zero.");
     }
 
@@ -157,15 +154,15 @@ class WPILIB_DLLEXPORT LinearSystemId {
    * @see <a
    * href="https://github.com/wpilibsuite/allwpilib/tree/main/sysid">https://github.com/wpilibsuite/allwpilib/tree/main/sysid</a>
    */
-  template <typename Distance>
-    requires std::same_as<mp::m, Distance> || std::same_as<mp::rad, Distance>
+  template <auto Distance>
+    requires(mp::m == Distance || mp::rad == Distance)
   static constexpr LinearSystem<2, 1, 2> IdentifyPositionSystem(
-      mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
-      mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA) {
-    if (kV < decltype(kV){0}) {
+      mp::quantity<mp::V / Velocity_t<Distance>::unit> kV,
+      mp::quantity<mp::V / Acceleration_t<Distance>::unit> kA) {
+    if (kV < 0.0 * decltype(kV)::unit) {
       throw std::domain_error("Kv must be greater than or equal to zero.");
     }
-    if (kA <= decltype(kA){0}) {
+    if (kA <= 0.0 * decltype(kA)::unit) {
       throw std::domain_error("Ka must be greater than zero.");
     }
 
@@ -204,16 +201,16 @@ class WPILIB_DLLEXPORT LinearSystemId {
       mp::quantity<mp::V / (mp::m / mp::s2)> kALinear,
       mp::quantity<mp::V / (mp::m / mp::s)> kVAngular,
       mp::quantity<mp::V / (mp::m / mp::s2)> kAAngular) {
-    if (kVLinear <= decltype(kVLinear){0}) {
+    if (kVLinear <= 0.0 * decltype(kVLinear)::unit) {
       throw std::domain_error("Kv,linear must be greater than zero.");
     }
-    if (kALinear <= decltype(kALinear){0}) {
+    if (kALinear <= 0.0 * decltype(kALinear)::unit) {
       throw std::domain_error("Ka,linear must be greater than zero.");
     }
-    if (kVAngular <= decltype(kVAngular){0}) {
+    if (kVAngular <= 0.0 * decltype(kVAngular)::unit) {
       throw std::domain_error("Kv,angular must be greater than zero.");
     }
-    if (kAAngular <= decltype(kAAngular){0}) {
+    if (kAAngular <= 0.0 * decltype(kAAngular)::unit) {
       throw std::domain_error("Ka,angular must be greater than zero.");
     }
 
@@ -268,16 +265,16 @@ class WPILIB_DLLEXPORT LinearSystemId {
       mp::quantity<mp::V / (mp::rad / mp::s)> kVAngular,
       mp::quantity<mp::V / (mp::rad / mp::s2)> kAAngular,
       mp::quantity<mp::m> trackwidth) {
-    if (kVLinear <= decltype(kVLinear){0}) {
+    if (kVLinear <= 0.0 * decltype(kVLinear)::unit) {
       throw std::domain_error("Kv,linear must be greater than zero.");
     }
-    if (kALinear <= decltype(kALinear){0}) {
+    if (kALinear <= 0.0 * decltype(kALinear)::unit) {
       throw std::domain_error("Ka,linear must be greater than zero.");
     }
-    if (kVAngular <= decltype(kVAngular){0}) {
+    if (kVAngular <= 0.0 * decltype(kVAngular)::unit) {
       throw std::domain_error("Kv,angular must be greater than zero.");
     }
-    if (kAAngular <= decltype(kAAngular){0}) {
+    if (kAAngular <= 0.0 * decltype(kAAngular)::unit) {
       throw std::domain_error("Ka,angular must be greater than zero.");
     }
     if (trackwidth <= 0.0 * mp::m) {
@@ -380,15 +377,15 @@ class WPILIB_DLLEXPORT LinearSystemId {
    *
    * @throws std::domain_error if kV < 0 or kA <= 0.
    */
-  template <typename Distance>
-    requires std::same_as<mp::m, Distance> || std::same_as<mp::rad, Distance>
+  template <auto Distance>
+    requires(mp::m == Distance || mp::rad == Distance)
   static constexpr LinearSystem<2, 1, 2> DCMotorSystem(
-      mp::quantity<mp::V / Velocity_t<Distance>(1)> kV,
-      mp::quantity<mp::V / Acceleration_t<Distance>(1)> kA) {
-    if (kV < decltype(kV){0}) {
+      mp::quantity<mp::V / Velocity_t<Distance>::unit> kV,
+      mp::quantity<mp::V / Acceleration_t<Distance>::unit> kA) {
+    if (kV < 0.0 * decltype(kV)::unit) {
       throw std::domain_error("Kv must be greater than or equal to zero.");
     }
-    if (kA <= decltype(kA){0}) {
+    if (kA <= 0.0 * decltype(kA)::unit) {
       throw std::domain_error("Ka must be greater than zero.");
     }
 
diff --git a/wpimath/src/main/native/include/wpi/math/trajectory/ExponentialProfile.hpp b/wpimath/src/main/native/include/wpi/math/trajectory/ExponentialProfile.hpp
index 80c61104f..892a55fcc 100644
--- a/wpimath/src/main/native/include/wpi/math/trajectory/ExponentialProfile.hpp
+++ b/wpimath/src/main/native/include/wpi/math/trajectory/ExponentialProfile.hpp
@@ -36,23 +36,20 @@ namespace wpi::math {
  * `Calculate()` and to determine when the profile has completed via
  * `IsFinished()`.
  */
-template <class Distance, class Input>
+template <auto Distance, auto Input>
+  requires mp::Unit<decltype(Distance)> && mp::Unit<decltype(Input)>
 class ExponentialProfile {
  public:
   using Distance_t = mp::quantity<Distance>;
-  using Velocity =
-      wpi::units::compound_unit<Distance, wpi::units::inverse<mp::s>>;
+  static constexpr auto Velocity = Distance / mp::s;
   using Velocity_t = mp::quantity<Velocity>;
-  using Acceleration =
-      wpi::units::compound_unit<Velocity, wpi::units::inverse<mp::s>>;
+  static constexpr auto Acceleration = Velocity / mp::s;
   using Input_t = mp::quantity<Input>;
-  using A_t = mp::quantity<wpi::units::inverse<mp::s>>;
-  using B_t = wpi::units::unit_t<
-      wpi::units::compound_unit<Acceleration, wpi::units::inverse<Input>>>;
-  using KV = wpi::units::compound_unit<Input, wpi::units::inverse<Velocity>>;
+  using A_t = mp::quantity<mp::one / mp::s>;
+  using B_t = mp::quantity<Acceleration / Input>;
+  static constexpr auto KV = Input / Velocity;
   using kV_t = mp::quantity<KV>;
-  using KA =
-      wpi::units::compound_unit<Input, wpi::units::inverse<Acceleration>>;
+  static constexpr auto KA = Input / Acceleration;
   using kA_t = mp::quantity<KA>;
 
   /**
@@ -113,20 +110,20 @@ class ExponentialProfile {
     Input_t maxInput{0};
 
     /// The State-Space 1x1 system matrix.
-    A_t A{0};
+    A_t A = 0.0 * A_t::unit;
 
     /// The State-Space 1x1 input matrix.
-    B_t B{0};
+    B_t B = 0.0 * B_t::unit;
   };
 
   /** Profile state. */
   class State {
    public:
     /// The position at this state.
-    Distance_t position{0};
+    Distance_t position = 0.0 * Distance;
 
     /// The velocity at this state.
-    Velocity_t velocity{0};
+    Velocity_t velocity = 0.0 * Velocity;
 
     constexpr bool operator==(const State&) const = default;
   };
@@ -280,7 +277,7 @@ class ExponentialProfile {
     // For cases 1 and 3, we want to subtract epsilon from the inflection point
     // velocity For cases 2 and 4, we want to add epsilon to the inflection
     // point velocity. For case 5, we have reached inflection point velocity.
-    auto epsilon = Velocity_t(1e-9);
+    auto epsilon = 1e-9 * Velocity;
     if (mp::abs(u_dir * m_constraints.MaxVelocity() -
                 inflectionPoint.velocity) < epsilon) {
       auto solvableV = inflectionPoint.velocity;
@@ -431,7 +428,7 @@ class ExponentialProfile {
     if (-1e-9 < mp::value(c) && mp::value(c) < 0) {
       // numeric instability - the heuristic gets it right but c is around
       // -1e-13
-      return Velocity_t(0);
+      return 0.0 * Velocity;
     }
 
     return u_dir * mp::sqrt(-c / a);
@@ -465,8 +462,8 @@ class ExponentialProfile {
       return xf < x_forward;
     }
 
-    auto a = v0 >= Velocity_t(0);
-    auto b = vf >= Velocity_t(0);
+    auto a = v0 >= 0.0 * Velocity;
+    auto b = vf >= 0.0 * Velocity;
     auto c = xf >= x_forward;
     auto d = xf >= x_reverse;
 
diff --git a/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp b/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp
index 81e727192..d8aba361e 100644
--- a/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp
+++ b/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp
@@ -42,15 +42,14 @@ namespace wpi::math {
  * `Calculate()` and to determine when the profile has completed via
  * `IsFinished()`.
  */
-template <class Distance>
+template <auto Distance>
+  requires mp::Unit<decltype(Distance)>
 class TrapezoidProfile {
  public:
   using Distance_t = mp::quantity<Distance>;
-  using Velocity =
-      wpi::units::compound_unit<Distance, wpi::units::inverse<mp::s>>;
+  static constexpr auto Velocity = Distance / mp::s;
   using Velocity_t = mp::quantity<Velocity>;
-  using Acceleration =
-      wpi::units::compound_unit<Velocity, wpi::units::inverse<mp::s>>;
+  static constexpr auto Acceleration = Velocity / mp::s;
   using Acceleration_t = mp::quantity<Acceleration>;
 
   /**
@@ -86,7 +85,7 @@ class TrapezoidProfile {
         wpi::math::MathSharedStore::ReportUsage("TrapezoidProfile", "");
       }
 
-      if (maxVelocity < Velocity_t{0} || maxAcceleration < Acceleration_t{0}) {
+      if (maxVelocity < 0.0 * Velocity || maxAcceleration < 0.0 * Acceleration) {
         throw std::domain_error("Constraints must be non-negative");
       }
     }
@@ -98,10 +97,10 @@ class TrapezoidProfile {
   class State {
    public:
     /// The position at this state.
-    Distance_t position{0};
+    Distance_t position = 0.0 * Distance;
 
     /// The velocity at this state.
-    Velocity_t velocity{0};
+    Velocity_t velocity = 0.0 * Velocity;
 
     constexpr bool operator==(const State&) const = default;
   };
@@ -164,10 +163,10 @@ class TrapezoidProfile {
         accelerationTime * accelerationTime * m_constraints.maxAcceleration;
 
     // Handle the case where the profile never reaches full speed
-    if (fullSpeedDist < Distance_t{0}) {
+    if (fullSpeedDist < 0.0 * Distance) {
       accelerationTime =
           mp::sqrt(fullTrapezoidDist / m_constraints.maxAcceleration);
-      fullSpeedDist = Distance_t{0};
+      fullSpeedDist = 0.0 * Distance;
     }
 
     m_endAccel = accelerationTime - cutoffBegin;
@@ -228,7 +227,7 @@ class TrapezoidProfile {
 
     Distance_t distToTarget = mp::abs(target - position);
 
-    if (distToTarget < Distance_t{1e-6}) {
+    if (distToTarget < 1e-6 * Distance) {
       return 0.0 * mp::s;
     }
 
@@ -248,11 +247,11 @@ class TrapezoidProfile {
 
     if (accelDist > distToTarget) {
       accelDist = distToTarget;
-      fullSpeedDist = Distance_t{0};
-      decelDist = Distance_t{0};
+      fullSpeedDist = 0.0 * Distance;
+      decelDist = 0.0 * Distance;
     } else if (accelDist + fullSpeedDist > distToTarget) {
       fullSpeedDist = distToTarget - accelDist;
-      decelDist = Distance_t{0};
+      decelDist = 0.0 * Distance;
     } else {
       decelDist = distToTarget - fullSpeedDist - accelDist;
     }
diff --git a/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp b/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp
index f89f2a0d9..ef86a7a3c 100644
--- a/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp
+++ b/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp
@@ -17,6 +17,20 @@
 
 namespace wpi::math {
 
+namespace detail {
+
+template <typename T>
+  requires std::is_arithmetic_v<T> || mp::Quantity<T>
+constexpr T MakeValue(double value) {
+  if constexpr (std::is_arithmetic_v<T>) {
+    return T{value};
+  } else {
+    return value * T::unit;
+  }
+}
+
+}  // namespace detail
+
 /**
  * Returns 0.0 if the given value is within the specified range around zero. The
  * remaining range between the deadband and the maximum magnitude is scaled from
@@ -30,7 +44,8 @@ namespace wpi::math {
  */
 template <typename T>
   requires std::is_arithmetic_v<T> || mp::Quantity<T>
-constexpr T ApplyDeadband(T value, T deadband, T maxMagnitude = T{1.0}) {
+constexpr T ApplyDeadband(T value, T deadband,
+                          T maxMagnitude = detail::MakeValue<T>(1.0)) {
   T magnitude;
   if constexpr (std::is_arithmetic_v<T>) {
     magnitude = gcem::abs(value);
@@ -39,10 +54,10 @@ constexpr T ApplyDeadband(T value, T deadband, T maxMagnitude = T{1.0}) {
   }
 
   if (magnitude < deadband) {
-    return T{0.0};
+    return detail::MakeValue<T>(0.0);
   }
 
-  if (value > T{0.0}) {
+  if (value > detail::MakeValue<T>(0.0)) {
     // Map deadband to 0 and map max to max with a linear relationship.
     //
     //   y - y = m(x - x)
@@ -103,7 +118,7 @@ constexpr T ApplyDeadband(T value, T deadband, T maxMagnitude = T{1.0}) {
 template <typename T, int N>
   requires std::is_arithmetic_v<T> || mp::Quantity<T>
 Eigen::Vector<T, N> ApplyDeadband(const Eigen::Vector<T, N>& value, T deadband,
-                                  T maxMagnitude = T{1.0}) {
+                                  T maxMagnitude = detail::MakeValue<T>(1.0)) {
   if constexpr (std::is_arithmetic_v<T>) {
     if (value.norm() < T{1e-9}) {
       return Eigen::Vector<T, N>::Zero();
@@ -111,10 +126,18 @@ Eigen::Vector<T, N> ApplyDeadband(const Eigen::Vector<T, N>& value, T deadband,
     return value.normalized() *
            ApplyDeadband(value.norm(), deadband, maxMagnitude);
   } else {
-    const Eigen::Vector<double, N> asDouble = value.template cast<double>();
+    // Use explicit rows() to handle dynamic size vectors
+    Eigen::Vector<double, N> asDouble(value.rows());
+    for (int i = 0; i < value.rows(); ++i) {
+      asDouble(i) = mp::value(value(i));
+    }
     const Eigen::Vector<double, N> processed =
         ApplyDeadband(asDouble, mp::value(deadband), mp::value(maxMagnitude));
-    return processed.template cast<T>();
+    Eigen::Vector<T, N> returnValue(processed.rows());
+    for (int i = 0; i < processed.rows(); ++i) {
+      returnValue(i) = processed(i) * T::unit;
+    }
+    return returnValue;
   }
 }
 
@@ -139,7 +162,7 @@ Eigen::Vector<T, N> ApplyDeadband(const Eigen::Vector<T, N>& value, T deadband,
 template <typename T>
   requires std::is_arithmetic_v<T> || mp::Quantity<T>
 constexpr T CopyDirectionPow(T value, double exponent,
-                             T maxMagnitude = T{1.0}) {
+                             T maxMagnitude = detail::MakeValue<T>(1.0)) {
   if constexpr (std::is_arithmetic_v<T>) {
     return gcem::copysign(
         gcem::pow(gcem::abs(value) / maxMagnitude, exponent) * maxMagnitude,
@@ -172,8 +195,9 @@ constexpr T CopyDirectionPow(T value, double exponent,
  */
 template <typename T, int N>
   requires std::is_arithmetic_v<T> || mp::Quantity<T>
-Eigen::Vector<T, N> CopyDirectionPow(const Eigen::Vector<T, N>& value,
-                                     double exponent, T maxMagnitude = T{1.0}) {
+Eigen::Vector<T, N> CopyDirectionPow(
+    const Eigen::Vector<T, N>& value, double exponent,
+    T maxMagnitude = detail::MakeValue<T>(1.0)) {
   if constexpr (std::is_arithmetic_v<T>) {
     if (value.norm() < T{1e-9}) {
       return Eigen::Vector<T, N>::Zero();
@@ -181,10 +205,18 @@ Eigen::Vector<T, N> CopyDirectionPow(const Eigen::Vector<T, N>& value,
     return value.normalized() *
            CopyDirectionPow(value.norm(), exponent, maxMagnitude);
   } else {
-    const Eigen::Vector<double, N> asDouble = value.template cast<double>();
+    // Use explicit rows() to handle dynamic size vectors
+    Eigen::Vector<double, N> asDouble(value.rows());
+    for (int i = 0; i < value.rows(); ++i) {
+      asDouble(i) = mp::value(value(i));
+    }
     const Eigen::Vector<double, N> processed =
         CopyDirectionPow(asDouble, exponent, mp::value(maxMagnitude));
-    return processed.template cast<T>();
+    Eigen::Vector<T, N> returnValue(processed.rows());
+    for (int i = 0; i < processed.rows(); ++i) {
+      returnValue(i) = processed(i) * T::unit;
+    }
+    return returnValue;
   }
 }
 
diff --git a/wpimath/src/test/native/cpp/FormatterTest.cpp b/wpimath/src/test/native/cpp/FormatterTest.cpp
index fdeb651b6..c7aa4ea51 100644
--- a/wpimath/src/test/native/cpp/FormatterTest.cpp
+++ b/wpimath/src/test/native/cpp/FormatterTest.cpp
@@ -44,5 +44,5 @@ TEST(FormatterTest, Eigen) {
 }
 
 TEST(FormatterTest, Units) {
-  EXPECT_EQ("4 mps", fmt::format("{}", 4.0 * mp::m / mp::s));
+  EXPECT_EQ("4 m/s", fmt::format("{}", 4.0 * mp::m / mp::s));
 }
diff --git a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
index 7ebf2e3ac..023321174 100644
--- a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
@@ -17,10 +17,10 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
   constexpr auto maxA = 2.0 * mp::m / mp::s2;
   constexpr auto maxAlpha = 2.0 * mp::rad / mp::s2;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   DifferentialDriveAccelerationLimiter accelLimiter{plant, trackwidth, maxA,
                                                     maxAlpha};
@@ -112,11 +112,11 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
   constexpr auto trackwidth = 0.9 * mp::m;
   constexpr mp::quantity<mp::s> dt = 5.0 * mp::ms;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
 
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   // Limits are so high, they don't get hit, so states of constrained and
   // unconstrained systems should match
@@ -180,10 +180,10 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
   constexpr auto maxA = 2.0 * mp::m / mp::s2;
   constexpr auto maxAlpha = 2.0 * mp::rad / mp::s2;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   DifferentialDriveAccelerationLimiter accelLimiter{plant, trackwidth, minA,
                                                     maxA, maxAlpha};
@@ -242,10 +242,10 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
 }
 
 TEST(DifferentialDriveAccelerationLimiterTest, MinAccelGreaterThanMaxAccel) {
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
   EXPECT_NO_THROW({
     DifferentialDriveAccelerationLimiter accelLimiter(
         plant, 1.0 * mp::m, 1.0 * mp::m / mp::s2, 1.0 * mp::rad / mp::s2);
diff --git a/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp b/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
index 0b9f1b754..c3946e14e 100644
--- a/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
@@ -13,10 +13,10 @@ namespace wpi::math {
 TEST(ImplicitModelFollowerTest, SameModel) {
   constexpr mp::quantity<mp::s> dt = 5.0 * mp::ms;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   ImplicitModelFollower<2, 2> imf{plant, plant};
 
@@ -57,15 +57,15 @@ TEST(ImplicitModelFollowerTest, SameModel) {
 TEST(ImplicitModelFollowerTest, SlowerRefModel) {
   constexpr mp::quantity<mp::s> dt = 5.0 * mp::ms;
 
-  using Kv_t = mp::quantity<mp::V / (mp::m / mp::s)>;
-  using Ka_t = mp::quantity<mp::V / (mp::m / mp::s2)>;
+  constexpr auto Kv_unit = mp::V / (mp::m / mp::s);
+  constexpr auto Ka_unit = mp::V / (mp::m / mp::s2);
 
-  auto plant = LinearSystemId::IdentifyDrivetrainSystem(Kv_t{1.0}, Ka_t{1.0},
-                                                        Kv_t{1.0}, Ka_t{1.0});
+  auto plant = LinearSystemId::IdentifyDrivetrainSystem(
+      1.0 * Kv_unit, 1.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   // Linear acceleration is slower, but angular acceleration is the same
   auto plantRef = LinearSystemId::IdentifyDrivetrainSystem(
-      Kv_t{1.0}, Ka_t{2.0}, Kv_t{1.0}, Ka_t{1.0});
+      1.0 * Kv_unit, 2.0 * Ka_unit, 1.0 * Kv_unit, 1.0 * Ka_unit);
 
   ImplicitModelFollower<2, 2> imf{plant, plantRef};
 
diff --git a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
index e97dfb7e8..cc4d3361b 100644
--- a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
@@ -12,7 +12,7 @@
 
 using namespace wpi::math;
 
-template <typename T>
+template <mp::Unit auto T>
 struct SimpleMotorFeedforwardProtoTestData {
   using Type = SimpleMotorFeedforward<T>;
 
diff --git a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
index 218dfe61d..2e2bf1221 100644
--- a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
@@ -12,7 +12,7 @@
 
 using namespace wpi::math;
 
-template <typename T>
+template <mp::Unit auto T>
 struct SimpleMotorFeedforwardStructTestData {
   using Type = SimpleMotorFeedforward<T>;
 
diff --git a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
index c00003691..42def2050 100644
--- a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
@@ -98,7 +98,7 @@ TEST(S3UKFTest, DriveInit) {
 }
 
 TEST(S3UKFTest, DriveConvergence) {
-  constexpr auto dt = 5.0 * mp::ms;
+  constexpr mp::quantity<mp::s> dt = 5.0 * mp::ms;
   constexpr auto rb = 0.8382 * mp::m / 2.0;  // Robot radius
 
   wpi::math::S3UKF<5, 2, 3> observer{DriveDynamics,
diff --git a/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp
index b4aa56ded..92a15b8ee 100644
--- a/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp
@@ -9,6 +9,8 @@
 
 #include <gtest/gtest.h>
 
+#include "wpi/units-usc.hpp"
+
 using namespace wpi::math;
 
 TEST(Pose2dTest, RotateBy) {
diff --git a/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp b/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp
index 8a1f93113..9937a8644 100644
--- a/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp
@@ -8,6 +8,7 @@
 
 #include <gtest/gtest.h>
 
+#include "wpi/units-usc.hpp"
 #include "wpi/util/array.hpp"
 
 using namespace wpi::math;
diff --git a/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
index e12b46d43..c7361097e 100644
--- a/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
@@ -90,6 +90,10 @@ TEST(Rotation2dTest, ToMatrix) {
   EXPECT_EQ(before, after);
 }
 
+constexpr bool IsNear(mp::quantity<mp::rad> lhs, mp::quantity<mp::rad> rhs) {
+  return lhs >= rhs - 1e-12 * mp::rad && lhs <= rhs + 1e-12 * mp::rad;
+}
+
 TEST(Rotation2dTest, Constexpr) {
   constexpr Rotation2d defaultCtor;
   constexpr Rotation2d radianCtor{5.0 * mp::rad};
@@ -103,8 +107,8 @@ TEST(Rotation2dTest, Constexpr) {
 
   static_assert(defaultCtor.Radians() == 0.0 * mp::rad);
   static_assert(degreeCtor.Degrees() == -90.0 * mp::deg);
-  static_assert(negated.Radians() == -5.0 * mp::rad + 1.0 * mp::rev);
-  static_assert(multiplied.Radians() == 10.0 * mp::rad - 2.0 * mp::rev);
+  static_assert(IsNear(negated.Radians(), -5.0 * mp::rad + 1.0 * mp::rev));
+  static_assert(IsNear(multiplied.Radians(), 10.0 * mp::rad - 2.0 * mp::rev));
   static_assert(subtracted == rotation45);
   static_assert(radianCtor != degreeCtor);
 }
