diff --git a/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp b/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp
index 9488ab19ff..db2553a25c 100644
--- a/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp
+++ b/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp
@@ -12,6 +12,9 @@
 
 #include "frc/EigenCore.h"
 #include "frc/system/NumericalIntegration.h"
+#include "units/base.h"
+#include "units/math.h"
+#include "units/voltage.h"
 
 using namespace frc;
 
@@ -23,7 +26,7 @@ units::volt_t ArmFeedforward::Calculate(
   // Small kₐ values make the solver ill-conditioned
   if (kA < units::unit_t<ka_unit>{1e-1}) {
     auto acceleration = (nextVelocity - currentVelocity) / m_dt;
-    return kS * wpi::sgn(currentVelocity.value()) + kV * currentVelocity +
+    return kS * wpi::sgn(currentVelocity) + kV * currentVelocity +
            kA * acceleration + kG * units::math::cos(currentAngle);
   }
 
@@ -43,7 +46,7 @@ units::volt_t ArmFeedforward::Calculate(
 
   // Initial guess
   auto acceleration = (nextVelocity - currentVelocity) / m_dt;
-  u_k.set_value((kS * wpi::sgn(currentVelocity.value()) + kV * currentVelocity +
+  u_k.set_value((kS * wpi::sgn(currentVelocity) + kV * currentVelocity +
                  kA * acceleration + kG * units::math::cos(currentAngle))
                     .value());
 
@@ -56,13 +59,13 @@ units::volt_t ArmFeedforward::Calculate(
   // Refine solution via Newton's method
   {
     auto xAD = u_k;
-    double x = xAD.value();
+    double x = xAD. value();
 
     slp::Gradient gradientF{cost, xAD};
-    Eigen::SparseVector<double> g = gradientF.value();
+    Eigen::SparseVector<double> g = gradientF. value();
 
     slp::Hessian hessianF{cost, xAD};
-    Eigen::SparseMatrix<double> H = hessianF.value();
+    Eigen::SparseMatrix<double> H = hessianF. value();
 
     double error_k = std::numeric_limits<double>::infinity();
     double error_k1 = std::abs(g.coeff(0));
@@ -81,14 +84,14 @@ units::volt_t ArmFeedforward::Calculate(
 
       // Shrink step until cost goes down
       {
-        double oldCost = cost.value();
+        double oldCost = cost. value();
 
         double α = 1.0;
         double trial_x = x + α * p_x;
 
         xAD.set_value(trial_x);
 
-        while (cost.value() > oldCost) {
+        while (cost. value() > oldCost) {
           α *= 0.5;
           trial_x = x + α * p_x;
 
@@ -100,12 +103,12 @@ units::volt_t ArmFeedforward::Calculate(
 
       xAD.set_value(x);
 
-      g = gradientF.value();
-      H = hessianF.value();
+      g = gradientF. value();
+      H = hessianF. value();
 
       error_k1 = std::abs(g.coeff(0));
     }
   }
 
-  return units::volt_t{u_k.value()};
+  return units::volt_t{u_k. value()};
 }
diff --git a/wpimath/src/main/native/cpp/controller/DifferentialDriveAccelerationLimiter.cpp b/wpimath/src/main/native/cpp/controller/DifferentialDriveAccelerationLimiter.cpp
index bcf625c319..c7ab22ec9e 100644
--- a/wpimath/src/main/native/cpp/controller/DifferentialDriveAccelerationLimiter.cpp
+++ b/wpimath/src/main/native/cpp/controller/DifferentialDriveAccelerationLimiter.cpp
@@ -6,6 +6,8 @@
 
 #include <Eigen/QR>
 
+#include "units/voltage.h"
+
 using namespace frc;
 
 DifferentialDriveWheelVoltages DifferentialDriveAccelerationLimiter::Calculate(
diff --git a/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp b/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp
index d058fdf17c..6e03c97eea 100644
--- a/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp
+++ b/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp
@@ -7,6 +7,9 @@
 #include <Eigen/Core>
 
 #include "frc/controller/LinearPlantInversionFeedforward.h"
+#include "units/time.h"
+#include "units/velocity.h"
+#include "units/voltage.h"
 
 using namespace frc;
 
@@ -17,8 +20,8 @@ DifferentialDriveWheelVoltages DifferentialDriveFeedforward::Calculate(
     units::meters_per_second_t nextRightVelocity, units::second_t dt) {
   frc::LinearPlantInversionFeedforward<2, 2> feedforward{m_plant, dt};
 
-  Eigen::Vector2d r{currentLeftVelocity, currentRightVelocity};
-  Eigen::Vector2d nextR{nextLeftVelocity, nextRightVelocity};
+  Eigen::Vector2d r{currentLeftVelocity.value(), currentRightVelocity.value()};
+  Eigen::Vector2d nextR{nextLeftVelocity.value(), nextRightVelocity.value()};
   auto u = feedforward.Calculate(r, nextR);
   return {units::volt_t{u(0)}, units::volt_t{u(1)}};
 }
diff --git a/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp b/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp
index 0ddd2f6e84..e8708e92b4 100644
--- a/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp
+++ b/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp
@@ -9,6 +9,8 @@
 #include "frc/DARE.h"
 #include "frc/MathUtil.h"
 #include "frc/system/Discretization.h"
+#include "units/math.h"
+#include "units/velocity.h"
 
 using namespace frc;
 
@@ -26,7 +28,7 @@ DifferentialDriveWheelVoltages LTVDifferentialDriveController::Calculate(
   //     [vₗ]
   //     [vᵣ]
 
-  units::meters_per_second_t velocity{(leftVelocity + rightVelocity) / 2.0};
+  units::meters_per_second_t velocity = (leftVelocity + rightVelocity) / 2.0;
 
   // The DARE is ill-conditioned if the velocity is close to zero, so don't
   // let the system stop.
@@ -60,7 +62,7 @@ DifferentialDriveWheelVoltages LTVDifferentialDriveController::Calculate(
   Eigen::Matrix<double, 5, 2> discB;
   DiscretizeAB(A, B, m_dt, &discA, &discB);
 
-  auto S = DARE<5, 2>(discA, discB, m_Q, m_R, false).value();
+  auto S = DARE<5, 2>(discA, discB, m_Q, m_R, false). value();
 
   // K = (BᵀSB + R)⁻¹BᵀSA
   Eigen::Matrix<double, 2, 5> K = (discB.transpose() * S * discB + m_R)
diff --git a/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp b/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp
index b525e256e8..f6fc1d787b 100644
--- a/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp
+++ b/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp
@@ -67,7 +67,7 @@ ChassisSpeeds LTVUnicycleController::Calculate(
   Eigen::Matrix<double, 3, 2> discB;
   DiscretizeAB(A, B, m_dt, &discA, &discB);
 
-  auto S = DARE<3, 2>(discA, discB, m_Q, m_R, false).value();
+  auto S = DARE<3, 2>(discA, discB, m_Q, m_R, false). value();
 
   // K = (BᵀSB + R)⁻¹BᵀSA
   Eigen::Matrix<double, 2, 3> K = (discB.transpose() * S * discB + m_R)
diff --git a/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp b/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp
index ab53ecb5d1..37f19710ca 100644
--- a/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp
+++ b/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp
@@ -6,6 +6,8 @@
 
 #include <sleipnir/optimization/problem.hpp>
 
+#include "units/length.h"
+
 using namespace frc;
 
 Translation2d Ellipse2d::Nearest(const Translation2d& point) const {
@@ -41,8 +43,8 @@ Translation2d Ellipse2d::Nearest(const Translation2d& point) const {
 
     problem.solve();
 
-    rotPoint = frc::Translation2d{units::meter_t{x.value()},
-                                  units::meter_t{y.value()}};
+    rotPoint = frc::Translation2d{units::meter_t{x. value()},
+                                  units::meter_t{y. value()}};
   }
 
   // Undo rotation
diff --git a/wpimath/src/main/native/cpp/jni/ArmFeedforwardJNI.cpp b/wpimath/src/main/native/cpp/jni/ArmFeedforwardJNI.cpp
index 54748f151f..b652d85e04 100644
--- a/wpimath/src/main/native/cpp/jni/ArmFeedforwardJNI.cpp
+++ b/wpimath/src/main/native/cpp/jni/ArmFeedforwardJNI.cpp
@@ -8,6 +8,10 @@
 
 #include "edu_wpi_first_math_jni_ArmFeedforwardJNI.h"
 #include "frc/controller/ArmFeedforward.h"
+#include "units/angle.h"
+#include "units/angular_velocity.h"
+#include "units/base.h"
+#include "units/voltage.h"
 
 using namespace wpi::java;
 
diff --git a/wpimath/src/main/native/cpp/jni/DAREJNI.cpp b/wpimath/src/main/native/cpp/jni/DAREJNI.cpp
index b5d441dee7..a3d3a66192 100644
--- a/wpimath/src/main/native/cpp/jni/DAREJNI.cpp
+++ b/wpimath/src/main/native/cpp/jni/DAREJNI.cpp
@@ -48,7 +48,7 @@ Java_edu_wpi_first_math_jni_DAREJNI_dareNoPrecondABQR
 
   auto result =
       frc::DARE<Eigen::Dynamic, Eigen::Dynamic>(Amat, Bmat, Qmat, Rmat, false)
-          .value();
+          . value();
 
   env->SetDoubleArrayRegion(S, 0, states * states, result.data());
 }
@@ -87,7 +87,7 @@ Java_edu_wpi_first_math_jni_DAREJNI_dareNoPrecondABQRN
 
   auto result = frc::DARE<Eigen::Dynamic, Eigen::Dynamic>(Amat, Bmat, Qmat,
                                                           Rmat, Nmat, false)
-                    .value();
+                    . value();
 
   env->SetDoubleArrayRegion(S, 0, states * states, result.data());
 }
@@ -122,7 +122,7 @@ Java_edu_wpi_first_math_jni_DAREJNI_dareABQR
 
   if (auto result =
           frc::DARE<Eigen::Dynamic, Eigen::Dynamic>(Amat, Bmat, Qmat, Rmat)) {
-    env->SetDoubleArrayRegion(S, 0, states * states, result.value().data());
+    env->SetDoubleArrayRegion(S, 0, states * states, result. value().data());
     // K = (BᵀSB + R)⁻¹BᵀSA
   } else if (result.error() == frc::DAREError::QNotSymmetric ||
              result.error() == frc::DAREError::QNotPositiveSemidefinite) {
@@ -175,7 +175,7 @@ Java_edu_wpi_first_math_jni_DAREJNI_dareABQRN
 
   if (auto result = frc::DARE<Eigen::Dynamic, Eigen::Dynamic>(Amat, Bmat, Qmat,
                                                               Rmat, Nmat)) {
-    env->SetDoubleArrayRegion(S, 0, states * states, result.value().data());
+    env->SetDoubleArrayRegion(S, 0, states * states, result. value().data());
   } else if (result.error() == frc::DAREError::QNotSymmetric ||
              result.error() == frc::DAREError::QNotPositiveSemidefinite) {
     illegalArgEx.Throw(
diff --git a/wpimath/src/main/native/cpp/jni/Ellipse2dJNI.cpp b/wpimath/src/main/native/cpp/jni/Ellipse2dJNI.cpp
index 72538dc3f8..640ca6d9fb 100644
--- a/wpimath/src/main/native/cpp/jni/Ellipse2dJNI.cpp
+++ b/wpimath/src/main/native/cpp/jni/Ellipse2dJNI.cpp
@@ -9,6 +9,8 @@
 
 #include "edu_wpi_first_math_jni_Ellipse2dJNI.h"
 #include "frc/geometry/Ellipse2d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace wpi::java;
 
diff --git a/wpimath/src/main/native/cpp/kinematics/MecanumDriveKinematics.cpp b/wpimath/src/main/native/cpp/kinematics/MecanumDriveKinematics.cpp
index c21a7b2034..508226fd8b 100644
--- a/wpimath/src/main/native/cpp/kinematics/MecanumDriveKinematics.cpp
+++ b/wpimath/src/main/native/cpp/kinematics/MecanumDriveKinematics.cpp
@@ -4,6 +4,11 @@
 
 #include "frc/kinematics/MecanumDriveKinematics.h"
 
+#include "units/angle.h"
+#include "units/angular_velocity.h"
+#include "units/length.h"
+#include "units/velocity.h"
+
 using namespace frc;
 
 MecanumDriveWheelSpeeds MecanumDriveKinematics::ToWheelSpeeds(
@@ -44,7 +49,7 @@ ChassisSpeeds MecanumDriveKinematics::ToChassisSpeeds(
   Eigen::Vector3d chassisSpeedsVector =
       m_forwardKinematics.solve(wheelSpeedsVector);
 
-  return {units::meters_per_second_t{chassisSpeedsVector(0)},  // NOLINT
+  return {units::meters_per_second_t{chassisSpeedsVector(0)},
           units::meters_per_second_t{chassisSpeedsVector(1)},
           units::radians_per_second_t{chassisSpeedsVector(2)}};
 }
diff --git a/wpimath/src/main/native/cpp/trajectory/TrajectoryGenerator.cpp b/wpimath/src/main/native/cpp/trajectory/TrajectoryGenerator.cpp
index e12157a43c..542ef4ab4e 100644
--- a/wpimath/src/main/native/cpp/trajectory/TrajectoryGenerator.cpp
+++ b/wpimath/src/main/native/cpp/trajectory/TrajectoryGenerator.cpp
@@ -12,6 +12,7 @@
 #include "frc/spline/SplineHelper.h"
 #include "frc/spline/SplineParameterizer.h"
 #include "frc/trajectory/TrajectoryParameterizer.h"
+#include "units/angle.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp b/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp
index fb2d6cdb6b..0446cbafba 100644
--- a/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp
+++ b/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp
@@ -28,6 +28,7 @@
 
 #include "frc/trajectory/TrajectoryParameterizer.h"
 
+#include <algorithm>
 #include <vector>
 
 #include <fmt/format.h>
@@ -66,7 +67,7 @@ Trajectory TrajectoryParameterizer::TimeParameterizeTrajectory(
       // Enforce global max velocity and max reachable velocity by global
       // acceleration limit. v_f = √(v_i² + 2ad).
 
-      constrainedState.maxVelocity = units::math::min(
+      constrainedState.maxVelocity = std::min(
           maxVelocity,
           units::math::sqrt(predecessor.maxVelocity * predecessor.maxVelocity +
                             predecessor.maxAcceleration * ds * 2.0));
@@ -77,7 +78,7 @@ Trajectory TrajectoryParameterizer::TimeParameterizeTrajectory(
       // At this point, the constrained state is fully constructed apart from
       // all the custom-defined user constraints.
       for (const auto& constraint : constraints) {
-        constrainedState.maxVelocity = units::math::min(
+        constrainedState.maxVelocity = std::min(
             constrainedState.maxVelocity,
             constraint->MaxVelocity(constrainedState.pose.first,
                                     constrainedState.pose.second,
@@ -230,11 +231,11 @@ void TrajectoryParameterizer::EnforceAccelerationLimits(
           "back one-by-one.");
     }
 
-    state->minAcceleration = units::math::max(
+    state->minAcceleration = std::max(
         state->minAcceleration,
         reverse ? -minMaxAccel.maxAcceleration : minMaxAccel.minAcceleration);
 
-    state->maxAcceleration = units::math::min(
+    state->maxAcceleration = std::min(
         state->maxAcceleration,
         reverse ? -minMaxAccel.minAcceleration : minMaxAccel.maxAcceleration);
   }
diff --git a/wpimath/src/main/native/include/frc/MathUtil.h b/wpimath/src/main/native/include/frc/MathUtil.h
index 97705811f9..5800462865 100644
--- a/wpimath/src/main/native/include/frc/MathUtil.h
+++ b/wpimath/src/main/native/include/frc/MathUtil.h
@@ -142,11 +142,11 @@ constexpr T InputModulus(T input, T minimumInput, T maximumInput) {
   T modulus = maximumInput - minimumInput;
 
   // Wrap input if it's above the maximum input
-  int numMax = (input - minimumInput) / modulus;
+  int numMax = static_cast<int>((input - minimumInput) / modulus);
   input -= numMax * modulus;
 
   // Wrap input if it's below the minimum input
-  int numMin = (input - maximumInput) / modulus;
+  int numMin = static_cast<int>((input - maximumInput) / modulus);
   input -= numMin * modulus;
 
   return input;
@@ -279,7 +279,7 @@ constexpr Translation2d SlewRateLimit(const Translation2d& current,
   }
   if (dist > maxVelocity * dt) {
     // Move maximum allowed amount in direction of the difference
-    return current + diff * (maxVelocity * dt / dist);
+    return current + diff * double{maxVelocity * dt / dist};
   }
   return next;
 }
@@ -309,7 +309,7 @@ constexpr Translation3d SlewRateLimit(const Translation3d& current,
   }
   if (dist > maxVelocity * dt) {
     // Move maximum allowed amount in direction of the difference
-    return current + diff * (maxVelocity * dt / dist);
+    return current + diff * double{maxVelocity * dt / dist};
   }
   return next;
 }
diff --git a/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h b/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h
index d6bdc0f81c..d23a7ebbad 100644
--- a/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h
+++ b/wpimath/src/main/native/include/frc/controller/ArmFeedforward.h
@@ -23,12 +23,10 @@ namespace frc {
 class WPILIB_DLLEXPORT ArmFeedforward {
  public:
   using Angle = units::radians;
-  using Velocity = units::radians_per_second;
-  using Acceleration = units::compound_unit<units::radians_per_second,
-                                            units::inverse<units::second>>;
+  using Velocity = units::compound_unit<Angle, units::inverse<units::second>>;
+  using Acceleration = units::compound_unit<Velocity, units::inverse<units::second>>;
   using kv_unit =
-      units::compound_unit<units::volts,
-                           units::inverse<units::radians_per_second>>;
+      units::compound_unit<units::volts, units::inverse<Velocity>>;
   using ka_unit =
       units::compound_unit<units::volts, units::inverse<Acceleration>>;
 
diff --git a/wpimath/src/main/native/include/frc/controller/DifferentialDriveFeedforward.h b/wpimath/src/main/native/include/frc/controller/DifferentialDriveFeedforward.h
index da66a439b0..7d8107579d 100644
--- a/wpimath/src/main/native/include/frc/controller/DifferentialDriveFeedforward.h
+++ b/wpimath/src/main/native/include/frc/controller/DifferentialDriveFeedforward.h
@@ -43,9 +43,11 @@ class WPILIB_DLLEXPORT DifferentialDriveFeedforward {
       decltype(1_V / 1_mps) kVLinear, decltype(1_V / 1_mps_sq) kALinear,
       decltype(1_V / 1_rad_per_s) kVAngular,
       decltype(1_V / 1_rad_per_s_sq) kAAngular, units::meter_t trackwidth)
-      // See LinearSystemId::IdentifyDrivetrainSystem(decltype(1_V / 1_mps),
-      // decltype(1_V / 1_mps_sq), decltype(1_V / 1_rad_per_s), decltype(1_V /
-      // 1_rad_per_s_sq))
+      // See LinearSystemId::IdentifyDrivetrainSystem(
+      // decltype(1_V / 1_mps),
+      // decltype(1_V / 1_mps_sq),
+      // decltype(1_V / 1_rad_per_s),
+      // decltype(1_V / 1_rad_per_s_sq))
       : DifferentialDriveFeedforward{kVLinear, kALinear,
                                      kVAngular * 2.0 / trackwidth * 1_rad,
                                      kAAngular * 2.0 / trackwidth * 1_rad} {}
diff --git a/wpimath/src/main/native/include/frc/controller/ImplicitModelFollower.h b/wpimath/src/main/native/include/frc/controller/ImplicitModelFollower.h
index f030d4898c..b6223c9293 100644
--- a/wpimath/src/main/native/include/frc/controller/ImplicitModelFollower.h
+++ b/wpimath/src/main/native/include/frc/controller/ImplicitModelFollower.h
@@ -9,7 +9,6 @@
 #include <Eigen/QR>
 
 #include "frc/EigenCore.h"
-#include "units/time.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/controller/LinearQuadraticRegulator.h b/wpimath/src/main/native/include/frc/controller/LinearQuadraticRegulator.h
index 10a2862683..379864307d 100644
--- a/wpimath/src/main/native/include/frc/controller/LinearQuadraticRegulator.h
+++ b/wpimath/src/main/native/include/frc/controller/LinearQuadraticRegulator.h
@@ -105,9 +105,9 @@ class LinearQuadraticRegulator {
 
     if (auto S = DARE<States, Inputs>(discA, discB, Q, R)) {
       // K = (BᵀSB + R)⁻¹BᵀSA
-      m_K = (discB.transpose() * S.value() * discB + R)
+      m_K = (discB.transpose() * S. value() * discB + R)
                 .llt()
-                .solve(discB.transpose() * S.value() * discA);
+                .solve(discB.transpose() * S. value() * discA);
     } else if (S.error() == DAREError::QNotSymmetric ||
                S.error() == DAREError::QNotPositiveSemidefinite) {
       std::string msg = fmt::format("{}\n\nQ =\n{}\n", to_string(S.error()), Q);
@@ -160,9 +160,9 @@ class LinearQuadraticRegulator {
 
     if (auto S = DARE<States, Inputs>(discA, discB, Q, R, N)) {
       // K = (BᵀSB + R)⁻¹(BᵀSA + Nᵀ)
-      m_K = (discB.transpose() * S.value() * discB + R)
+      m_K = (discB.transpose() * S. value() * discB + R)
                 .llt()
-                .solve(discB.transpose() * S.value() * discA + N.transpose());
+                .solve(discB.transpose() * S. value() * discA + N.transpose());
     } else if (S.error() == DAREError::QNotSymmetric ||
                S.error() == DAREError::QNotPositiveSemidefinite) {
       std::string msg = fmt::format("{}\n\nQ =\n{}\n", to_string(S.error()), Q);
@@ -296,7 +296,7 @@ class LinearQuadraticRegulator {
     Matrixd<States, Inputs> discB;
     DiscretizeAB<States, Inputs>(plant.A(), plant.B(), dt, &discA, &discB);
 
-    m_K = m_K * (discA - discB * m_K).pow(inputDelay / dt);
+    m_K = m_K * (discA - discB * m_K).pow(double{inputDelay / dt});
   }
 
  private:
diff --git a/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h b/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h
index aed953150a..899ab88b88 100644
--- a/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h
+++ b/wpimath/src/main/native/include/frc/controller/proto/SimpleMotorFeedforwardProto.h
@@ -48,11 +48,9 @@ struct wpi::Protobuf<frc::SimpleMotorFeedforward<Distance>> {
         units::unit<std::ratio<1>, units::traits::base_unit_of<Distance>>;
     using BaseFeedforward = frc::SimpleMotorFeedforward<BaseUnit>;
     wpi_proto_ProtobufSimpleMotorFeedforward msg{
-        .ks = value.GetKs().value(),
-        .kv = units::unit_t<typename BaseFeedforward::kv_unit>{value.GetKv()}
-                  .value(),
-        .ka = units::unit_t<typename BaseFeedforward::ka_unit>{value.GetKa()}
-                  .value(),
+        .ks = units::volt_t{value.GetKs()}.value(),
+        .kv = units::unit_t<typename BaseFeedforward::kv_unit>{value.GetKv()}.value(),
+        .ka = units::unit_t<typename BaseFeedforward::ka_unit>{value.GetKa()}.value(),
         .dt = units::second_t{value.GetDt()}.value(),
     };
     return stream.Encode(msg);
diff --git a/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h b/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h
index 12b3186f7b..3af62a738e 100644
--- a/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h
+++ b/wpimath/src/main/native/include/frc/controller/struct/SimpleMotorFeedforwardStruct.h
@@ -50,13 +50,11 @@ struct wpi::Struct<frc::SimpleMotorFeedforward<Distance>> {
     constexpr size_t kKvOff = kKsOff + 8;
     constexpr size_t kKaOff = kKvOff + 8;
     constexpr size_t kDtOff = kKaOff + 8;
-    wpi::PackStruct<kKsOff>(data, value.GetKs().value());
+    wpi::PackStruct<kKsOff>(data, units::volt_t{value.GetKs()}.value());
     wpi::PackStruct<kKvOff>(
-        data, units::unit_t<typename BaseFeedforward::kv_unit>{value.GetKv()}
-                  .value());
+        data, units::unit_t<typename BaseFeedforward::kv_unit>{value.GetKv()}.value());
     wpi::PackStruct<kKaOff>(
-        data, units::unit_t<typename BaseFeedforward::ka_unit>{value.GetKa()}
-                  .value());
+        data, units::unit_t<typename BaseFeedforward::ka_unit>{value.GetKa()}.value());
     wpi::PackStruct<kDtOff>(data, units::second_t{value.GetDt()}.value());
   }
 };
@@ -64,6 +62,6 @@ struct wpi::Struct<frc::SimpleMotorFeedforward<Distance>> {
 static_assert(
     wpi::StructSerializable<frc::SimpleMotorFeedforward<units::meters>>);
 static_assert(
-    wpi::StructSerializable<frc::SimpleMotorFeedforward<units::feet>>);
+    wpi::StructSerializable<frc::SimpleMotorFeedforward<units::centimeters>>);
 static_assert(
     wpi::StructSerializable<frc::SimpleMotorFeedforward<units::radians>>);
diff --git a/wpimath/src/main/native/include/frc/estimator/AngleStatistics.h b/wpimath/src/main/native/include/frc/estimator/AngleStatistics.h
index 8b94313ba7..7d424c6b0f 100644
--- a/wpimath/src/main/native/include/frc/estimator/AngleStatistics.h
+++ b/wpimath/src/main/native/include/frc/estimator/AngleStatistics.h
@@ -9,6 +9,7 @@
 
 #include "frc/EigenCore.h"
 #include "frc/MathUtil.h"
+#include "units/angle.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/estimator/ExtendedKalmanFilter.h b/wpimath/src/main/native/include/frc/estimator/ExtendedKalmanFilter.h
index 22eddbc281..cff7d5d494 100644
--- a/wpimath/src/main/native/include/frc/estimator/ExtendedKalmanFilter.h
+++ b/wpimath/src/main/native/include/frc/estimator/ExtendedKalmanFilter.h
@@ -104,7 +104,7 @@ class ExtendedKalmanFilter {
     if (IsDetectable<States, Outputs>(discA, C) && Outputs <= States) {
       if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(),
                                          discQ, discR)) {
-        m_initP = P.value();
+        m_initP = P. value();
       } else if (P.error() == DAREError::QNotSymmetric ||
                  P.error() == DAREError::QNotPositiveSemidefinite) {
         std::string msg =
@@ -188,7 +188,7 @@ class ExtendedKalmanFilter {
     if (IsDetectable<States, Outputs>(discA, C) && Outputs <= States) {
       if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(),
                                          discQ, discR)) {
-        m_initP = P.value();
+        m_initP = P. value();
       } else if (P.error() == DAREError::QNotSymmetric ||
                  P.error() == DAREError::QNotPositiveSemidefinite) {
         std::string msg =
diff --git a/wpimath/src/main/native/include/frc/estimator/KalmanFilter.h b/wpimath/src/main/native/include/frc/estimator/KalmanFilter.h
index aa169368bb..26c4b35c05 100644
--- a/wpimath/src/main/native/include/frc/estimator/KalmanFilter.h
+++ b/wpimath/src/main/native/include/frc/estimator/KalmanFilter.h
@@ -87,7 +87,7 @@ class KalmanFilter {
 
     if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(), discQ,
                                        discR)) {
-      m_initP = P.value();
+      m_initP = P. value();
     } else if (P.error() == DAREError::QNotSymmetric ||
                P.error() == DAREError::QNotPositiveSemidefinite) {
       std::string msg =
diff --git a/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator.h b/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator.h
index d748164f47..8b91b186d6 100644
--- a/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator.h
+++ b/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator.h
@@ -15,7 +15,6 @@
 #include "frc/interpolation/TimeInterpolatableBuffer.h"
 #include "frc/kinematics/MecanumDriveKinematics.h"
 #include "frc/kinematics/MecanumDriveOdometry.h"
-#include "units/time.h"
 
 namespace frc {
 /**
diff --git a/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator3d.h b/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator3d.h
index bb1c6ea693..6858742052 100644
--- a/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator3d.h
+++ b/wpimath/src/main/native/include/frc/estimator/MecanumDrivePoseEstimator3d.h
@@ -15,7 +15,6 @@
 #include "frc/interpolation/TimeInterpolatableBuffer.h"
 #include "frc/kinematics/MecanumDriveKinematics.h"
 #include "frc/kinematics/MecanumDriveOdometry3d.h"
-#include "units/time.h"
 
 namespace frc {
 /**
diff --git a/wpimath/src/main/native/include/frc/estimator/PoseEstimator.h b/wpimath/src/main/native/include/frc/estimator/PoseEstimator.h
index 46d124f7de..f933edfcc8 100644
--- a/wpimath/src/main/native/include/frc/estimator/PoseEstimator.h
+++ b/wpimath/src/main/native/include/frc/estimator/PoseEstimator.h
@@ -263,7 +263,7 @@ class WPILIB_DLLEXPORT PoseEstimator {
 
     // Step 4: Measure the twist between the old pose estimate and the vision
     // pose.
-    auto twist = (visionRobotPose - visionSample.value()).Log();
+    auto twist = (visionRobotPose - visionSample. value()).Log();
 
     // Step 5: We should not trust the twist entirely, so instead we scale this
     // twist by a Kalman gain matrix representing how much we trust vision
@@ -278,7 +278,7 @@ class WPILIB_DLLEXPORT PoseEstimator {
                         units::radian_t{k_times_twist(2)}};
 
     // Step 7: Calculate and record the vision update.
-    VisionUpdate visionUpdate{visionSample.value() + scaledTwist.Exp(),
+    VisionUpdate visionUpdate{visionSample. value() + scaledTwist.Exp(),
                               *odometrySample};
     m_visionUpdates[timestamp] = visionUpdate;
 
diff --git a/wpimath/src/main/native/include/frc/estimator/PoseEstimator3d.h b/wpimath/src/main/native/include/frc/estimator/PoseEstimator3d.h
index 68e99dd4f2..4f881d6715 100644
--- a/wpimath/src/main/native/include/frc/estimator/PoseEstimator3d.h
+++ b/wpimath/src/main/native/include/frc/estimator/PoseEstimator3d.h
@@ -272,7 +272,7 @@ class WPILIB_DLLEXPORT PoseEstimator3d {
 
     // Step 4: Measure the twist between the old pose estimate and the vision
     // pose.
-    auto twist = (visionRobotPose - visionSample.value()).Log();
+    auto twist = (visionRobotPose - visionSample. value()).Log();
 
     // Step 5: We should not trust the twist entirely, so instead we scale this
     // twist by a Kalman gain matrix representing how much we trust vision
@@ -289,7 +289,7 @@ class WPILIB_DLLEXPORT PoseEstimator3d {
         units::radian_t{k_times_twist(4)}, units::radian_t{k_times_twist(5)}};
 
     // Step 7: Calculate and record the vision update.
-    VisionUpdate visionUpdate{visionSample.value() + scaledTwist.Exp(),
+    VisionUpdate visionUpdate{visionSample. value() + scaledTwist.Exp(),
                               *odometrySample};
     m_visionUpdates[timestamp] = visionUpdate;
 
diff --git a/wpimath/src/main/native/include/frc/estimator/SteadyStateKalmanFilter.h b/wpimath/src/main/native/include/frc/estimator/SteadyStateKalmanFilter.h
index 734c70c7e0..1ae8c0e286 100644
--- a/wpimath/src/main/native/include/frc/estimator/SteadyStateKalmanFilter.h
+++ b/wpimath/src/main/native/include/frc/estimator/SteadyStateKalmanFilter.h
@@ -100,7 +100,7 @@ class SteadyStateKalmanFilter {
     if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(), discQ,
                                        discR)) {
       // S = CPCᵀ + R
-      Matrixd<Outputs, Outputs> S = C * P.value() * C.transpose() + discR;
+      Matrixd<Outputs, Outputs> S = C * P. value() * C.transpose() + discR;
 
       // We want to put K = PCᵀS⁻¹ into Ax = b form so we can solve it more
       // efficiently.
@@ -118,7 +118,7 @@ class SteadyStateKalmanFilter {
       // Drop the transposes on symmetric matrices S and P.
       //
       // K = (S.solve(CP))ᵀ
-      m_K = S.ldlt().solve(C * P.value()).transpose();
+      m_K = S.ldlt().solve(C * P. value()).transpose();
     } else if (P.error() == DAREError::QNotSymmetric ||
                P.error() == DAREError::QNotPositiveSemidefinite) {
       std::string msg =
diff --git a/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator.h b/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator.h
index a03dde9399..98b0cdf7e9 100644
--- a/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator.h
+++ b/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator.h
@@ -14,7 +14,6 @@
 #include "frc/geometry/Rotation2d.h"
 #include "frc/kinematics/SwerveDriveKinematics.h"
 #include "frc/kinematics/SwerveDriveOdometry.h"
-#include "units/time.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator3d.h b/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator3d.h
index 7efcbb573c..383de91b23 100644
--- a/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator3d.h
+++ b/wpimath/src/main/native/include/frc/estimator/SwerveDrivePoseEstimator3d.h
@@ -14,7 +14,6 @@
 #include "frc/geometry/Rotation2d.h"
 #include "frc/kinematics/SwerveDriveKinematics.h"
 #include "frc/kinematics/SwerveDriveOdometry3d.h"
-#include "units/time.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h b/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h
index f04aac4855..a784e3746b 100644
--- a/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h
+++ b/wpimath/src/main/native/include/frc/filter/SlewRateLimiter.h
@@ -45,8 +45,7 @@ class SlewRateLimiter {
       : m_positiveRateLimit{positiveRateLimit},
         m_negativeRateLimit{negativeRateLimit},
         m_prevVal{initialValue},
-        m_prevTime{
-            units::microsecond_t{wpi::math::MathSharedStore::GetTimestamp()}} {}
+        m_prevTime{wpi::math::MathSharedStore::GetTimestamp()} {}
 
   /**
    * Creates a new SlewRateLimiter with the given positive rate limit and
diff --git a/wpimath/src/main/native/include/frc/geometry/Ellipse2d.h b/wpimath/src/main/native/include/frc/geometry/Ellipse2d.h
index 629faf5922..28f6187915 100644
--- a/wpimath/src/main/native/include/frc/geometry/Ellipse2d.h
+++ b/wpimath/src/main/native/include/frc/geometry/Ellipse2d.h
@@ -4,6 +4,7 @@
 
 #pragma once
 
+#include <algorithm>
 #include <stdexcept>
 
 #include <gcem.hpp>
@@ -47,7 +48,7 @@ class WPILIB_DLLEXPORT Ellipse2d {
    * @param center The center of the circle.
    * @param radius The radius of the circle.
    */
-  constexpr Ellipse2d(const Translation2d& center, double radius)
+  constexpr Ellipse2d(const Translation2d& center, units::meter_t radius)
       : m_center{center, Rotation2d{}},
         m_xSemiAxis{radius},
         m_ySemiAxis{radius} {}
@@ -88,10 +89,10 @@ class WPILIB_DLLEXPORT Ellipse2d {
    */
   constexpr wpi::array<Translation2d, 2> FocalPoints() const {
     // Major semi-axis
-    auto a = units::math::max(m_xSemiAxis, m_ySemiAxis);
+    auto a = std::max(m_xSemiAxis, m_ySemiAxis);
 
     // Minor semi-axis
-    auto b = units::math::min(m_xSemiAxis, m_ySemiAxis);  // NOLINT
+    auto b = std::min(m_xSemiAxis, m_ySemiAxis);
 
     auto c = units::math::sqrt(a * a - b * b);
 
@@ -203,8 +204,8 @@ class WPILIB_DLLEXPORT Ellipse2d {
     auto x = rotPoint.X() - m_center.X();
     auto y = rotPoint.Y() - m_center.Y();
 
-    return (x * x) / (m_xSemiAxis * m_xSemiAxis) +
-           (y * y) / (m_ySemiAxis * m_ySemiAxis);
+    return double{(x * x) / (m_xSemiAxis * m_xSemiAxis) +
+                  (y * y) / (m_ySemiAxis * m_ySemiAxis)};
   }
 };
 
diff --git a/wpimath/src/main/native/include/frc/geometry/Pose3d.h b/wpimath/src/main/native/include/frc/geometry/Pose3d.h
index ebf4de6827..a055bb6256 100644
--- a/wpimath/src/main/native/include/frc/geometry/Pose3d.h
+++ b/wpimath/src/main/native/include/frc/geometry/Pose3d.h
@@ -19,6 +19,8 @@
 #include "frc/geometry/Pose2d.h"
 #include "frc/geometry/Rotation3d.h"
 #include "frc/geometry/Translation3d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/geometry/Rotation2d.h b/wpimath/src/main/native/include/frc/geometry/Rotation2d.h
index 2b33d6d26a..f4718cf7e9 100644
--- a/wpimath/src/main/native/include/frc/geometry/Rotation2d.h
+++ b/wpimath/src/main/native/include/frc/geometry/Rotation2d.h
@@ -36,8 +36,8 @@ class WPILIB_DLLEXPORT Rotation2d {
    * @param value The value of the angle.
    */
   constexpr Rotation2d(units::angle_unit auto value)  // NOLINT
-      : m_cos{gcem::cos(value.template convert<units::radian>().value())},
-        m_sin{gcem::sin(value.template convert<units::radian>().value())} {}
+      : m_cos{gcem::cos(units::radian_t{value}.value())},
+        m_sin{gcem::sin(units::radian_t{value}.value())} {}
 
   /**
    * Constructs a Rotation2d with the given x and y (cosine and sine)
diff --git a/wpimath/src/main/native/include/frc/geometry/Rotation3d.h b/wpimath/src/main/native/include/frc/geometry/Rotation3d.h
index 8d1e975299..fa5243b405 100644
--- a/wpimath/src/main/native/include/frc/geometry/Rotation3d.h
+++ b/wpimath/src/main/native/include/frc/geometry/Rotation3d.h
@@ -311,9 +311,9 @@ class WPILIB_DLLEXPORT Rotation3d {
   /**
    * Adds the new rotation to the current rotation. The other rotation is
    * applied extrinsically, which means that it rotates around the global axes.
-   * For example, Rotation3d{90_deg, 0, 0}.RotateBy(Rotation3d{0, 45_deg, 0})
+   * For example, Rotation3d{90_deg, 0_deg, 0_deg}.RotateBy(Rotation3d{0_deg, 45_deg, 0_deg})
    * rotates by 90 degrees around the +X axis and then by 45 degrees around the
-   * global +Y axis. (This is equivalent to Rotation3d{90_deg, 45_deg, 0})
+   * global +Y axis. (This is equivalent to Rotation3d{90_deg, 45_deg, 0_deg})
    *
    * @param other The extrinsic rotation to rotate by.
    *
diff --git a/wpimath/src/main/native/include/frc/geometry/Transform2d.h b/wpimath/src/main/native/include/frc/geometry/Transform2d.h
index d85abb4ded..533e022502 100644
--- a/wpimath/src/main/native/include/frc/geometry/Transform2d.h
+++ b/wpimath/src/main/native/include/frc/geometry/Transform2d.h
@@ -10,6 +10,7 @@
 
 #include "frc/geometry/Rotation2d.h"
 #include "frc/geometry/Translation2d.h"
+#include "units/length.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/geometry/Transform3d.h b/wpimath/src/main/native/include/frc/geometry/Transform3d.h
index b424ddf48c..d4592bfead 100644
--- a/wpimath/src/main/native/include/frc/geometry/Transform3d.h
+++ b/wpimath/src/main/native/include/frc/geometry/Transform3d.h
@@ -10,6 +10,7 @@
 
 #include "frc/geometry/Transform2d.h"
 #include "frc/geometry/Translation3d.h"
+#include "units/length.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/interpolation/TimeInterpolatableBuffer.h b/wpimath/src/main/native/include/frc/interpolation/TimeInterpolatableBuffer.h
index 74824c2620..662f366c5b 100644
--- a/wpimath/src/main/native/include/frc/interpolation/TimeInterpolatableBuffer.h
+++ b/wpimath/src/main/native/include/frc/interpolation/TimeInterpolatableBuffer.h
@@ -128,8 +128,8 @@ class TimeInterpolatableBuffer {
 
     auto lower_bound = upper_bound - 1;
 
-    double t = ((time - lower_bound->first) /
-                (upper_bound->first - lower_bound->first));
+    double t = double{((time - lower_bound->first) /
+                      (upper_bound->first - lower_bound->first))};
 
     return m_interpolatingFunc(lower_bound->second, upper_bound->second, t);
   }
diff --git a/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h b/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h
index fb3d7fbfdb..8d902768d4 100644
--- a/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h
+++ b/wpimath/src/main/native/include/frc/kinematics/DifferentialDriveWheelSpeeds.h
@@ -4,6 +4,8 @@
 
 #pragma once
 
+#include <algorithm>
+
 #include <wpi/SymbolExports.h>
 
 #include "units/math.h"
@@ -38,7 +40,7 @@ struct WPILIB_DLLEXPORT DifferentialDriveWheelSpeeds {
    */
   constexpr void Desaturate(units::meters_per_second_t attainableMaxSpeed) {
     auto realMaxSpeed =
-        units::math::max(units::math::abs(left), units::math::abs(right));
+        std::max(units::math::abs(left), units::math::abs(right));
 
     if (realMaxSpeed > attainableMaxSpeed) {
       left = left / realMaxSpeed * attainableMaxSpeed;
diff --git a/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry.h b/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry.h
index 0a6f537cd7..046a857b2e 100644
--- a/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry.h
+++ b/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry.h
@@ -12,7 +12,6 @@
 #include "frc/kinematics/MecanumDriveWheelPositions.h"
 #include "frc/kinematics/MecanumDriveWheelSpeeds.h"
 #include "frc/kinematics/Odometry.h"
-#include "units/time.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry3d.h b/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry3d.h
index 2f3726e45d..4412616daa 100644
--- a/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry3d.h
+++ b/wpimath/src/main/native/include/frc/kinematics/MecanumDriveOdometry3d.h
@@ -12,7 +12,6 @@
 #include "frc/kinematics/MecanumDriveWheelPositions.h"
 #include "frc/kinematics/MecanumDriveWheelSpeeds.h"
 #include "frc/kinematics/Odometry3d.h"
-#include "units/time.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/kinematics/Odometry3d.h b/wpimath/src/main/native/include/frc/kinematics/Odometry3d.h
index 0c4b819bc0..c097c50cdf 100644
--- a/wpimath/src/main/native/include/frc/kinematics/Odometry3d.h
+++ b/wpimath/src/main/native/include/frc/kinematics/Odometry3d.h
@@ -13,6 +13,8 @@
 #include "frc/geometry/Translation2d.h"
 #include "frc/geometry/Translation3d.h"
 #include "frc/kinematics/Kinematics.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/kinematics/SwerveDriveKinematics.h b/wpimath/src/main/native/include/frc/kinematics/SwerveDriveKinematics.h
index 2aa2a88523..280057b347 100644
--- a/wpimath/src/main/native/include/frc/kinematics/SwerveDriveKinematics.h
+++ b/wpimath/src/main/native/include/frc/kinematics/SwerveDriveKinematics.h
@@ -188,8 +188,8 @@ class SwerveDriveKinematics
         m_inverseKinematics * chassisSpeedsVector;
 
     for (size_t i = 0; i < NumModules; i++) {
-      units::meters_per_second_t x{moduleStateMatrix(i * 2, 0)};
-      units::meters_per_second_t y{moduleStateMatrix(i * 2 + 1, 0)};
+      units::meters_per_second_t x = units::meters_per_second_t{moduleStateMatrix(i * 2, 0)};
+      units::meters_per_second_t y = units::meters_per_second_t{moduleStateMatrix(i * 2 + 1, 0)};
 
       auto speed = units::math::hypot(x, y);
       auto rotation = speed > 1e-6_mps ? Rotation2d{x.value(), y.value()}
@@ -416,9 +416,9 @@ class SwerveDriveKinematics
     auto rotationalK = units::math::abs(desiredChassisSpeed.omega) /
                        attainableMaxRobotRotationSpeed;
 
-    auto k = units::math::max(translationalK, rotationalK);
+    auto k = std::max(translationalK, rotationalK);
 
-    auto scale = units::math::min(k * attainableMaxModuleSpeed / realMaxSpeed,
+    auto scale = std::min(k * attainableMaxModuleSpeed / realMaxSpeed,
                                   units::scalar_t{1});
     for (auto& module : states) {
       module.speed = module.speed * scale;
diff --git a/wpimath/src/main/native/include/frc/kinematics/SwerveDriveOdometry3d.h b/wpimath/src/main/native/include/frc/kinematics/SwerveDriveOdometry3d.h
index 062118582c..c411ab7ffd 100644
--- a/wpimath/src/main/native/include/frc/kinematics/SwerveDriveOdometry3d.h
+++ b/wpimath/src/main/native/include/frc/kinematics/SwerveDriveOdometry3d.h
@@ -16,7 +16,6 @@
 #include "SwerveModulePosition.h"
 #include "SwerveModuleState.h"
 #include "frc/geometry/Pose2d.h"
-#include "units/time.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/path/TravelingSalesman.h b/wpimath/src/main/native/include/frc/path/TravelingSalesman.h
index d45f6203f8..e7f2704c03 100644
--- a/wpimath/src/main/native/include/frc/path/TravelingSalesman.h
+++ b/wpimath/src/main/native/include/frc/path/TravelingSalesman.h
@@ -15,6 +15,7 @@
 #include "frc/EigenCore.h"
 #include "frc/geometry/Pose2d.h"
 #include "frc/optimization/SimulatedAnnealing.h"
+#include "units/math.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/spline/SplineHelper.h b/wpimath/src/main/native/include/frc/spline/SplineHelper.h
index 4ad3694a31..784d406de7 100644
--- a/wpimath/src/main/native/include/frc/spline/SplineHelper.h
+++ b/wpimath/src/main/native/include/frc/spline/SplineHelper.h
@@ -12,6 +12,7 @@
 
 #include "frc/spline/CubicHermiteSpline.h"
 #include "frc/spline/QuinticHermiteSpline.h"
+#include "units/length.h"
 
 namespace frc {
 /**
diff --git a/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h b/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h
index cbcd9de13f..6b25d4cedd 100644
--- a/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h
+++ b/wpimath/src/main/native/include/frc/spline/SplineParameterizer.h
@@ -80,7 +80,7 @@ class WPILIB_DLLEXPORT SplineParameterizer {
 
     // The parameterization does not add the initial point. Let's add that.
     if (auto point = spline.GetPoint(t0)) {
-      splinePoints.push_back(point.value());
+      splinePoints.push_back(point. value());
     } else {
       throw MalformedSplineException(kMalformedSplineExceptionMsg);
     }
@@ -106,7 +106,7 @@ class WPILIB_DLLEXPORT SplineParameterizer {
         throw MalformedSplineException(kMalformedSplineExceptionMsg);
       }
 
-      const auto twist = (end.value().first - start.value().first).Log();
+      const auto twist = (end. value().first - start. value().first).Log();
 
       if (units::math::abs(twist.dy) > kMaxDy ||
           units::math::abs(twist.dx) > kMaxDx ||
@@ -114,7 +114,7 @@ class WPILIB_DLLEXPORT SplineParameterizer {
         stack.emplace(StackContents{(current.t0 + current.t1) / 2, current.t1});
         stack.emplace(StackContents{current.t0, (current.t0 + current.t1) / 2});
       } else {
-        splinePoints.push_back(end.value());
+        splinePoints.push_back(end. value());
       }
 
       if (iterations++ >= kMaxIterations) {
diff --git a/wpimath/src/main/native/include/frc/system/NumericalIntegration.h b/wpimath/src/main/native/include/frc/system/NumericalIntegration.h
index 2fe1946f0d..682b1fb2f8 100644
--- a/wpimath/src/main/native/include/frc/system/NumericalIntegration.h
+++ b/wpimath/src/main/native/include/frc/system/NumericalIntegration.h
@@ -61,7 +61,7 @@ T RK4(F&& f, T x, U u, units::second_t dt) {
  */
 template <typename F, typename T>
 T RK4(F&& f, units::second_t t, T y, units::second_t dt) {
-  const auto h = dt.to<double>();
+  const auto h = dt.value();
 
   T k1 = f(t, y);
   T k2 = f(t + dt * 0.5, y + h * k1 * 0.5);
@@ -198,13 +198,13 @@ T RKDP(F&& f, units::second_t t, T y, units::second_t dt,
   double truncationError;
 
   double dtElapsed = 0.0;
-  double h = dt.to<double>();
+  double h = dt.value();
 
   // Loop until we've gotten to our desired dt
-  while (dtElapsed < dt.to<double>()) {
+  while (dtElapsed < dt.value()) {
     do {
       // Only allow us to advance up to the dt remaining
-      h = std::min(h, dt.to<double>() - dtElapsed);
+      h = std::min(h, dt.value() - dtElapsed);
 
       // clang-format off
       T k1 = f(t, y);
diff --git a/wpimath/src/main/native/include/frc/trajectory/Trajectory.h b/wpimath/src/main/native/include/frc/trajectory/Trajectory.h
index 74c939356f..fb78d0aee9 100644
--- a/wpimath/src/main/native/include/frc/trajectory/Trajectory.h
+++ b/wpimath/src/main/native/include/frc/trajectory/Trajectory.h
@@ -45,7 +45,7 @@ class WPILIB_DLLEXPORT Trajectory {
     Pose2d pose;
 
     /// The curvature at that point of the trajectory.
-    units::curvature_t curvature{0.0};
+    units::curvature_t curvature = units::curvature_t{0.0};
 
     /**
      * Checks equality between this State and another object.
@@ -93,8 +93,8 @@ class WPILIB_DLLEXPORT Trajectory {
       // need to interpolate between the two endpoint poses. The fraction for
       // interpolation is the change in position (delta s) divided by the total
       // distance between the two endpoints.
-      const double interpolationFrac =
-          newS / endValue.pose.Translation().Distance(pose.Translation());
+      const double interpolationFrac = double{
+          newS / endValue.pose.Translation().Distance(pose.Translation())};
 
       return {newT, newV, acceleration,
               wpi::Lerp(pose, endValue.pose, interpolationFrac),
@@ -171,7 +171,7 @@ class WPILIB_DLLEXPORT Trajectory {
     }
     // Interpolate between the two states for the state that we want.
     return prevSample->Interpolate(
-        *sample, (t - prevSample->t) / (sample->t - prevSample->t));
+        *sample, double{(t - prevSample->t) / (sample->t - prevSample->t)});
   }
 
   /**
diff --git a/wpimath/src/main/native/include/frc/trajectory/TrajectoryGenerator.h b/wpimath/src/main/native/include/frc/trajectory/TrajectoryGenerator.h
index f7076bce1d..4cca2fecf5 100644
--- a/wpimath/src/main/native/include/frc/trajectory/TrajectoryGenerator.h
+++ b/wpimath/src/main/native/include/frc/trajectory/TrajectoryGenerator.h
@@ -16,6 +16,7 @@
 #include "frc/trajectory/TrajectoryConfig.h"
 #include "frc/trajectory/constraint/DifferentialDriveKinematicsConstraint.h"
 #include "frc/trajectory/constraint/TrajectoryConstraint.h"
+#include "units/curvature.h"
 
 namespace frc {
 /**
@@ -99,7 +100,7 @@ class WPILIB_DLLEXPORT TrajectoryGenerator {
     std::vector<PoseWithCurvature> splinePoints;
 
     // Add the first point to the vector.
-    splinePoints.push_back(splines.front().GetPoint(0.0).value());
+    splinePoints.push_back(splines.front().GetPoint(0.0). value());
 
     // Iterate through the vector and parameterize each spline, adding the
     // parameterized points to the final vector.
diff --git a/wpimath/src/main/native/include/frc/trajectory/TrajectoryParameterizer.h b/wpimath/src/main/native/include/frc/trajectory/TrajectoryParameterizer.h
index 807b31575c..5647382a9e 100644
--- a/wpimath/src/main/native/include/frc/trajectory/TrajectoryParameterizer.h
+++ b/wpimath/src/main/native/include/frc/trajectory/TrajectoryParameterizer.h
@@ -36,6 +36,7 @@
 
 #include "frc/trajectory/Trajectory.h"
 #include "frc/trajectory/constraint/TrajectoryConstraint.h"
+#include "units/curvature.h"
 
 namespace frc {
 /**
diff --git a/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h b/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h
index 617a3e22da..b2cfb98e53 100644
--- a/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h
+++ b/wpimath/src/main/native/include/frc/trajectory/TrapezoidProfile.h
@@ -4,6 +4,7 @@
 
 #pragma once
 
+#include <algorithm>
 #include <type_traits>
 
 #include "units/math.h"
@@ -219,8 +220,8 @@ class TrapezoidProfile {
       velocity *= -1.0;
     }
 
-    endAccel = units::math::max(endAccel, 0_s);
-    endFullSpeed = units::math::max(endFullSpeed, 0_s);
+    endAccel = std::max(endAccel, 0_s);
+    endFullSpeed = std::max(endFullSpeed, 0_s);
 
     const Acceleration_t acceleration = m_constraints.maxAcceleration;
     const Acceleration_t deceleration = -m_constraints.maxAcceleration;
diff --git a/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h b/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h
index be55464c88..d2ec15f12e 100644
--- a/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h
+++ b/wpimath/src/main/native/include/frc/trajectory/constraint/CentripetalAccelerationConstraint.h
@@ -40,7 +40,7 @@ class WPILIB_DLLEXPORT CentripetalAccelerationConstraint
     // ac/k = v²
     // v = √(ac/k)
 
-    // We have to multiply by 1_rad here to get the units to cancel out nicely.
+    // We have to multiply by rad here to get the units to cancel out nicely.
     // The units library defines a unit for radians although it is technically
     // unitless.
     return units::math::sqrt(m_maxCentripetalAcceleration /
diff --git a/wpimath/src/main/native/include/frc/trajectory/constraint/RectangularRegionConstraint.h b/wpimath/src/main/native/include/frc/trajectory/constraint/RectangularRegionConstraint.h
index 471951c5cc..9fc12530f3 100644
--- a/wpimath/src/main/native/include/frc/trajectory/constraint/RectangularRegionConstraint.h
+++ b/wpimath/src/main/native/include/frc/trajectory/constraint/RectangularRegionConstraint.h
@@ -10,6 +10,8 @@
 #include "frc/geometry/Rectangle2d.h"
 #include "frc/geometry/Translation2d.h"
 #include "frc/trajectory/constraint/TrajectoryConstraint.h"
+#include "units/curvature.h"
+#include "units/velocity.h"
 
 namespace frc {
 
diff --git a/wpimath/src/main/native/include/frc/trajectory/constraint/TrajectoryConstraint.h b/wpimath/src/main/native/include/frc/trajectory/constraint/TrajectoryConstraint.h
index 502fc9d429..7c741b6798 100644
--- a/wpimath/src/main/native/include/frc/trajectory/constraint/TrajectoryConstraint.h
+++ b/wpimath/src/main/native/include/frc/trajectory/constraint/TrajectoryConstraint.h
@@ -38,14 +38,14 @@ class WPILIB_DLLEXPORT TrajectoryConstraint {
     /**
      * The minimum acceleration.
      */
-    units::meters_per_second_squared_t minAcceleration{
-        -std::numeric_limits<double>::max()};
+    units::meters_per_second_squared_t minAcceleration =
+        units::meters_per_second_squared_t{-std::numeric_limits<double>::max()};
 
     /**
      * The maximum acceleration.
      */
-    units::meters_per_second_squared_t maxAcceleration{
-        std::numeric_limits<double>::max()};
+    units::meters_per_second_squared_t maxAcceleration =
+        units::meters_per_second_squared_t{std::numeric_limits<double>::max()};
   };
 
   /**
diff --git a/wpimath/src/test/native/cpp/ComputerVisionUtilTest.cpp b/wpimath/src/test/native/cpp/ComputerVisionUtilTest.cpp
index bbada9e322..09d71a1c8d 100644
--- a/wpimath/src/test/native/cpp/ComputerVisionUtilTest.cpp
+++ b/wpimath/src/test/native/cpp/ComputerVisionUtilTest.cpp
@@ -5,6 +5,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/ComputerVisionUtil.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 TEST(ComputerVisionUtilTest, ObjectToRobotPose) {
   frc::Pose3d robot{1_m, 2_m, 0_m, frc::Rotation3d{0_deg, 0_deg, 30_deg}};
diff --git a/wpimath/src/test/native/cpp/DARETest.cpp b/wpimath/src/test/native/cpp/DARETest.cpp
index d5d087f509..8ffae102f8 100644
--- a/wpimath/src/test/native/cpp/DARETest.cpp
+++ b/wpimath/src/test/native/cpp/DARETest.cpp
@@ -139,7 +139,7 @@ TEST(DARETest, NonInvertibleA_ABQR) {
 
   auto ret = frc::DARE<4, 1>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -164,7 +164,7 @@ TEST(DARETest, NonInvertibleA_ABQRN) {
 
   auto ret = frc::DARE<4, 1>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -179,7 +179,7 @@ TEST(DARETest, InvertibleA_ABQR) {
 
   auto ret = frc::DARE<2, 1>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -199,7 +199,7 @@ TEST(DARETest, InvertibleA_ABQRN) {
 
   auto ret = frc::DARE<2, 1>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -216,7 +216,7 @@ TEST(DARETest, FirstGeneralizedEigenvalueOfSTIsStable_ABQR) {
 
   auto ret = frc::DARE<2, 1>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -238,7 +238,7 @@ TEST(DARETest, FirstGeneralizedEigenvalueOfSTIsStable_ABQRN) {
 
   auto ret = frc::DARE<2, 1>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -253,7 +253,7 @@ TEST(DARETest, IdentitySystem_ABQR) {
 
   auto ret = frc::DARE<2, 2>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -269,7 +269,7 @@ TEST(DARETest, IdentitySystem_ABQRN) {
 
   auto ret = frc::DARE<2, 2>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -284,7 +284,7 @@ TEST(DARETest, MoreInputsThanStates_ABQR) {
 
   auto ret = frc::DARE<2, 3>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -300,7 +300,7 @@ TEST(DARETest, MoreInputsThanStates_ABQRN) {
 
   auto ret = frc::DARE<2, 3>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret. value();
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
diff --git a/wpimath/src/test/native/cpp/MathUtilTest.cpp b/wpimath/src/test/native/cpp/MathUtilTest.cpp
index 1479c0d18f..850f15b67a 100644
--- a/wpimath/src/test/native/cpp/MathUtilTest.cpp
+++ b/wpimath/src/test/native/cpp/MathUtilTest.cpp
@@ -162,11 +162,11 @@ TEST(MathUtilTest, InputModulus) {
 
 TEST(MathUtilTest, AngleModulus) {
   EXPECT_UNITS_NEAR(
-      frc::AngleModulus(units::radian_t{-2000 * std::numbers::pi / 180}),
-      units::radian_t{160 * std::numbers::pi / 180}, 1e-10);
+      frc::AngleModulus(units::radian_t{-2000.0 * std::numbers::pi / 180}),
+      units::radian_t{160.0 * std::numbers::pi / 180}, 1e-10);
   EXPECT_UNITS_NEAR(
-      frc::AngleModulus(units::radian_t{358 * std::numbers::pi / 180}),
-      units::radian_t{-2 * std::numbers::pi / 180}, 1e-10);
+      frc::AngleModulus(units::radian_t{358.0 * std::numbers::pi / 180}),
+      units::radian_t{-2.0 * std::numbers::pi / 180}, 1e-10);
   EXPECT_UNITS_NEAR(frc::AngleModulus(units::radian_t{2.0 * std::numbers::pi}),
                     0_rad, 1e-10);
 
@@ -246,8 +246,8 @@ TEST(MathUtilTest, Translation2dSlewRateLimitChanged) {
       frc::SlewRateLimit(translation3, translation4, 0.25_s, 2_mps);
 
   const frc::Translation2d expected2{
-      units::meter_t{1.0 + 0.5 * (std::numbers::sqrt2 / 2)},
-      units::meter_t{1.0 + 0.5 * (std::numbers::sqrt2 / 2)}};
+      units::meter_t{1.0 + 0.5 * (std::numbers::sqrt2 / 2.0)},
+      units::meter_t{1.0 + 0.5 * (std::numbers::sqrt2 / 2.0)}};
 
   EXPECT_EQ(result2, expected2);
 }
diff --git a/wpimath/src/test/native/cpp/SleipnirTest.cpp b/wpimath/src/test/native/cpp/SleipnirTest.cpp
index c0eb25d90e..1a48a8731e 100644
--- a/wpimath/src/test/native/cpp/SleipnirTest.cpp
+++ b/wpimath/src/test/native/cpp/SleipnirTest.cpp
@@ -23,5 +23,5 @@ TEST(SleipnirTest, Quartic) {
 
   EXPECT_EQ(status, slp::ExitStatus::SUCCESS);
 
-  EXPECT_NEAR(x.value(), 1.0, 1e-6);
+  EXPECT_NEAR(x. value(), 1.0, 1e-6);
 }
diff --git a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
index 452e017ecc..0819e6f5ae 100644
--- a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
@@ -31,13 +31,13 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
   {
     Vectord<2> accels =
         plant.A() * xAccelLimiter + plant.B() * Vectord<2>{12.0, 12.0};
-    units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+    units::meters_per_second_squared_t a = units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GT(units::math::abs(a), maxA);
   }
   {
     Vectord<2> accels =
         plant.A() * xAccelLimiter + plant.B() * Vectord<2>{-12.0, 12.0};
-    units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
+    units::radians_per_second_squared_t alpha = units::radians_per_second_squared_t{(accels(1) - accels(0)) /
                                               trackwidth.value()};
     EXPECT_GT(units::math::abs(alpha), maxAlpha);
   }
@@ -51,12 +51,12 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
-    units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
+        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left.value(), right.value()};
+    units::meters_per_second_squared_t a = units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
+    units::radians_per_second_squared_t alpha = units::radians_per_second_squared_t{(accels(1) - accels(0)) /
                                               trackwidth.value()};
     EXPECT_LE(units::math::abs(a), maxA);
     EXPECT_LE(units::math::abs(alpha), maxAlpha);
@@ -71,12 +71,12 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
-    units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
+        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left.value(), right.value()};
+    units::meters_per_second_squared_t a = units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
+    units::radians_per_second_squared_t alpha = units::radians_per_second_squared_t{(accels(1) - accels(0)) /
                                               trackwidth.value()};
     EXPECT_LE(units::math::abs(a), maxA);
     EXPECT_LE(units::math::abs(alpha), maxAlpha);
@@ -91,12 +91,12 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
-    units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
+        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left.value(), right.value()};
+    units::meters_per_second_squared_t a = units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
+    units::radians_per_second_squared_t alpha = units::radians_per_second_squared_t{(accels(1) - accels(0)) /
                                               trackwidth.value()};
     EXPECT_LE(units::math::abs(a), maxA);
     EXPECT_LE(units::math::abs(alpha), maxAlpha);
@@ -130,7 +130,7 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     EXPECT_DOUBLE_EQ(x(0), xAccelLimiter(0));
     EXPECT_DOUBLE_EQ(x(1), xAccelLimiter(1));
@@ -147,7 +147,7 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     EXPECT_DOUBLE_EQ(x(0), xAccelLimiter(0));
     EXPECT_DOUBLE_EQ(x(1), xAccelLimiter(1));
@@ -164,7 +164,7 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     EXPECT_DOUBLE_EQ(x(0), xAccelLimiter(0));
     EXPECT_DOUBLE_EQ(x(1), xAccelLimiter(1));
@@ -193,7 +193,7 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
   {
     Vectord<2> accels =
         plant.A() * xAccelLimiter + plant.B() * Vectord<2>{12.0, 12.0};
-    units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+    units::meters_per_second_squared_t a = units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GT(units::math::abs(a), maxA);
     EXPECT_GT(units::math::abs(a), -minA);
   }
@@ -208,11 +208,11 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left.value(), right.value()};
+    units::meters_per_second_squared_t a = units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GE(a, minA);
     EXPECT_LE(a, maxA);
   }
@@ -226,11 +226,11 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
                                units::meters_per_second_t{xAccelLimiter(1)},
                                units::volt_t{u(0)}, units::volt_t{u(1)});
     xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+        plant.CalculateX(xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left.value(), right.value()};
+    units::meters_per_second_squared_t a = units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GE(a, minA);
     EXPECT_LE(a, maxA);
   }
diff --git a/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp b/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp
index 5428d843ca..83dcb9e09a 100644
--- a/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp
@@ -39,8 +39,8 @@ TEST(DifferentialDriveFeedforwardTest, CalculateWithTrackwidth) {
               currentLeftVelocity, nextLeftVelocity, currentRightVelocity,
               nextRightVelocity, dt);
           Eigen::Vector2d nextX = plant.CalculateX(
-              Eigen::Vector2d{currentLeftVelocity, currentRightVelocity},
-              Eigen::Vector2d{left, right}, dt);
+              Eigen::Vector2d{currentLeftVelocity.value(), currentRightVelocity.value()},
+              Eigen::Vector2d{left.value(), right.value()}, dt);
           EXPECT_NEAR(nextX(0), nextLeftVelocity.value(), 1e-6);
           EXPECT_NEAR(nextX(1), nextRightVelocity.value(), 1e-6);
         }
@@ -73,8 +73,8 @@ TEST(DifferentialDriveFeedforwardTest, CalculateWithoutTrackwidth) {
               currentLeftVelocity, nextLeftVelocity, currentRightVelocity,
               nextRightVelocity, dt);
           Eigen::Vector2d nextX = plant.CalculateX(
-              Eigen::Vector2d{currentLeftVelocity, currentRightVelocity},
-              Eigen::Vector2d{left, right}, dt);
+              Eigen::Vector2d{currentLeftVelocity.value(), currentRightVelocity.value()},
+              Eigen::Vector2d{left.value(), right.value()}, dt);
           EXPECT_NEAR(nextX(0), nextLeftVelocity.value(), 1e-6);
           EXPECT_NEAR(nextX(1), nextRightVelocity.value(), 1e-6);
         }
diff --git a/wpimath/src/test/native/cpp/controller/ElevatorFeedforwardTest.cpp b/wpimath/src/test/native/cpp/controller/ElevatorFeedforwardTest.cpp
index e4048c0d0b..5545d5e4d8 100644
--- a/wpimath/src/test/native/cpp/controller/ElevatorFeedforwardTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/ElevatorFeedforwardTest.cpp
@@ -14,8 +14,8 @@
 #include "units/time.h"
 
 static constexpr auto Ks = 0.5_V;
-static constexpr auto Kv = 1.5_V * 1_s / 1_m;
-static constexpr auto Ka = 2_V * 1_s * 1_s / 1_m;
+static constexpr auto Kv = 1.5_V / 1_mps;
+static constexpr auto Ka = 2_V / 1_mps_sq;
 static constexpr auto Kg = 1_V;
 
 TEST(ElevatorFeedforwardTest, Calculate) {
@@ -37,9 +37,9 @@ TEST(ElevatorFeedforwardTest, Calculate) {
 
 TEST(ElevatorFeedforwardTest, AchievableVelocity) {
   frc::ElevatorFeedforward elevatorFF{Ks, Kg, Kv, Ka};
-  EXPECT_NEAR(elevatorFF.MaxAchievableVelocity(11_V, 1_m / 1_s / 1_s).value(),
+  EXPECT_NEAR(elevatorFF.MaxAchievableVelocity(11_V, 1_mps_sq).value(),
               5, 0.002);
-  EXPECT_NEAR(elevatorFF.MinAchievableVelocity(11_V, 1_m / 1_s / 1_s).value(),
+  EXPECT_NEAR(elevatorFF.MinAchievableVelocity(11_V, 1_mps_sq).value(),
               -9, 0.002);
 }
 
diff --git a/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp b/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
index afa491a7b1..f53d919677 100644
--- a/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/ImplicitModelFollowerTest.cpp
@@ -6,6 +6,10 @@
 
 #include "frc/controller/ImplicitModelFollower.h"
 #include "frc/system/plant/LinearSystemId.h"
+#include "units/acceleration.h"
+#include "units/time.h"
+#include "units/velocity.h"
+#include "units/voltage.h"
 
 namespace frc {
 
diff --git a/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp b/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp
index f602c70244..4380dcd44c 100644
--- a/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp
@@ -16,9 +16,8 @@
 #define EXPECT_NEAR_UNITS(val1, val2, eps) \
   EXPECT_LE(units::math::abs(val1 - val2), eps)
 
-static constexpr units::meter_t kTolerance{1 / 12.0};
-static constexpr units::radian_t kAngularTolerance{2.0 * std::numbers::pi /
-                                                   180.0};
+static constexpr units::meter_t kTolerance = units::meter_t{1.0 / 12.0};
+static constexpr units::radian_t kAngularTolerance = 2_deg;
 
 /**
  * States of the drivetrain system.
diff --git a/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp b/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp
index bb7914dc51..3810dd6288 100644
--- a/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp
@@ -12,9 +12,8 @@
 #define EXPECT_NEAR_UNITS(val1, val2, eps) \
   EXPECT_LE(units::math::abs(val1 - val2), eps)
 
-static constexpr units::meter_t kTolerance{1 / 12.0};
-static constexpr units::radian_t kAngularTolerance{2.0 * std::numbers::pi /
-                                                   180.0};
+static constexpr units::meter_t kTolerance = units::meter_t{1.0 / 12.0};
+static constexpr units::radian_t kAngularTolerance = 2_deg;
 
 TEST(LTVUnicycleControllerTest, ReachesReference) {
   constexpr units::second_t kDt = 20_ms;
diff --git a/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp b/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp
index 2f36c75209..728d7eb1e0 100644
--- a/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp
@@ -5,6 +5,7 @@
 #include <gtest/gtest.h>
 
 #include "frc/controller/PIDController.h"
+#include "units/time.h"
 
 TEST(PIDInputOutputTest, ContinuousInput) {
   frc::PIDController controller{0.0, 0.0, 0.0};
@@ -46,7 +47,7 @@ TEST(PIDInputOutputTest, DerivativeGainOutput) {
 
   controller.Calculate(0, 0);
 
-  EXPECT_DOUBLE_EQ(-10_ms / controller.GetPeriod(),
+  EXPECT_DOUBLE_EQ(double{units::second_t{-10_ms} / controller.GetPeriod()},
                    controller.Calculate(0.0025, 0));
 }
 
diff --git a/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp b/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp
index 2fb46fae2f..67d3401663 100644
--- a/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp
@@ -18,9 +18,9 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput1) {
   controller.SetP(1);
   controller.EnableContinuousInput(-180_deg, 180_deg);
 
-  static constexpr units::degree_t kSetpoint{-179.0};
-  static constexpr units::degree_t kMeasurement{-179.0};
-  static constexpr units::degree_t kGoal{179.0};
+  static constexpr units::degree_t kSetpoint = units::degree_t{-179.0};
+  static constexpr units::degree_t kMeasurement = units::degree_t{-179.0};
+  static constexpr units::degree_t kGoal = units::degree_t{179.0};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -38,9 +38,9 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput2) {
   controller.EnableContinuousInput(-units::radian_t{std::numbers::pi},
                                    units::radian_t{std::numbers::pi});
 
-  static constexpr units::radian_t kSetpoint{-3.4826633343199735};
-  static constexpr units::radian_t kMeasurement{-3.1352207333939606};
-  static constexpr units::radian_t kGoal{-3.534162788601621};
+  static constexpr units::radian_t kSetpoint = units::radian_t{-3.4826633343199735};
+  static constexpr units::radian_t kMeasurement = units::radian_t{-3.1352207333939606};
+  static constexpr units::radian_t kGoal = units::radian_t{-3.534162788601621};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -58,9 +58,9 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput3) {
   controller.EnableContinuousInput(-units::radian_t{std::numbers::pi},
                                    units::radian_t{std::numbers::pi});
 
-  static constexpr units::radian_t kSetpoint{-3.5176604690006377};
-  static constexpr units::radian_t kMeasurement{3.1191729343822456};
-  static constexpr units::radian_t kGoal{2.709680418117445};
+  static constexpr units::radian_t kSetpoint = units::radian_t{-3.5176604690006377};
+  static constexpr units::radian_t kMeasurement = units::radian_t{3.1191729343822456};
+  static constexpr units::radian_t kGoal = units::radian_t{2.709680418117445};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -78,9 +78,9 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput4) {
   controller.EnableContinuousInput(0_rad,
                                    units::radian_t{2.0 * std::numbers::pi});
 
-  static constexpr units::radian_t kSetpoint{2.78};
-  static constexpr units::radian_t kMeasurement{3.12};
-  static constexpr units::radian_t kGoal{2.71};
+  static constexpr units::radian_t kSetpoint = units::radian_t{2.78};
+  static constexpr units::radian_t kMeasurement = units::radian_t{3.12};
+  static constexpr units::radian_t kGoal = units::radian_t{2.71};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -122,6 +122,6 @@ TEST(ProfiledPIDInputOutputTest, DerivativeGainOutput) {
 
   controller.Calculate(0_deg, 0_deg);
 
-  EXPECT_DOUBLE_EQ(-10_ms / controller.GetPeriod(),
+  EXPECT_DOUBLE_EQ(double{units::second_t{-10_ms} / controller.GetPeriod()},
                    controller.Calculate(0.0025_deg, 0_deg));
 }
diff --git a/wpimath/src/test/native/cpp/controller/proto/ArmFeedforwardProtoTest.cpp b/wpimath/src/test/native/cpp/controller/proto/ArmFeedforwardProtoTest.cpp
index ef4f612d8c..84f8be8435 100644
--- a/wpimath/src/test/native/cpp/controller/proto/ArmFeedforwardProtoTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/proto/ArmFeedforwardProtoTest.cpp
@@ -13,8 +13,8 @@ namespace {
 
 static constexpr auto Ks = 1.91_V;
 static constexpr auto Kg = 2.29_V;
-static constexpr auto Kv = 35.04_V * 1_s / 1_rad;
-static constexpr auto Ka = 1.74_V * 1_s * 1_s / 1_rad;
+static constexpr auto Kv = 35.04_V / 1_rad_per_s;
+static constexpr auto Ka = 1.74_V / 1_rad_per_s_sq;
 const ArmFeedforward kExpectedData{Ks, Kg, Kv, Ka};
 }  // namespace
 
diff --git a/wpimath/src/test/native/cpp/controller/proto/ElevatorFeedforwardProtoTest.cpp b/wpimath/src/test/native/cpp/controller/proto/ElevatorFeedforwardProtoTest.cpp
index be0cc42518..6dca38d560 100644
--- a/wpimath/src/test/native/cpp/controller/proto/ElevatorFeedforwardProtoTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/proto/ElevatorFeedforwardProtoTest.cpp
@@ -13,8 +13,8 @@ namespace {
 
 static constexpr auto Ks = 1.91_V;
 static constexpr auto Kg = 2.29_V;
-static constexpr auto Kv = 35.04_V * 1_s / 1_m;
-static constexpr auto Ka = 1.74_V * 1_s * 1_s / 1_m;
+static constexpr auto Kv = 35.04_V / 1_mps;
+static constexpr auto Ka = 1.74_V / 1_mps_sq;
 
 constexpr ElevatorFeedforward kExpectedData{Ks, Kg, Kv, Ka};
 }  // namespace
diff --git a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
index ff3ee3a75a..d5f61161b9 100644
--- a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
@@ -7,18 +7,18 @@
 #include "../../ProtoTestBase.h"
 #include "frc/controller/SimpleMotorFeedforward.h"
 #include "frc/controller/proto/SimpleMotorFeedforwardProto.h"
-#include "units/acceleration.h"
-#include "units/velocity.h"
+#include "units/base.h"
 
 using namespace frc;
 
-template <typename T>
+template <typename Distance>
+  requires (units::traits::is_unit_v<Distance>)
 struct SimpleMotorFeedforwardProtoTestData {
-  using Type = SimpleMotorFeedforward<T>;
+  using Type = SimpleMotorFeedforward<Distance>;
 
   inline static const Type kTestData = {
-      units::volt_t{0.4}, units::volt_t{4.0} / (units::unit_t<T>{1} / 1_s),
-      units::volt_t{0.7} / (units::unit_t<T>{1} / 1_s / 1_s), 25_ms};
+      units::volt_t{0.4}, units::volt_t{4.0} / (units::unit_t<Distance>{1} / 1_s),
+      units::volt_t{0.7} / (units::unit_t<Distance>{1} / 1_s / 1_s), 25_ms};
 
   static void CheckEq(const Type& testData, const Type& data) {
     EXPECT_EQ(testData.GetKs().value(), data.GetKs().value());
@@ -33,7 +33,7 @@ INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardProtoTestData<units::meters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardFeet, ProtoTest,
-    SimpleMotorFeedforwardProtoTestData<units::feet>);
+    SimpleMotorFeedforwardProtoTestData<units::centimeters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardRadians, ProtoTest,
     SimpleMotorFeedforwardProtoTestData<units::radians>);
diff --git a/wpimath/src/test/native/cpp/controller/struct/ArmFeedforwardStructTest.cpp b/wpimath/src/test/native/cpp/controller/struct/ArmFeedforwardStructTest.cpp
index ee1c8d2435..9169503660 100644
--- a/wpimath/src/test/native/cpp/controller/struct/ArmFeedforwardStructTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/struct/ArmFeedforwardStructTest.cpp
@@ -14,8 +14,8 @@ using StructType = wpi::Struct<frc::ArmFeedforward>;
 
 static constexpr auto Ks = 1.91_V;
 static constexpr auto Kg = 2.29_V;
-static constexpr auto Kv = 35.04_V * 1_s / 1_rad;
-static constexpr auto Ka = 1.74_V * 1_s * 1_s / 1_rad;
+static constexpr auto Kv = 35.04_V / 1_rad_per_s;
+static constexpr auto Ka = 1.74_V / 1_rad_per_s_sq;
 const ArmFeedforward kExpectedData{Ks, Kg, Kv, Ka};
 }  // namespace
 
diff --git a/wpimath/src/test/native/cpp/controller/struct/ElevatorFeedforwardStructTest.cpp b/wpimath/src/test/native/cpp/controller/struct/ElevatorFeedforwardStructTest.cpp
index e554891ba2..a23808e1ab 100644
--- a/wpimath/src/test/native/cpp/controller/struct/ElevatorFeedforwardStructTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/struct/ElevatorFeedforwardStructTest.cpp
@@ -14,8 +14,8 @@ using StructType = wpi::Struct<frc::ElevatorFeedforward>;
 
 static constexpr auto Ks = 1.91_V;
 static constexpr auto Kg = 2.29_V;
-static constexpr auto Kv = 35.04_V * 1_s / 1_m;
-static constexpr auto Ka = 1.74_V * 1_s * 1_s / 1_m;
+static constexpr auto Kv = 35.04_V / 1_mps;
+static constexpr auto Ka = 1.74_V / 1_mps_sq;
 
 constexpr ElevatorFeedforward kExpectedData{Ks, Kg, Kv, Ka};
 }  // namespace
diff --git a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
index cb8aec9e97..272e048b16 100644
--- a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
@@ -7,18 +7,18 @@
 #include "../../StructTestBase.h"
 #include "frc/controller/SimpleMotorFeedforward.h"
 #include "frc/controller/struct/SimpleMotorFeedforwardStruct.h"
-#include "units/acceleration.h"
-#include "units/velocity.h"
+#include "units/base.h"
 
 using namespace frc;
 
-template <typename T>
+template <typename Distance>
+  requires (units::traits::is_unit_v<Distance>)
 struct SimpleMotorFeedforwardStructTestData {
-  using Type = SimpleMotorFeedforward<T>;
+  using Type = SimpleMotorFeedforward<Distance>;
 
   inline static const Type kTestData = {
-      units::volt_t{0.4}, units::volt_t{4.0} / (units::unit_t<T>{1} / 1_s),
-      units::volt_t{0.7} / (units::unit_t<T>{1} / 1_s / 1_s), 25_ms};
+      units::volt_t{0.4}, units::volt_t{4.0} / (units::unit_t<Distance>{1} / 1_s),
+      units::volt_t{0.7} / (units::unit_t<Distance>{1} / 1_s / 1_s), 25_ms};
 
   static void CheckEq(const Type& testData, const Type& data) {
     EXPECT_EQ(testData.GetKs().value(), data.GetKs().value());
@@ -33,7 +33,7 @@ INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardStructTestData<units::meters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardFeet, StructTest,
-    SimpleMotorFeedforwardStructTestData<units::feet>);
+    SimpleMotorFeedforwardStructTestData<units::centimeters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardRadians, StructTest,
     SimpleMotorFeedforwardStructTestData<units::radians>);
diff --git a/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp b/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp
index 362de8b699..d375a7c3b4 100644
--- a/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp
@@ -34,10 +34,10 @@ frc::Vectord<5> Dynamics(const frc::Vectord<5>& x, const frc::Vectord<2>& u) {
   auto k1 = (1 / m + units::math::pow<2>(rb) / J);
   auto k2 = (1 / m - units::math::pow<2>(rb) / J);
 
-  units::meters_per_second_t vl{x(3)};
-  units::meters_per_second_t vr{x(4)};
-  units::volt_t Vl{u(0)};
-  units::volt_t Vr{u(1)};
+  units::meters_per_second_t vl = units::meters_per_second_t{x(3)};
+  units::meters_per_second_t vr = units::meters_per_second_t{x(4)};
+  units::volt_t Vl = units::volt_t{u(0)};
+  units::volt_t Vr = units::volt_t{u(1)};
 
   auto v = 0.5 * (vl + vr);
   return frc::Vectord<5>{
diff --git a/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimator3dTest.cpp b/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimator3dTest.cpp
index 7ba98c9f99..3bbb86dc6f 100644
--- a/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimator3dTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimator3dTest.cpp
@@ -14,6 +14,11 @@
 #include "frc/geometry/Pose2d.h"
 #include "frc/kinematics/MecanumDriveKinematics.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 void testFollowTrajectory(
     const frc::MecanumDriveKinematics& kinematics,
diff --git a/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimatorTest.cpp b/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimatorTest.cpp
index bd3ce4f6ca..4042d22685 100644
--- a/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimatorTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/MecanumDrivePoseEstimatorTest.cpp
@@ -15,6 +15,11 @@
 #include "frc/geometry/Pose2d.h"
 #include "frc/kinematics/MecanumDriveKinematics.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 void testFollowTrajectory(
     const frc::MecanumDriveKinematics& kinematics,
diff --git a/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp b/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
index 0c3aa23e7c..5dd17da3a1 100644
--- a/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
@@ -42,10 +42,10 @@ frc::Vectord<5> DriveDynamics(const frc::Vectord<5>& x,
   auto k1 = (1 / m + units::math::pow<2>(rb) / J);
   auto k2 = (1 / m - units::math::pow<2>(rb) / J);
 
-  units::meters_per_second_t vl{x(3)};
-  units::meters_per_second_t vr{x(4)};
-  units::volt_t Vl{u(0)};
-  units::volt_t Vr{u(1)};
+  units::meters_per_second_t vl = units::meters_per_second_t{x(3)};
+  units::meters_per_second_t vr = units::meters_per_second_t{x(4)};
+  units::volt_t Vl = units::volt_t{u(0)};
+  units::volt_t Vr = units::volt_t{u(1)};
 
   auto v = 0.5 * (vl + vr);
   return frc::Vectord<5>{
@@ -128,7 +128,7 @@ TEST(MerweUKFTest, DriveConvergence) {
   auto trueXhat = observer.Xhat();
 
   auto totalTime = trajectory.TotalTime();
-  for (size_t i = 0; i < (totalTime / dt).value(); ++i) {
+  for (size_t i = 0; i < double{totalTime / dt}; ++i) {
     auto ref = trajectory.Sample(dt * i);
     units::meters_per_second_t vl =
         ref.velocity * (1 - (ref.curvature * rb).value());
diff --git a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
index fb38c0f3d5..36aaf187d1 100644
--- a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
@@ -42,10 +42,10 @@ frc::Vectord<5> DriveDynamics(const frc::Vectord<5>& x,
   auto k1 = (1 / m + units::math::pow<2>(rb) / J);
   auto k2 = (1 / m - units::math::pow<2>(rb) / J);
 
-  units::meters_per_second_t vl{x(3)};
-  units::meters_per_second_t vr{x(4)};
-  units::volt_t Vl{u(0)};
-  units::volt_t Vr{u(1)};
+  units::meters_per_second_t vl = units::meters_per_second_t{x(3)};
+  units::meters_per_second_t vr = units::meters_per_second_t{x(4)};
+  units::volt_t Vl = units::volt_t{u(0)};
+  units::volt_t Vr = units::volt_t{u(1)};
 
   auto v = 0.5 * (vl + vr);
   return frc::Vectord<5>{
@@ -128,7 +128,7 @@ TEST(S3UKFTest, DriveConvergence) {
   auto trueXhat = observer.Xhat();
 
   auto totalTime = trajectory.TotalTime();
-  for (size_t i = 0; i < (totalTime / dt).value(); ++i) {
+  for (size_t i = 0; i < double{totalTime / dt}; ++i) {
     auto ref = trajectory.Sample(dt * i);
     units::meters_per_second_t vl =
         ref.velocity * (1 - (ref.curvature * rb).value());
diff --git a/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimator3dTest.cpp b/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimator3dTest.cpp
index 612862f4f1..66a448cd7e 100644
--- a/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimator3dTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimator3dTest.cpp
@@ -16,6 +16,11 @@
 #include "frc/geometry/Pose2d.h"
 #include "frc/kinematics/SwerveDriveKinematics.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 void testFollowTrajectory(
     const frc::SwerveDriveKinematics<4>& kinematics,
diff --git a/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimatorTest.cpp b/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimatorTest.cpp
index 1655074209..6b5c25f72a 100644
--- a/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimatorTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/SwerveDrivePoseEstimatorTest.cpp
@@ -17,6 +17,11 @@
 #include "frc/geometry/Pose2d.h"
 #include "frc/kinematics/SwerveDriveKinematics.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 void testFollowTrajectory(
     const frc::SwerveDriveKinematics<4>& kinematics,
diff --git a/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp b/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp
index 8b0e56cd96..e506f3c979 100644
--- a/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp
+++ b/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp
@@ -13,7 +13,7 @@ static units::second_t now = 0_s;
 class DebouncerTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    WPI_SetNowImpl([] { return units::microsecond_t{now}.to<uint64_t>(); });
+    WPI_SetNowImpl([] { return static_cast<uint64_t>(units::microsecond_t{now}.value()); });
   }
 
   void TearDown() override { WPI_SetNowImpl(nullptr); }
diff --git a/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp b/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp
index aabd6ad0c3..8d4d55ef33 100644
--- a/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp
+++ b/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp
@@ -15,14 +15,14 @@ static units::second_t now = 0_s;
 class SlewRateLimiterTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    WPI_SetNowImpl([] { return units::microsecond_t{now}.to<uint64_t>(); });
+    WPI_SetNowImpl([] { return static_cast<uint64_t>(units::microsecond_t{now}.value()); });
   }
 
   void TearDown() override { WPI_SetNowImpl(nullptr); }
 };
 
 TEST_F(SlewRateLimiterTest, SlewRateLimit) {
-  WPI_SetNowImpl([] { return units::microsecond_t{now}.to<uint64_t>(); });
+  WPI_SetNowImpl([] { return static_cast<uint64_t>(units::microsecond_t{now}.value()); });
 
   frc::SlewRateLimiter<units::meters> limiter(1_mps);
 
diff --git a/wpimath/src/test/native/cpp/geometry/CoordinateSystemTest.cpp b/wpimath/src/test/native/cpp/geometry/CoordinateSystemTest.cpp
index 198f90f7a6..90c45c2397 100644
--- a/wpimath/src/test/native/cpp/geometry/CoordinateSystemTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/CoordinateSystemTest.cpp
@@ -7,6 +7,8 @@
 #include "frc/geometry/CoordinateSystem.h"
 #include "frc/geometry/Pose3d.h"
 #include "frc/geometry/Transform3d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Ellipse2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Ellipse2dTest.cpp
index 1ee79e7ac6..e1a3280acf 100644
--- a/wpimath/src/test/native/cpp/geometry/Ellipse2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Ellipse2dTest.cpp
@@ -5,6 +5,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Ellipse2d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 TEST(Ellipse2dTest, FocalPoints) {
   constexpr frc::Pose2d center{1_m, 2_m, 0_deg};
diff --git a/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp
index eb5c3bef99..9649cd5d09 100644
--- a/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Pose2dTest.cpp
@@ -8,6 +8,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Pose2d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp b/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp
index 045870c792..a1184d748c 100644
--- a/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Pose3dTest.cpp
@@ -8,6 +8,9 @@
 #include <wpi/array.h>
 
 #include "frc/geometry/Pose3d.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/math.h"
 
 using namespace frc;
 
@@ -21,8 +24,8 @@ TEST(Pose3dTest, RotateBy) {
   const auto rotated = initial.RotateBy(rotation);
 
   // Translation is rotated by CCW rotation matrix
-  double c = std::cos(yaw.value());
-  double s = std::sin(yaw.value());
+  double c = units::math::cos(yaw);
+  double s = units::math::sin(yaw);
   EXPECT_DOUBLE_EQ(c * x.value() - s * y.value(), rotated.X().value());
   EXPECT_DOUBLE_EQ(s * x.value() + c * y.value(), rotated.Y().value());
   EXPECT_DOUBLE_EQ(0.0, rotated.Z().value());
diff --git a/wpimath/src/test/native/cpp/geometry/Rectangle2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Rectangle2dTest.cpp
index 90ac72f51a..a1a7af65cd 100644
--- a/wpimath/src/test/native/cpp/geometry/Rectangle2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Rectangle2dTest.cpp
@@ -5,6 +5,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Rectangle2d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 TEST(Rectangle2dTest, NewWithCorners) {
   constexpr frc::Translation2d cornerA{1_m, 2_m};
diff --git a/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
index d9d1502471..f25ad94b57 100644
--- a/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Rotation2dTest.cpp
@@ -8,6 +8,7 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Rotation2d.h"
+#include "units/angle.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Rotation3dTest.cpp b/wpimath/src/test/native/cpp/geometry/Rotation3dTest.cpp
index 903d4144bc..e61fa64eda 100644
--- a/wpimath/src/test/native/cpp/geometry/Rotation3dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Rotation3dTest.cpp
@@ -10,6 +10,7 @@
 #include <wpi/MathExtras.h>
 
 #include "frc/geometry/Rotation3d.h"
+#include "units/angle.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Transform2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Transform2dTest.cpp
index 5a562405cc..c70080812f 100644
--- a/wpimath/src/test/native/cpp/geometry/Transform2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Transform2dTest.cpp
@@ -10,6 +10,8 @@
 #include "frc/geometry/Rotation2d.h"
 #include "frc/geometry/Transform2d.h"
 #include "frc/geometry/Translation2d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Transform3dTest.cpp b/wpimath/src/test/native/cpp/geometry/Transform3dTest.cpp
index 9aa7eda331..b980f27646 100644
--- a/wpimath/src/test/native/cpp/geometry/Transform3dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Transform3dTest.cpp
@@ -10,6 +10,8 @@
 #include "frc/geometry/Rotation3d.h"
 #include "frc/geometry/Transform3d.h"
 #include "frc/geometry/Translation3d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp
index e44e334aec..eb9b307b84 100644
--- a/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Translation2dTest.cpp
@@ -7,6 +7,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Translation2d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Translation3dTest.cpp b/wpimath/src/test/native/cpp/geometry/Translation3dTest.cpp
index cdc7a6ebb7..1a88f96a47 100644
--- a/wpimath/src/test/native/cpp/geometry/Translation3dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Translation3dTest.cpp
@@ -7,6 +7,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Translation3d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Twist2dTest.cpp b/wpimath/src/test/native/cpp/geometry/Twist2dTest.cpp
index d4a03b7a8e..c834f3ba76 100644
--- a/wpimath/src/test/native/cpp/geometry/Twist2dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Twist2dTest.cpp
@@ -8,6 +8,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Pose2d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
diff --git a/wpimath/src/test/native/cpp/geometry/Twist3dTest.cpp b/wpimath/src/test/native/cpp/geometry/Twist3dTest.cpp
index ddf429a8fe..c198aacf74 100644
--- a/wpimath/src/test/native/cpp/geometry/Twist3dTest.cpp
+++ b/wpimath/src/test/native/cpp/geometry/Twist3dTest.cpp
@@ -8,6 +8,8 @@
 #include <gtest/gtest.h>
 
 #include "frc/geometry/Pose3d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 using namespace frc;
 
@@ -39,7 +41,7 @@ TEST(Twist3dTest, QuarterCircle) {
   Eigen::Vector3d zAxis{0.0, 0.0, 1.0};
 
   const Twist3d quarterCircle{
-      5_m / 2.0 * std::numbers::pi,           0_m, 0_m, 0_rad, 0_rad,
+      units::meter_t{5.0 / 2.0 * std::numbers::pi},           0_m, 0_m, 0_rad, 0_rad,
       units::radian_t{std::numbers::pi / 2.0}};
   const auto quarterCirclePose = quarterCircle.Exp();
 
diff --git a/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp b/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp
index b41ba3bef1..f57f4a1511 100644
--- a/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp
+++ b/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp
@@ -16,31 +16,31 @@ TEST(TimeInterpolatableBufferTest, AddSample) {
 
   // No entries
   buffer.AddSample(1_s, 0_rad);
-  EXPECT_TRUE(buffer.Sample(1_s).value() == 0_rad);
+  EXPECT_TRUE(buffer.Sample(1_s). value() == 0_rad);
 
   // New entry at start of container
   buffer.AddSample(0_s, 1_rad);
-  EXPECT_TRUE(buffer.Sample(0_s).value() == 1_rad);
+  EXPECT_TRUE(buffer.Sample(0_s). value() == 1_rad);
 
   // New entry in middle of container
   buffer.AddSample(0.5_s, 0.5_rad);
-  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 0.5_rad);
+  EXPECT_TRUE(buffer.Sample(0.5_s). value() == 0.5_rad);
 
   // Override sample
   buffer.AddSample(0.5_s, 1_rad);
-  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 1_rad);
+  EXPECT_TRUE(buffer.Sample(0.5_s). value() == 1_rad);
 }
 
 TEST(TimeInterpolatableBufferTest, Interpolation) {
   frc::TimeInterpolatableBuffer<frc::Rotation2d> buffer{10_s};
 
   buffer.AddSample(0_s, 0_rad);
-  EXPECT_TRUE(buffer.Sample(0_s).value() == 0_rad);
+  EXPECT_TRUE(buffer.Sample(0_s). value() == 0_rad);
   buffer.AddSample(1_s, 1_rad);
-  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 0.5_rad);
-  EXPECT_TRUE(buffer.Sample(1_s).value() == 1_rad);
+  EXPECT_TRUE(buffer.Sample(0.5_s). value() == 0.5_rad);
+  EXPECT_TRUE(buffer.Sample(1_s). value() == 1_rad);
   buffer.AddSample(3_s, 2_rad);
-  EXPECT_TRUE(buffer.Sample(2_s).value() == 1.5_rad);
+  EXPECT_TRUE(buffer.Sample(2_s). value() == 1.5_rad);
 
   buffer.AddSample(10.5_s, 2_rad);
   EXPECT_TRUE(buffer.Sample(0_s) == 1_rad);
@@ -52,7 +52,7 @@ TEST(TimeInterpolatableBufferTest, Pose2d) {
   // We expect to be at (1 - 1/std::sqrt(2), 1/std::sqrt(2), 45deg) at t=0.5
   buffer.AddSample(0_s, frc::Pose2d{0_m, 0_m, 90_deg});
   buffer.AddSample(1_s, frc::Pose2d{1_m, 1_m, 0_deg});
-  frc::Pose2d sample = buffer.Sample(0.5_s).value();
+  frc::Pose2d sample = buffer.Sample(0.5_s). value();
 
   EXPECT_TRUE(std::abs(sample.X().value() - (1.0 - 1.0 / std::sqrt(2.0))) <
               0.01);
diff --git a/wpimath/src/test/native/cpp/kinematics/ChassisSpeedsTest.cpp b/wpimath/src/test/native/cpp/kinematics/ChassisSpeedsTest.cpp
index 60c76aca54..47fc680255 100644
--- a/wpimath/src/test/native/cpp/kinematics/ChassisSpeedsTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/ChassisSpeedsTest.cpp
@@ -7,6 +7,9 @@
 #include <gtest/gtest.h>
 
 #include "frc/kinematics/ChassisSpeeds.h"
+#include "units/angle.h"
+#include "units/angular_velocity.h"
+#include "units/velocity.h"
 
 static constexpr double kEpsilon = 1E-9;
 
diff --git a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveKinematicsTest.cpp b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveKinematicsTest.cpp
index 782fed05db..aad78eaa97 100644
--- a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveKinematicsTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveKinematicsTest.cpp
@@ -17,7 +17,7 @@ using namespace frc;
 static constexpr double kEpsilon = 1E-9;
 
 TEST(DifferentialDriveKinematicsTest, InverseKinematicsFromZero) {
-  const DifferentialDriveKinematics kinematics{0.381_m * 2};
+  const DifferentialDriveKinematics kinematics{2 * 0.381_m};
   const ChassisSpeeds chassisSpeeds;
   const auto wheelSpeeds = kinematics.ToWheelSpeeds(chassisSpeeds);
 
@@ -26,7 +26,7 @@ TEST(DifferentialDriveKinematicsTest, InverseKinematicsFromZero) {
 }
 
 TEST(DifferentialDriveKinematicsTest, ForwardKinematicsFromZero) {
-  const DifferentialDriveKinematics kinematics{0.381_m * 2};
+  const DifferentialDriveKinematics kinematics{2 * 0.381_m};
   const DifferentialDriveWheelSpeeds wheelSpeeds;
   const auto chassisSpeeds = kinematics.ToChassisSpeeds(wheelSpeeds);
 
@@ -36,7 +36,7 @@ TEST(DifferentialDriveKinematicsTest, ForwardKinematicsFromZero) {
 }
 
 TEST(DifferentialDriveKinematicsTest, InverseKinematicsForStraightLine) {
-  const DifferentialDriveKinematics kinematics{0.381_m * 2};
+  const DifferentialDriveKinematics kinematics{2 * 0.381_m};
   const ChassisSpeeds chassisSpeeds{3.0_mps, 0_mps, 0_rad_per_s};
   const auto wheelSpeeds = kinematics.ToWheelSpeeds(chassisSpeeds);
 
@@ -45,7 +45,7 @@ TEST(DifferentialDriveKinematicsTest, InverseKinematicsForStraightLine) {
 }
 
 TEST(DifferentialDriveKinematicsTest, ForwardKinematicsForStraightLine) {
-  const DifferentialDriveKinematics kinematics{0.381_m * 2};
+  const DifferentialDriveKinematics kinematics{2 * 0.381_m};
   const DifferentialDriveWheelSpeeds wheelSpeeds{3.0_mps, 3.0_mps};
   const auto chassisSpeeds = kinematics.ToChassisSpeeds(wheelSpeeds);
 
@@ -55,7 +55,7 @@ TEST(DifferentialDriveKinematicsTest, ForwardKinematicsForStraightLine) {
 }
 
 TEST(DifferentialDriveKinematicsTest, InverseKinematicsForRotateInPlace) {
-  const DifferentialDriveKinematics kinematics{0.381_m * 2};
+  const DifferentialDriveKinematics kinematics{2 * 0.381_m};
   const ChassisSpeeds chassisSpeeds{
       0.0_mps, 0.0_mps, units::radians_per_second_t{std::numbers::pi}};
   const auto wheelSpeeds = kinematics.ToWheelSpeeds(chassisSpeeds);
@@ -65,7 +65,7 @@ TEST(DifferentialDriveKinematicsTest, InverseKinematicsForRotateInPlace) {
 }
 
 TEST(DifferentialDriveKinematicsTest, ForwardKinematicsForRotateInPlace) {
-  const DifferentialDriveKinematics kinematics{0.381_m * 2};
+  const DifferentialDriveKinematics kinematics{2 * 0.381_m};
   const DifferentialDriveWheelSpeeds wheelSpeeds{
       units::meters_per_second_t{+0.381 * std::numbers::pi},
       units::meters_per_second_t{-0.381 * std::numbers::pi}};
diff --git a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometry3dTest.cpp b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometry3dTest.cpp
index 76f5f3292c..73e19295fa 100644
--- a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometry3dTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometry3dTest.cpp
@@ -8,6 +8,8 @@
 
 #include "frc/kinematics/DifferentialDriveKinematics.h"
 #include "frc/kinematics/DifferentialDriveOdometry3d.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 static constexpr double kEpsilon = 1E-9;
 
@@ -31,7 +33,7 @@ TEST(DifferentialDriveOdometry3dTest, EncoderDistances) {
                                        0_m, 0_m};
 
   const auto& pose = odometry.Update(frc::Rotation3d{0_deg, 0_deg, 135_deg},
-                                     0_m, units::meter_t{5 * std::numbers::pi});
+                                     0_m, units::meter_t{5.0 * std::numbers::pi});
 
   EXPECT_NEAR(pose.X().value(), 5.0, kEpsilon);
   EXPECT_NEAR(pose.Y().value(), 5.0, kEpsilon);
diff --git a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometryTest.cpp b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometryTest.cpp
index a228357f50..e5a6c95682 100644
--- a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometryTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveOdometryTest.cpp
@@ -8,6 +8,8 @@
 
 #include "frc/kinematics/DifferentialDriveKinematics.h"
 #include "frc/kinematics/DifferentialDriveOdometry.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 static constexpr double kEpsilon = 1E-9;
 
@@ -17,7 +19,7 @@ TEST(DifferentialDriveOdometryTest, EncoderDistances) {
   DifferentialDriveOdometry odometry{45_deg, 0_m, 0_m};
 
   const auto& pose =
-      odometry.Update(135_deg, 0_m, units::meter_t{5 * std::numbers::pi});
+      odometry.Update(135_deg, 0_m, units::meter_t{5.0 * std::numbers::pi});
 
   EXPECT_NEAR(pose.X().value(), 5.0, kEpsilon);
   EXPECT_NEAR(pose.Y().value(), 5.0, kEpsilon);
diff --git a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveWheelSpeedsTest.cpp b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveWheelSpeedsTest.cpp
index 92cc583644..1a2b1381a8 100644
--- a/wpimath/src/test/native/cpp/kinematics/DifferentialDriveWheelSpeedsTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/DifferentialDriveWheelSpeedsTest.cpp
@@ -5,6 +5,7 @@
 #include <gtest/gtest.h>
 
 #include "frc/kinematics/DifferentialDriveWheelSpeeds.h"
+#include "units/velocity.h"
 
 TEST(DifferentialDriveWheelSpeedsTest, Plus) {
   const frc::DifferentialDriveWheelSpeeds left{1.0_mps, 0.5_mps};
diff --git a/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometry3dTest.cpp b/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometry3dTest.cpp
index b195e8507b..08028da35a 100644
--- a/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometry3dTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometry3dTest.cpp
@@ -9,6 +9,12 @@
 
 #include "frc/kinematics/MecanumDriveOdometry3d.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/angular_velocity.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 using namespace frc;
 
@@ -155,7 +161,7 @@ TEST_F(MecanumDriveOdometry3dTest, AccuracyFacingTrajectory) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.06);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.06);
   EXPECT_LT(maxError, 0.125);
 }
 
@@ -218,6 +224,6 @@ TEST_F(MecanumDriveOdometry3dTest, AccuracyFacingXAxis) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.06);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.06);
   EXPECT_LT(maxError, 0.125);
 }
diff --git a/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometryTest.cpp b/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometryTest.cpp
index 18e786cb71..9960a94a31 100644
--- a/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometryTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/MecanumDriveOdometryTest.cpp
@@ -9,6 +9,12 @@
 
 #include "frc/kinematics/MecanumDriveOdometry.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/angular_velocity.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 using namespace frc;
 
@@ -136,7 +142,7 @@ TEST_F(MecanumDriveOdometryTest, AccuracyFacingTrajectory) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.06);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.06);
   EXPECT_LT(maxError, 0.125);
 }
 
@@ -198,6 +204,6 @@ TEST_F(MecanumDriveOdometryTest, AccuracyFacingXAxis) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.06);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.06);
   EXPECT_LT(maxError, 0.125);
 }
diff --git a/wpimath/src/test/native/cpp/kinematics/MecanumDriveWheelSpeedsTest.cpp b/wpimath/src/test/native/cpp/kinematics/MecanumDriveWheelSpeedsTest.cpp
index c10cfb5f85..883c94e403 100644
--- a/wpimath/src/test/native/cpp/kinematics/MecanumDriveWheelSpeedsTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/MecanumDriveWheelSpeedsTest.cpp
@@ -5,6 +5,7 @@
 #include <gtest/gtest.h>
 
 #include "frc/kinematics/MecanumDriveWheelSpeeds.h"
+#include "units/velocity.h"
 
 TEST(MecanumDriveWheelSpeedsTest, Plus) {
   const frc::MecanumDriveWheelSpeeds left{1.0_mps, 0.5_mps, 2.0_mps, 1.5_mps};
diff --git a/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometry3dTest.cpp b/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometry3dTest.cpp
index d9fd52a559..8709184bc6 100644
--- a/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometry3dTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometry3dTest.cpp
@@ -12,6 +12,11 @@
 #include "frc/trajectory/Trajectory.h"
 #include "frc/trajectory/TrajectoryConfig.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 using namespace frc;
 
@@ -155,7 +160,7 @@ TEST_F(SwerveDriveOdometry3dTest, AccuracyFacingTrajectory) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.05);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.05);
   EXPECT_LT(maxError, 0.125);
 }
 
@@ -219,6 +224,6 @@ TEST_F(SwerveDriveOdometry3dTest, AccuracyFacingXAxis) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.06);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.06);
   EXPECT_LT(maxError, 0.125);
 }
diff --git a/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometryTest.cpp b/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometryTest.cpp
index 80a3c85cd7..a6ddede037 100644
--- a/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometryTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/SwerveDriveOdometryTest.cpp
@@ -12,6 +12,11 @@
 #include "frc/trajectory/Trajectory.h"
 #include "frc/trajectory/TrajectoryConfig.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/time.h"
+#include "units/velocity.h"
 
 using namespace frc;
 
@@ -133,7 +138,7 @@ TEST_F(SwerveDriveOdometryTest, AccuracyFacingTrajectory) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.05);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.05);
   EXPECT_LT(maxError, 0.125);
 }
 
@@ -196,6 +201,6 @@ TEST_F(SwerveDriveOdometryTest, AccuracyFacingXAxis) {
     t += dt;
   }
 
-  EXPECT_LT(errorSum / (trajectory.TotalTime().value() / dt.value()), 0.06);
+  EXPECT_LT(errorSum / double{trajectory.TotalTime() / dt}, 0.06);
   EXPECT_LT(maxError, 0.125);
 }
diff --git a/wpimath/src/test/native/cpp/kinematics/SwerveModulePositionTest.cpp b/wpimath/src/test/native/cpp/kinematics/SwerveModulePositionTest.cpp
index 14155f1d47..61f8726802 100644
--- a/wpimath/src/test/native/cpp/kinematics/SwerveModulePositionTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/SwerveModulePositionTest.cpp
@@ -6,6 +6,8 @@
 
 #include "frc/geometry/Rotation2d.h"
 #include "frc/kinematics/SwerveModulePosition.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 TEST(SwerveModulePositionTest, Equality) {
   frc::SwerveModulePosition position1{2_m, 90_deg};
diff --git a/wpimath/src/test/native/cpp/kinematics/SwerveModuleStateTest.cpp b/wpimath/src/test/native/cpp/kinematics/SwerveModuleStateTest.cpp
index 9d13eeca4e..8a6d2f14f8 100644
--- a/wpimath/src/test/native/cpp/kinematics/SwerveModuleStateTest.cpp
+++ b/wpimath/src/test/native/cpp/kinematics/SwerveModuleStateTest.cpp
@@ -6,6 +6,8 @@
 
 #include "frc/geometry/Rotation2d.h"
 #include "frc/kinematics/SwerveModuleState.h"
+#include "units/angle.h"
+#include "units/velocity.h"
 
 static constexpr double kEpsilon = 1E-9;
 
diff --git a/wpimath/src/test/native/cpp/path/TravelingSalesmanTest.cpp b/wpimath/src/test/native/cpp/path/TravelingSalesmanTest.cpp
index f46eb2040f..22b8dbbb9b 100644
--- a/wpimath/src/test/native/cpp/path/TravelingSalesmanTest.cpp
+++ b/wpimath/src/test/native/cpp/path/TravelingSalesmanTest.cpp
@@ -14,6 +14,8 @@
 #include "frc/geometry/Pose2d.h"
 #include "frc/geometry/Rotation2d.h"
 #include "frc/path/TravelingSalesman.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 /**
  * Returns true if the cycles represented by the two lists match.
diff --git a/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp b/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp
index 744680bd03..098ce7a72f 100644
--- a/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp
+++ b/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp
@@ -30,7 +30,7 @@ class CubicHermiteSplineTest : public ::testing::Test {
         SplineHelper::CubicSplinesFromControlVectors(startCV, waypoints, endCV);
     std::vector<Spline<3>::PoseWithCurvature> poses;
 
-    poses.push_back(splines[0].GetPoint(0.0).value());
+    poses.push_back(splines[0].GetPoint(0.0). value());
 
     for (auto&& spline : splines) {
       auto x = SplineParameterizer::Parameterize(spline);
diff --git a/wpimath/src/test/native/cpp/system/DiscretizationTest.cpp b/wpimath/src/test/native/cpp/system/DiscretizationTest.cpp
index 055ee49736..8531896cae 100644
--- a/wpimath/src/test/native/cpp/system/DiscretizationTest.cpp
+++ b/wpimath/src/test/native/cpp/system/DiscretizationTest.cpp
@@ -10,6 +10,7 @@
 #include "frc/EigenCore.h"
 #include "frc/system/Discretization.h"
 #include "frc/system/NumericalIntegration.h"
+#include "units/time.h"
 
 // Check that for a simple second-order system that we can easily analyze
 // analytically,
diff --git a/wpimath/src/test/native/cpp/system/NumericalIntegrationTest.cpp b/wpimath/src/test/native/cpp/system/NumericalIntegrationTest.cpp
index 05ec0a4826..7ace1915d6 100644
--- a/wpimath/src/test/native/cpp/system/NumericalIntegrationTest.cpp
+++ b/wpimath/src/test/native/cpp/system/NumericalIntegrationTest.cpp
@@ -8,6 +8,7 @@
 
 #include "frc/EigenCore.h"
 #include "frc/system/NumericalIntegration.h"
+#include "units/time.h"
 
 // Test that integrating dx/dt = eˣ works
 TEST(NumericalIntegrationTest, Exponential) {
diff --git a/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp b/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp
index 8bb39cecdb..e5274b83c0 100644
--- a/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp
+++ b/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp
@@ -4,6 +4,7 @@
 
 #include "frc/trajectory/ExponentialProfile.h"  // NOLINT(build/include_order)
 
+#include <algorithm>
 #include <chrono>
 #include <cmath>
 #include <tuple>
@@ -160,7 +161,7 @@ TEST(ExponentialProfileTest, TopSpeed) {
 
   for (int i = 0; i < 900; ++i) {
     state = CheckDynamics(profile, constraints, feedforward, state, goal);
-    maxSpeed = units::math::max(state.velocity, maxSpeed);
+    maxSpeed = std::max(state.velocity, maxSpeed);
   }
 
   EXPECT_NEAR_UNITS(constraints.MaxVelocity(), maxSpeed, 1e-5_mps);
@@ -181,7 +182,7 @@ TEST(ExponentialProfileTest, TopSpeedBackward) {
 
   for (int i = 0; i < 900; ++i) {
     state = CheckDynamics(profile, constraints, feedforward, state, goal);
-    maxSpeed = units::math::min(state.velocity, maxSpeed);
+    maxSpeed = std::min(state.velocity, maxSpeed);
   }
 
   EXPECT_NEAR_UNITS(-constraints.MaxVelocity(), maxSpeed, 1e-5_mps);
@@ -267,10 +268,10 @@ TEST(ExponentialProfileTest, TestHeuristic) {
   for (auto& testCase : testCases) {
     auto state = profile.CalculateInflectionPoint(std::get<0>(testCase),
                                                   std::get<1>(testCase));
-    EXPECT_NEAR_UNITS(std::get<2>(testCase).position / 1_m,
-                      state.position / 1_m, 1e-3);
-    EXPECT_NEAR_UNITS(std::get<2>(testCase).velocity / 1_mps,
-                      state.velocity / 1_mps, 1e-3);
+    EXPECT_NEAR_UNITS(std::get<2>(testCase).position,
+                      state.position, 1e-3_m);
+    EXPECT_NEAR_UNITS(std::get<2>(testCase).velocity,
+                      state.velocity, 1e-3_mps);
   }
 }
 
diff --git a/wpimath/src/test/native/cpp/trajectory/TrajectoryConcatenateTest.cpp b/wpimath/src/test/native/cpp/trajectory/TrajectoryConcatenateTest.cpp
index 2bfd5413a5..990ff9bc1a 100644
--- a/wpimath/src/test/native/cpp/trajectory/TrajectoryConcatenateTest.cpp
+++ b/wpimath/src/test/native/cpp/trajectory/TrajectoryConcatenateTest.cpp
@@ -6,6 +6,10 @@
 
 #include "frc/trajectory/TrajectoryConfig.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/velocity.h"
 
 TEST(TrajectoryConcatenateTest, States) {
   auto t1 = frc::TrajectoryGenerator::GenerateTrajectory(
diff --git a/wpimath/src/test/native/cpp/trajectory/TrajectoryTransformTest.cpp b/wpimath/src/test/native/cpp/trajectory/TrajectoryTransformTest.cpp
index f088fa34b6..17169746cc 100644
--- a/wpimath/src/test/native/cpp/trajectory/TrajectoryTransformTest.cpp
+++ b/wpimath/src/test/native/cpp/trajectory/TrajectoryTransformTest.cpp
@@ -9,6 +9,10 @@
 #include "frc/trajectory/Trajectory.h"
 #include "frc/trajectory/TrajectoryConfig.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
+#include "units/acceleration.h"
+#include "units/angle.h"
+#include "units/length.h"
+#include "units/velocity.h"
 
 void TestSameShapedTrajectory(std::vector<frc::Trajectory::State> statesA,
                               std::vector<frc::Trajectory::State> statesB) {
diff --git a/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp b/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp
index 0846e8b74c..8cfb1dde8e 100644
--- a/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp
+++ b/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp
@@ -119,7 +119,7 @@ TEST(TrapezoidProfileTest, TopSpeed) {
   for (int i = 0; i < 200; ++i) {
     state = profile.Calculate(kDt, state, goal);
   }
-  EXPECT_NEAR_UNITS(constraints.maxVelocity, state.velocity, 10e-5_mps);
+  EXPECT_NEAR_UNITS(constraints.maxVelocity, state.velocity, 1e-4_mps);
 
   profile = frc::TrapezoidProfile<units::meter>{constraints};
   for (int i = 0; i < 2000; ++i) {
@@ -142,8 +142,6 @@ TEST(TrapezoidProfileTest, TimingToCurrent) {
 }
 
 TEST(TrapezoidProfileTest, TimingToGoal) {
-  using units::unit_cast;
-
   frc::TrapezoidProfile<units::meter>::Constraints constraints{0.75_mps,
                                                                0.75_mps_sq};
   frc::TrapezoidProfile<units::meter>::State goal{2_m, 0_mps};
@@ -159,15 +157,13 @@ TEST(TrapezoidProfileTest, TimingToGoal) {
     if (!reachedGoal && state == goal) {
       // Expected value using for loop index is just an approximation since the
       // time left in the profile doesn't increase linearly at the endpoints
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 0.25);
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 0.25);
       reachedGoal = true;
     }
   }
 }
 
 TEST(TrapezoidProfileTest, TimingBeforeGoal) {
-  using units::unit_cast;
-
   frc::TrapezoidProfile<units::meter>::Constraints constraints{0.75_mps,
                                                                0.75_mps_sq};
   frc::TrapezoidProfile<units::meter>::State goal{2_m, 0_mps};
@@ -181,16 +177,14 @@ TEST(TrapezoidProfileTest, TimingBeforeGoal) {
   for (int i = 0; i < 400; i++) {
     state = profile.Calculate(kDt, state, goal);
     if (!reachedGoal &&
-        (units::math::abs(state.velocity - 1_mps) < 10e-5_mps)) {
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 2e-2);
+        (units::math::abs(state.velocity - 1_mps) < 1e-4_mps)) {
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 2e-2);
       reachedGoal = true;
     }
   }
 }
 
 TEST(TrapezoidProfileTest, TimingToNegativeGoal) {
-  using units::unit_cast;
-
   frc::TrapezoidProfile<units::meter>::Constraints constraints{0.75_mps,
                                                                0.75_mps_sq};
   frc::TrapezoidProfile<units::meter>::State goal{-2_m, 0_mps};
@@ -206,15 +200,13 @@ TEST(TrapezoidProfileTest, TimingToNegativeGoal) {
     if (!reachedGoal && state == goal) {
       // Expected value using for loop index is just an approximation since the
       // time left in the profile doesn't increase linearly at the endpoints
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 0.25);
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 0.25);
       reachedGoal = true;
     }
   }
 }
 
 TEST(TrapezoidProfileTest, TimingBeforeNegativeGoal) {
-  using units::unit_cast;
-
   frc::TrapezoidProfile<units::meter>::Constraints constraints{0.75_mps,
                                                                0.75_mps_sq};
   frc::TrapezoidProfile<units::meter>::State goal{-2_m, 0_mps};
@@ -228,8 +220,8 @@ TEST(TrapezoidProfileTest, TimingBeforeNegativeGoal) {
   for (int i = 0; i < 400; i++) {
     state = profile.Calculate(kDt, state, goal);
     if (!reachedGoal &&
-        (units::math::abs(state.velocity + 1_mps) < 10e-5_mps)) {
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 2e-2);
+        (units::math::abs(state.velocity + 1_mps) < 1e-4_mps)) {
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 2e-2);
       reachedGoal = true;
     }
   }
diff --git a/wpimath/src/test/native/include/trajectory/TestTrajectory.h b/wpimath/src/test/native/include/trajectory/TestTrajectory.h
index 89e735cf44..5a21271f0c 100644
--- a/wpimath/src/test/native/include/trajectory/TestTrajectory.h
+++ b/wpimath/src/test/native/include/trajectory/TestTrajectory.h
@@ -11,6 +11,8 @@
 #include "frc/trajectory/Trajectory.h"
 #include "frc/trajectory/TrajectoryGenerator.h"
 #include "frc/trajectory/constraint/TrajectoryConstraint.h"
+#include "units/angle.h"
+#include "units/length.h"
 
 namespace frc {
 class TestTrajectory {
