diff --git a/apriltag/src/main/native/cpp/AprilTagFieldLayout.cpp b/apriltag/src/main/native/cpp/AprilTagFieldLayout.cpp
index 255321198a..56d7cf8446 100644
--- a/apriltag/src/main/native/cpp/AprilTagFieldLayout.cpp
+++ b/apriltag/src/main/native/cpp/AprilTagFieldLayout.cpp
@@ -23,6 +23,7 @@ AprilTagFieldLayout::AprilTagFieldLayout(std::string_view path) {
   }
 
   wpi::util::json json =
+      // next line non-unit .value()
       wpi::util::json::parse(fileBuffer.value()->GetCharBuffer());
 
   for (const auto& tag : json.at("tags").get<std::vector<AprilTag>>()) {
diff --git a/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp b/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp
index 9b78ee611f..7fb015fb81 100644
--- a/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp
+++ b/commandsv2/src/main/native/include/wpi/commands2/sysid/SysIdRoutine.hpp
@@ -23,13 +23,13 @@ using ramp_rate_t = wpi::units::unit_t<wpi::units::compound_unit<
 class Config {
  public:
   /// The voltage ramp rate used for quasistatic test routines.
-  ramp_rate_t m_rampRate{1_V / 1_s};
+  ramp_rate_t m_rampRate = 1_V / 1_s;
 
   /// The step voltage output used for dynamic test routines.
-  wpi::units::volt_t m_stepVoltage{7_V};
+  wpi::units::volt_t m_stepVoltage = 7_V;
 
   /// Safety timeout for the test routine commands.
-  wpi::units::second_t m_timeout{10_s};
+  wpi::units::second_t m_timeout = 10_s;
 
   /// Optional handle for recording test state in a third-party logging
   /// solution.
@@ -190,7 +190,7 @@ class SysIdRoutine : public wpi::sysid::SysIdRoutineLog {
  private:
   Config m_config;
   Mechanism m_mechanism;
-  wpi::units::volt_t m_outputVolts{0};
+  wpi::units::volt_t m_outputVolts = wpi::units::volt_t{0};
   std::function<void(wpi::sysid::State)> m_recordState;
   wpi::Timer timer;
 };
diff --git a/ntcore/src/main/native/cpp/NetworkServer.cpp b/ntcore/src/main/native/cpp/NetworkServer.cpp
index ff26afd4e9..7d451c3843 100644
--- a/ntcore/src/main/native/cpp/NetworkServer.cpp
+++ b/ntcore/src/main/native/cpp/NetworkServer.cpp
@@ -315,13 +315,14 @@ void NetworkServer::LoadPersistent() {
                   std::filesystem::copy_options::overwrite_existing, ec);
     // try to write an empty file so it doesn't happen again
     wpi::util::raw_fd_ostream os{m_persistentFilename, ec, fs::F_Text};
-    if (ec.value() == 0) {
+    if (ec.value() == 0) {  // non-unit .value()
       os << "[]\n";
       os.close();
     }
     return;
   }
   m_persistentData =
+      // next line non-unit .value()
       std::string{fileBuffer.value()->begin(), fileBuffer.value()->end()};
   DEBUG4("read data: {}", m_persistentData);
 }
@@ -332,7 +333,7 @@ void NetworkServer::SavePersistent(std::string_view filename,
   auto tmp = fmt::format("{}.tmp", filename);
   std::error_code ec;
   wpi::util::raw_fd_ostream os{tmp, ec, fs::F_Text};
-  if (ec.value() != 0) {
+  if (ec.value() != 0) {  // non-unit .value()
     INFO("could not open persistent file '{}' for write: {}", tmp,
          ec.message());
     return;
@@ -349,7 +350,7 @@ void NetworkServer::SavePersistent(std::string_view filename,
   fs::remove(bak, ec);
   fs::rename(filename, bak, ec);
   fs::rename(tmp, filename, ec);
-  if (ec.value() != 0) {
+  if (ec.value() != 0) {  // non-unit .value()
     // attempt to restore backup
     fs::rename(bak, filename, ec);
   }
diff --git a/ntcore/src/main/native/cpp/Value.cpp b/ntcore/src/main/native/cpp/Value.cpp
index 8aa2c316f1..7f7c0a9144 100644
--- a/ntcore/src/main/native/cpp/Value.cpp
+++ b/ntcore/src/main/native/cpp/Value.cpp
@@ -177,7 +177,7 @@ Value Value::MakeStringArray(std::vector<std::string>&& value, int64_t time) {
 }
 
 void wpi::nt::ConvertToC(const Value& in, NT_Value* out) {
-  *out = in.value();
+  *out = in.value();  // non-unit .value()
   switch (in.type()) {
     case NT_STRING:
       ConvertToC(in.GetString(), &out->data.v_string);
diff --git a/ntcore/src/main/native/cpp/local/LocalTopic.cpp b/ntcore/src/main/native/cpp/local/LocalTopic.cpp
index b201a4b90c..3be886a937 100644
--- a/ntcore/src/main/native/cpp/local/LocalTopic.cpp
+++ b/ntcore/src/main/native/cpp/local/LocalTopic.cpp
@@ -138,10 +138,10 @@ bool LocalTopic::SetProperties(const wpi::util::json& update) {
     return false;
   }
   for (auto&& change : update.items()) {
-    if (change.value().is_null()) {
+    if (change.value().is_null()) {  // non-unit .value()
       properties.erase(change.key());
     } else {
-      properties[change.key()] = change.value();
+      properties[change.key()] = change.value();  // non-unit .value()
     }
   }
   return true;
@@ -159,8 +159,8 @@ wpi::util::json LocalTopic::CompareProperties(const wpi::util::json props) {
   // added/changed
   for (auto&& prop : props.items()) {
     auto it = properties.find(prop.key());
-    if (it == properties.end() || *it != prop.value()) {
-      update[prop.key()] = prop.value();
+    if (it == properties.end() || *it != prop.value()) {  // non-unit .value()
+      update[prop.key()] = prop.value();                  // non-unit .value()
     }
   }
   // removed
diff --git a/ntcore/src/main/native/cpp/server/ServerTopic.cpp b/ntcore/src/main/native/cpp/server/ServerTopic.cpp
index eaf85ddd76..e7f962636e 100644
--- a/ntcore/src/main/native/cpp/server/ServerTopic.cpp
+++ b/ntcore/src/main/native/cpp/server/ServerTopic.cpp
@@ -14,10 +14,10 @@ bool ServerTopic::SetProperties(const wpi::util::json& update) {
   }
   bool updated = false;
   for (auto&& elem : update.items()) {
-    if (elem.value().is_null()) {
+    if (elem.value().is_null()) {  // non-unit .value()
       properties.erase(elem.key());
     } else {
-      properties[elem.key()] = elem.value();
+      properties[elem.key()] = elem.value();  // non-unit .value()
     }
     updated = true;
   }
diff --git a/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp b/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp
index b113e56056..09bcf6b00b 100644
--- a/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp
+++ b/ntcore/src/main/native/include/wpi/nt/UnitTopic.hpp
@@ -11,6 +11,7 @@
 
 #include "wpi/nt/Topic.hpp"
 #include "wpi/nt/ntcore_cpp.hpp"
+#include "wpi/units/base.hpp"
 #include "wpi/util/json.hpp"
 
 namespace wpi::nt {
diff --git a/wpilibc/src/main/native/cpp/ExpansionHubServo.cpp b/wpilibc/src/main/native/cpp/ExpansionHubServo.cpp
index 2e9fbc46d5..d816f2e66a 100644
--- a/wpilibc/src/main/native/cpp/ExpansionHubServo.cpp
+++ b/wpilibc/src/main/native/cpp/ExpansionHubServo.cpp
@@ -72,7 +72,7 @@ void ExpansionHubServo::SetAngle(wpi::units::degree_t angle) {
   angle = std::clamp(angle, m_minServoAngle, m_maxServoAngle);
 
   // NOLINTNEXTLINE(bugprone-integer-division)
-  Set((angle - m_minServoAngle) / GetServoAngleRange());
+  Set(double{(angle - m_minServoAngle) / GetServoAngleRange()});
 }
 
 void ExpansionHubServo::SetPulseWidth(wpi::units::microsecond_t pulseWidth) {
diff --git a/wpilibc/src/main/native/cpp/counter/Tachometer.cpp b/wpilibc/src/main/native/cpp/counter/Tachometer.cpp
index f41c2d1abe..a5d81703b4 100644
--- a/wpilibc/src/main/native/cpp/counter/Tachometer.cpp
+++ b/wpilibc/src/main/native/cpp/counter/Tachometer.cpp
@@ -71,7 +71,7 @@ wpi::units::turns_per_second_t Tachometer::GetRevolutionsPerSecond() const {
 
 wpi::units::revolutions_per_minute_t Tachometer::GetRevolutionsPerMinute()
     const {
-  return wpi::units::revolutions_per_minute_t{GetRevolutionsPerSecond()};
+  return GetRevolutionsPerSecond();
 }
 
 bool Tachometer::GetStopped() const {
diff --git a/wpilibc/src/main/native/cpp/hardware/led/LEDPattern.cpp b/wpilibc/src/main/native/cpp/hardware/led/LEDPattern.cpp
index c4b05d5ecb..72e72d1e5f 100644
--- a/wpilibc/src/main/native/cpp/hardware/led/LEDPattern.cpp
+++ b/wpilibc/src/main/native/cpp/hardware/led/LEDPattern.cpp
@@ -128,12 +128,12 @@ LEDPattern LEDPattern::SynchronizedBlink(std::function<bool()> signal) {
 }
 
 LEDPattern LEDPattern::Breathe(wpi::units::second_t period) {
-  auto periodMicros = wpi::units::microsecond_t{period};
+  double periodMicros = wpi::units::microsecond_t{period}.value();
 
   return LEDPattern{[periodMicros, self = *this](auto data, auto writer) {
     self.ApplyTo(data, [&writer, periodMicros](int i, Color color) {
-      double t = (wpi::util::Now() % periodMicros.to<uint64_t>()) /
-                 periodMicros.to<double>();
+      double t = (wpi::util::Now() % static_cast<uint64_t>(periodMicros)) /
+                 periodMicros;
       double phase = t * 2 * std::numbers::pi;
 
       // Apply the cosine function and shift its output from [-1, 1] to [0, 1]
diff --git a/wpilibc/src/main/native/cpp/hardware/rotation/DutyCycleEncoder.cpp b/wpilibc/src/main/native/cpp/hardware/rotation/DutyCycleEncoder.cpp
index 1dacd45b22..6aab8b61d6 100644
--- a/wpilibc/src/main/native/cpp/hardware/rotation/DutyCycleEncoder.cpp
+++ b/wpilibc/src/main/native/cpp/hardware/rotation/DutyCycleEncoder.cpp
@@ -87,7 +87,7 @@ double DutyCycleEncoder::Get() const {
     pos = m_dutyCycle->GetOutput();
   } else {
     auto highTime = m_dutyCycle->GetHighTime();
-    pos = highTime / m_period;
+    pos = double{highTime / m_period};
   }
 
   // Map sensor range if range isn't full
diff --git a/wpilibc/src/main/native/cpp/motorcontrol/MotorController.cpp b/wpilibc/src/main/native/cpp/motorcontrol/MotorController.cpp
index d01d1d78e7..25daf9413e 100644
--- a/wpilibc/src/main/native/cpp/motorcontrol/MotorController.cpp
+++ b/wpilibc/src/main/native/cpp/motorcontrol/MotorController.cpp
@@ -10,5 +10,5 @@ using namespace wpi;
 
 void MotorController::SetVoltage(wpi::units::volt_t output) {
   // NOLINTNEXTLINE(bugprone-integer-division)
-  Set(output / RobotController::GetBatteryVoltage());
+  Set(double{output / RobotController::GetBatteryVoltage()});
 }
diff --git a/wpilibc/src/main/native/cpp/motorcontrol/PWMMotorController.cpp b/wpilibc/src/main/native/cpp/motorcontrol/PWMMotorController.cpp
index 198ed0d358..077e91b27e 100644
--- a/wpilibc/src/main/native/cpp/motorcontrol/PWMMotorController.cpp
+++ b/wpilibc/src/main/native/cpp/motorcontrol/PWMMotorController.cpp
@@ -32,7 +32,7 @@ void PWMMotorController::Set(double speed) {
 
 void PWMMotorController::SetVoltage(wpi::units::volt_t output) {
   // NOLINTNEXTLINE(bugprone-integer-division)
-  Set(output / RobotController::GetBatteryVoltage());
+  Set(double{output / RobotController::GetBatteryVoltage()});
 }
 
 double PWMMotorController::Get() const {
diff --git a/wpilibc/src/main/native/cpp/simulation/DCMotorSim.cpp b/wpilibc/src/main/native/cpp/simulation/DCMotorSim.cpp
index 3485487e6b..7e520d3228 100644
--- a/wpilibc/src/main/native/cpp/simulation/DCMotorSim.cpp
+++ b/wpilibc/src/main/native/cpp/simulation/DCMotorSim.cpp
@@ -33,12 +33,14 @@ DCMotorSim::DCMotorSim(const wpi::math::LinearSystem<2, 1, 2>& plant,
       //   B = GKₜ/(RJ)
       //   J = GKₜ/(RB)
       m_gearing(-gearbox.Kv.value() * m_plant.A(1, 1) / m_plant.B(1, 0)),
-      m_j(m_gearing * gearbox.Kt.value() /
-          (gearbox.R.value() * m_plant.B(1, 0))) {}
+      m_j(wpi::units::kilogram_square_meter_t{
+          m_gearing * gearbox.Kt.value() /
+          (gearbox.R.value() * m_plant.B(1, 0))}) {}
 
 void DCMotorSim::SetState(wpi::units::radian_t angularPosition,
                           wpi::units::radians_per_second_t angularVelocity) {
-  SetState(wpi::math::Vectord<2>{angularPosition, angularVelocity});
+  SetState(
+      wpi::math::Vectord<2>{angularPosition.value(), angularVelocity.value()});
 }
 
 void DCMotorSim::SetAngle(wpi::units::radian_t angularPosition) {
diff --git a/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp b/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp
index 614f0abd36..02b8433c45 100644
--- a/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp
+++ b/wpilibc/src/main/native/cpp/simulation/ElevatorSim.cpp
@@ -54,8 +54,9 @@ ElevatorSim::ElevatorSim(decltype(1_V / Velocity_t<Distance>(1)) kV,
 
 void ElevatorSim::SetState(wpi::units::meter_t position,
                            wpi::units::meters_per_second_t velocity) {
-  SetState(wpi::math::Vectord<2>{std::clamp(position, m_minHeight, m_maxHeight),
-                                 velocity});
+  SetState(wpi::math::Vectord<2>{
+      std::clamp(position, m_minHeight, m_maxHeight).value(),
+      velocity.value()});
 }
 
 bool ElevatorSim::WouldHitLowerLimit(wpi::units::meter_t elevatorHeight) const {
@@ -91,7 +92,8 @@ wpi::units::ampere_t ElevatorSim::GetCurrentDraw() const {
   using Kv_t = wpi::units::unit_t<wpi::units::compound_unit<
       wpi::units::volt, wpi::units::inverse<wpi::units::meters_per_second>>>;
   Kv_t Kv = Kv_t{kA * m_plant.A(1, 1)};
-  wpi::units::meters_per_second_t velocity{m_x(1)};
+  wpi::units::meters_per_second_t velocity =
+      wpi::units::meters_per_second_t{m_x(1)};
   wpi::units::radians_per_second_t motorVelocity = velocity * Kv * m_gearbox.Kv;
 
   // Perform calculation and return.
diff --git a/wpilibc/src/main/native/cpp/simulation/FlywheelSim.cpp b/wpilibc/src/main/native/cpp/simulation/FlywheelSim.cpp
index 25f893a5c5..0a5d0add3a 100644
--- a/wpilibc/src/main/native/cpp/simulation/FlywheelSim.cpp
+++ b/wpilibc/src/main/native/cpp/simulation/FlywheelSim.cpp
@@ -33,8 +33,9 @@ FlywheelSim::FlywheelSim(const wpi::math::LinearSystem<1, 1, 1>& plant,
       //   B = GKₜ/(RJ)
       //   J = GKₜ/(RB)
       m_gearing(-gearbox.Kv.value() * m_plant.A(0, 0) / m_plant.B(0, 0)),
-      m_j(m_gearing * gearbox.Kt.value() /
-          (gearbox.R.value() * m_plant.B(0, 0))) {}
+      m_j(wpi::units::kilogram_square_meter_t{
+          m_gearing * gearbox.Kt.value() /
+          (gearbox.R.value() * m_plant.B(0, 0))}) {}
 
 void FlywheelSim::SetVelocity(wpi::units::radians_per_second_t velocity) {
   LinearSystemSim::SetState(wpi::math::Vectord<1>{velocity.value()});
diff --git a/wpilibc/src/main/native/cpp/simulation/SingleJointedArmSim.cpp b/wpilibc/src/main/native/cpp/simulation/SingleJointedArmSim.cpp
index d22ba2dacf..3a45dadb0e 100644
--- a/wpilibc/src/main/native/cpp/simulation/SingleJointedArmSim.cpp
+++ b/wpilibc/src/main/native/cpp/simulation/SingleJointedArmSim.cpp
@@ -45,8 +45,8 @@ SingleJointedArmSim::SingleJointedArmSim(
 
 void SingleJointedArmSim::SetState(wpi::units::radian_t angle,
                                    wpi::units::radians_per_second_t velocity) {
-  SetState(wpi::math::Vectord<2>{std::clamp(angle, m_minAngle, m_maxAngle),
-                                 velocity});
+  SetState(wpi::math::Vectord<2>{
+      std::clamp(angle, m_minAngle, m_maxAngle).value(), velocity.value()});
 }
 
 bool SingleJointedArmSim::WouldHitLowerLimit(
@@ -78,7 +78,8 @@ wpi::units::radians_per_second_t SingleJointedArmSim::GetVelocity() const {
 wpi::units::ampere_t SingleJointedArmSim::GetCurrentDraw() const {
   // Reductions are greater than 1, so a reduction of 10:1 would mean the motor
   // is spinning 10x faster than the output
-  wpi::units::radians_per_second_t motorVelocity{m_x(1) * m_gearing};
+  wpi::units::radians_per_second_t motorVelocity =
+      wpi::units::radians_per_second_t{m_x(1) * m_gearing};
   return m_gearbox.Current(motorVelocity, wpi::units::volt_t{m_u(0)}) *
          wpi::util::sgn(m_u(0));
 }
diff --git a/wpilibc/src/main/native/cpp/system/Notifier.cpp b/wpilibc/src/main/native/cpp/system/Notifier.cpp
index 08aa2e066d..2d1b4d88c6 100644
--- a/wpilibc/src/main/native/cpp/system/Notifier.cpp
+++ b/wpilibc/src/main/native/cpp/system/Notifier.cpp
@@ -205,7 +205,7 @@ void Notifier::UpdateAlarm(uint64_t triggerTime) {
 }
 
 void Notifier::UpdateAlarm() {
-  UpdateAlarm(static_cast<uint64_t>(m_expirationTime * 1e6));
+  UpdateAlarm(static_cast<uint64_t>(m_expirationTime.value() * 1e6));
 }
 
 bool Notifier::SetHALThreadPriority(bool realTime, int32_t priority) {
diff --git a/wpilibc/src/main/native/cpp/system/Watchdog.cpp b/wpilibc/src/main/native/cpp/system/Watchdog.cpp
index 73a6fc5352..70b2f3cfd9 100644
--- a/wpilibc/src/main/native/cpp/system/Watchdog.cpp
+++ b/wpilibc/src/main/native/cpp/system/Watchdog.cpp
@@ -110,7 +110,7 @@ void Watchdog::Impl::Main() {
     // has occurred, so call its timeout function.
     auto watchdog = m_watchdogs.pop();
 
-    wpi::units::second_t now{curTime * 1e-6};
+    wpi::units::second_t now = wpi::units::second_t{curTime * 1e-6};
     if (now - watchdog->m_lastTimeoutPrintTime > kMinPrintPeriod) {
       watchdog->m_lastTimeoutPrintTime = now;
       if (!watchdog->m_suppressTimeoutMessage) {
diff --git a/wpilibc/src/main/native/include/wpi/hardware/imu/OnboardIMU.hpp b/wpilibc/src/main/native/include/wpi/hardware/imu/OnboardIMU.hpp
index 74e08a0d02..43e38487e7 100644
--- a/wpilibc/src/main/native/include/wpi/hardware/imu/OnboardIMU.hpp
+++ b/wpilibc/src/main/native/include/wpi/hardware/imu/OnboardIMU.hpp
@@ -125,6 +125,6 @@ class OnboardIMU {
  private:
   wpi::units::radian_t GetYawNoOffset();
   MountOrientation m_mountOrientation;
-  wpi::units::radian_t m_yawOffset{0};
+  wpi::units::radian_t m_yawOffset = wpi::units::radian_t{0};
 };
 }  // namespace wpi
diff --git a/wpilibc/src/main/native/include/wpi/hardware/motor/PWMMotorController.hpp b/wpilibc/src/main/native/include/wpi/hardware/motor/PWMMotorController.hpp
index a8961125d5..74df52f737 100644
--- a/wpilibc/src/main/native/include/wpi/hardware/motor/PWMMotorController.hpp
+++ b/wpilibc/src/main/native/include/wpi/hardware/motor/PWMMotorController.hpp
@@ -152,11 +152,11 @@ class PWMMotorController
   wpi::hal::SimDouble m_simSpeed;
 
   bool m_eliminateDeadband{0};
-  wpi::units::microsecond_t m_minPwm{0};
-  wpi::units::microsecond_t m_deadbandMinPwm{0};
-  wpi::units::microsecond_t m_centerPwm{0};
-  wpi::units::microsecond_t m_deadbandMaxPwm{0};
-  wpi::units::microsecond_t m_maxPwm{0};
+  wpi::units::microsecond_t m_minPwm = wpi::units::microsecond_t{0};
+  wpi::units::microsecond_t m_deadbandMinPwm = wpi::units::microsecond_t{0};
+  wpi::units::microsecond_t m_centerPwm = wpi::units::microsecond_t{0};
+  wpi::units::microsecond_t m_deadbandMaxPwm = wpi::units::microsecond_t{0};
+  wpi::units::microsecond_t m_maxPwm = wpi::units::microsecond_t{0};
 
   wpi::units::microsecond_t GetMinPositivePwm() const;
   wpi::units::microsecond_t GetMaxNegativePwm() const;
diff --git a/wpilibc/src/main/native/include/wpi/hardware/rotation/DutyCycleEncoder.hpp b/wpilibc/src/main/native/include/wpi/hardware/rotation/DutyCycleEncoder.hpp
index 2a23f86411..27e7b05ce5 100644
--- a/wpilibc/src/main/native/include/wpi/hardware/rotation/DutyCycleEncoder.hpp
+++ b/wpilibc/src/main/native/include/wpi/hardware/rotation/DutyCycleEncoder.hpp
@@ -184,10 +184,10 @@ class DutyCycleEncoder : public wpi::util::Sendable,
   double MapSensorRange(double pos) const;
 
   std::shared_ptr<DutyCycle> m_dutyCycle;
-  wpi::units::hertz_t m_frequencyThreshold = {100_Hz};
+  wpi::units::hertz_t m_frequencyThreshold = 100_Hz;
   double m_fullRange;
   double m_expectedZero;
-  wpi::units::second_t m_period{0_s};
+  wpi::units::second_t m_period = 0_s;
   double m_sensorMin{0.0};
   double m_sensorMax{1.0};
   bool m_isInverted{false};
diff --git a/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp b/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp
index 8525923727..869ace9848 100644
--- a/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp
+++ b/wpimath/src/main/native/cpp/controller/ArmFeedforward.cpp
@@ -58,13 +58,13 @@ wpi::units::volt_t ArmFeedforward::Calculate(
   // Refine solution via Newton's method
   {
     auto xAD = u_k;
-    double x = xAD.value();
+    double x = xAD.value();  // non-unit .value()
 
     slp::Gradient gradientF{cost, xAD};
-    Eigen::SparseVector<double> g = gradientF.value();
+    Eigen::SparseVector<double> g = gradientF.value();  // non-unit .value()
 
     slp::Hessian hessianF{cost, xAD};
-    Eigen::SparseMatrix<double> H = hessianF.value();
+    Eigen::SparseMatrix<double> H = hessianF.value();  // non-unit .value()
 
     double error_k = std::numeric_limits<double>::infinity();
     double error_k1 = std::abs(g.coeff(0));
@@ -83,14 +83,14 @@ wpi::units::volt_t ArmFeedforward::Calculate(
 
       // Shrink step until cost goes down
       {
-        double oldCost = cost.value();
+        double oldCost = cost.value();  // non-unit .value()
 
         double α = 1.0;
         double trial_x = x + α * p_x;
 
         xAD.set_value(trial_x);
 
-        while (cost.value() > oldCost) {
+        while (cost.value() > oldCost) {  // non-unit .value()
           α *= 0.5;
           trial_x = x + α * p_x;
 
@@ -102,12 +102,12 @@ wpi::units::volt_t ArmFeedforward::Calculate(
 
       xAD.set_value(x);
 
-      g = gradientF.value();
-      H = hessianF.value();
+      g = gradientF.value();  // non-unit .value()
+      H = hessianF.value();   // non-unit .value()
 
       error_k1 = std::abs(g.coeff(0));
     }
   }
 
-  return wpi::units::volt_t{u_k.value()};
+  return wpi::units::volt_t{u_k.value()};  // non-unit .value()
 }
diff --git a/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp b/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp
index 6225530edd..5a176aacaf 100644
--- a/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp
+++ b/wpimath/src/main/native/cpp/controller/DifferentialDriveFeedforward.cpp
@@ -18,8 +18,8 @@ DifferentialDriveWheelVoltages DifferentialDriveFeedforward::Calculate(
     wpi::units::second_t dt) {
   wpi::math::LinearPlantInversionFeedforward<2, 2> feedforward{m_plant, dt};
 
-  Eigen::Vector2d r{currentLeftVelocity, currentRightVelocity};
-  Eigen::Vector2d nextR{nextLeftVelocity, nextRightVelocity};
+  Eigen::Vector2d r{currentLeftVelocity.value(), currentRightVelocity.value()};
+  Eigen::Vector2d nextR{nextLeftVelocity.value(), nextRightVelocity.value()};
   auto u = feedforward.Calculate(r, nextR);
   return {wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)}};
 }
diff --git a/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp b/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp
index 1cae86bbdf..f041f55c24 100644
--- a/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp
+++ b/wpimath/src/main/native/cpp/controller/LTVDifferentialDriveController.cpp
@@ -26,8 +26,8 @@ DifferentialDriveWheelVoltages LTVDifferentialDriveController::Calculate(
   //     [vₗ]
   //     [vᵣ]
 
-  wpi::units::meters_per_second_t velocity{(leftVelocity + rightVelocity) /
-                                           2.0};
+  wpi::units::meters_per_second_t velocity =
+      (leftVelocity + rightVelocity) / 2.0;
 
   // The DARE is ill-conditioned if the velocity is close to zero, so don't
   // let the system stop.
@@ -62,6 +62,7 @@ DifferentialDriveWheelVoltages LTVDifferentialDriveController::Calculate(
   Eigen::Matrix<double, 5, 2> discB;
   DiscretizeAB(A, B, m_dt, &discA, &discB);
 
+  // next line non-unit .value()
   auto S = DARE<5, 2>(discA, discB, m_Q, m_R, false).value();
 
   // K = (BᵀSB + R)⁻¹BᵀSA
diff --git a/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp b/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp
index 1820c9c23a..0c5a68b27a 100644
--- a/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp
+++ b/wpimath/src/main/native/cpp/controller/LTVUnicycleController.cpp
@@ -67,6 +67,7 @@ ChassisSpeeds LTVUnicycleController::Calculate(
   Eigen::Matrix<double, 3, 2> discB;
   DiscretizeAB(A, B, m_dt, &discA, &discB);
 
+  // next line non-unit .value()
   auto S = DARE<3, 2>(discA, discB, m_Q, m_R, false).value();
 
   // K = (BᵀSB + R)⁻¹BᵀSA
diff --git a/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp b/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp
index fc35f501c3..fe77767a39 100644
--- a/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp
+++ b/wpimath/src/main/native/cpp/geometry/Ellipse2d.cpp
@@ -41,7 +41,9 @@ Translation2d Ellipse2d::Nearest(const Translation2d& point) const {
 
     problem.solve();
 
+    // next line non-unit .value()
     rotPoint = wpi::math::Translation2d{wpi::units::meter_t{x.value()},
+                                        // next line non-unit .value()
                                         wpi::units::meter_t{y.value()}};
   }
 
diff --git a/wpimath/src/main/native/cpp/jni/DAREJNI.cpp b/wpimath/src/main/native/cpp/jni/DAREJNI.cpp
index 36ef6e6597..154d736f36 100644
--- a/wpimath/src/main/native/cpp/jni/DAREJNI.cpp
+++ b/wpimath/src/main/native/cpp/jni/DAREJNI.cpp
@@ -47,7 +47,7 @@ Java_org_wpilib_math_jni_DAREJNI_dareNoPrecondABQR
 
   auto result = wpi::math::DARE<Eigen::Dynamic, Eigen::Dynamic>(
                     Amat, Bmat, Qmat, Rmat, false)
-                    .value();
+                    .value();  // non-unit .value()
 
   env->SetDoubleArrayRegion(S, 0, states * states, result.data());
 }
@@ -86,7 +86,7 @@ Java_org_wpilib_math_jni_DAREJNI_dareNoPrecondABQRN
 
   auto result = wpi::math::DARE<Eigen::Dynamic, Eigen::Dynamic>(
                     Amat, Bmat, Qmat, Rmat, Nmat, false)
-                    .value();
+                    .value();  // non-unit .value()
 
   env->SetDoubleArrayRegion(S, 0, states * states, result.data());
 }
@@ -121,6 +121,7 @@ Java_org_wpilib_math_jni_DAREJNI_dareABQR
 
   if (auto result = wpi::math::DARE<Eigen::Dynamic, Eigen::Dynamic>(
           Amat, Bmat, Qmat, Rmat)) {
+    // next line non-unit .value()
     env->SetDoubleArrayRegion(S, 0, states * states, result.value().data());
     // K = (BᵀSB + R)⁻¹BᵀSA
   } else if (result.error() == wpi::math::DAREError::QNotSymmetric ||
@@ -174,6 +175,7 @@ Java_org_wpilib_math_jni_DAREJNI_dareABQRN
 
   if (auto result = wpi::math::DARE<Eigen::Dynamic, Eigen::Dynamic>(
           Amat, Bmat, Qmat, Rmat, Nmat)) {
+    // next line non-unit .value()
     env->SetDoubleArrayRegion(S, 0, states * states, result.value().data());
   } else if (result.error() == wpi::math::DAREError::QNotSymmetric ||
              result.error() == wpi::math::DAREError::QNotPositiveSemidefinite) {
diff --git a/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp b/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp
index bcc088f804..b7f615137e 100644
--- a/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp
+++ b/wpimath/src/main/native/cpp/trajectory/TrajectoryParameterizer.cpp
@@ -28,6 +28,7 @@
 
 #include "wpi/math/trajectory/TrajectoryParameterizer.hpp"
 
+#include <algorithm>
 #include <vector>
 
 #include <fmt/format.h>
@@ -66,7 +67,7 @@ Trajectory TrajectoryParameterizer::TimeParameterizeTrajectory(
       // Enforce global max velocity and max reachable velocity by global
       // acceleration limit. v_f = √(v_i² + 2ad).
 
-      constrainedState.maxVelocity = wpi::units::math::min(
+      constrainedState.maxVelocity = std::min(
           maxVelocity, wpi::units::math::sqrt(
                            predecessor.maxVelocity * predecessor.maxVelocity +
                            predecessor.maxAcceleration * ds * 2.0));
@@ -77,11 +78,11 @@ Trajectory TrajectoryParameterizer::TimeParameterizeTrajectory(
       // At this point, the constrained state is fully constructed apart from
       // all the custom-defined user constraints.
       for (const auto& constraint : constraints) {
-        constrainedState.maxVelocity = wpi::units::math::min(
-            constrainedState.maxVelocity,
-            constraint->MaxVelocity(constrainedState.pose.first,
-                                    constrainedState.pose.second,
-                                    constrainedState.maxVelocity));
+        constrainedState.maxVelocity =
+            std::min(constrainedState.maxVelocity,
+                     constraint->MaxVelocity(constrainedState.pose.first,
+                                             constrainedState.pose.second,
+                                             constrainedState.maxVelocity));
       }
 
       // Now enforce all acceleration limits.
@@ -230,12 +231,12 @@ void TrajectoryParameterizer::EnforceAccelerationLimits(
           "back one-by-one.");
     }
 
-    state->minAcceleration = wpi::units::math::max(
-        state->minAcceleration,
-        reverse ? -minMaxAccel.maxAcceleration : minMaxAccel.minAcceleration);
+    state->minAcceleration =
+        std::max(state->minAcceleration, reverse ? -minMaxAccel.maxAcceleration
+                                                 : minMaxAccel.minAcceleration);
 
-    state->maxAcceleration = wpi::units::math::min(
-        state->maxAcceleration,
-        reverse ? -minMaxAccel.minAcceleration : minMaxAccel.maxAcceleration);
+    state->maxAcceleration =
+        std::min(state->maxAcceleration, reverse ? -minMaxAccel.minAcceleration
+                                                 : minMaxAccel.maxAcceleration);
   }
 }
diff --git a/wpimath/src/main/native/include/wpi/math/controller/LinearQuadraticRegulator.hpp b/wpimath/src/main/native/include/wpi/math/controller/LinearQuadraticRegulator.hpp
index 2f53b06cda..b8103daea0 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/LinearQuadraticRegulator.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/LinearQuadraticRegulator.hpp
@@ -105,8 +105,9 @@ class LinearQuadraticRegulator {
 
     if (auto S = DARE<States, Inputs>(discA, discB, Q, R)) {
       // K = (BᵀSB + R)⁻¹BᵀSA
-      m_K = (discB.transpose() * S.value() * discB + R)
+      m_K = (discB.transpose() * S.value() * discB + R)  // non-unit .value()
                 .llt()
+                // next line non-unit .value()
                 .solve(discB.transpose() * S.value() * discA);
     } else if (S.error() == DAREError::QNotSymmetric ||
                S.error() == DAREError::QNotPositiveSemidefinite) {
@@ -160,8 +161,9 @@ class LinearQuadraticRegulator {
 
     if (auto S = DARE<States, Inputs>(discA, discB, Q, R, N)) {
       // K = (BᵀSB + R)⁻¹(BᵀSA + Nᵀ)
-      m_K = (discB.transpose() * S.value() * discB + R)
+      m_K = (discB.transpose() * S.value() * discB + R)  // non-unit .value()
                 .llt()
+                // next line non-unit .value()
                 .solve(discB.transpose() * S.value() * discA + N.transpose());
     } else if (S.error() == DAREError::QNotSymmetric ||
                S.error() == DAREError::QNotPositiveSemidefinite) {
@@ -297,7 +299,7 @@ class LinearQuadraticRegulator {
     Matrixd<States, Inputs> discB;
     DiscretizeAB<States, Inputs>(plant.A(), plant.B(), dt, &discA, &discB);
 
-    m_K = m_K * (discA - discB * m_K).pow(inputDelay / dt);
+    m_K = m_K * (discA - discB * m_K).pow(double{inputDelay / dt});
   }
 
  private:
diff --git a/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp b/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp
index c43e0300cc..851a66d138 100644
--- a/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp
+++ b/wpimath/src/main/native/include/wpi/math/controller/struct/SimpleMotorFeedforwardStruct.hpp
@@ -69,6 +69,6 @@ struct wpi::util::Struct<wpi::math::SimpleMotorFeedforward<Distance>> {
 static_assert(wpi::util::StructSerializable<
               wpi::math::SimpleMotorFeedforward<wpi::units::meters>>);
 static_assert(wpi::util::StructSerializable<
-              wpi::math::SimpleMotorFeedforward<wpi::units::feet>>);
+              wpi::math::SimpleMotorFeedforward<wpi::units::centimeters>>);
 static_assert(wpi::util::StructSerializable<
               wpi::math::SimpleMotorFeedforward<wpi::units::radians>>);
diff --git a/wpimath/src/main/native/include/wpi/math/estimator/ExtendedKalmanFilter.hpp b/wpimath/src/main/native/include/wpi/math/estimator/ExtendedKalmanFilter.hpp
index 15a69198e1..3aecf216ff 100644
--- a/wpimath/src/main/native/include/wpi/math/estimator/ExtendedKalmanFilter.hpp
+++ b/wpimath/src/main/native/include/wpi/math/estimator/ExtendedKalmanFilter.hpp
@@ -104,7 +104,7 @@ class ExtendedKalmanFilter {
     if (IsDetectable<States, Outputs>(discA, C) && Outputs <= States) {
       if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(),
                                          discQ, discR)) {
-        m_initP = P.value();
+        m_initP = P.value();  // non-unit .value()
       } else if (P.error() == DAREError::QNotSymmetric ||
                  P.error() == DAREError::QNotPositiveSemidefinite) {
         std::string msg =
@@ -188,7 +188,7 @@ class ExtendedKalmanFilter {
     if (IsDetectable<States, Outputs>(discA, C) && Outputs <= States) {
       if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(),
                                          discQ, discR)) {
-        m_initP = P.value();
+        m_initP = P.value();  // non-unit .value()
       } else if (P.error() == DAREError::QNotSymmetric ||
                  P.error() == DAREError::QNotPositiveSemidefinite) {
         std::string msg =
diff --git a/wpimath/src/main/native/include/wpi/math/estimator/KalmanFilter.hpp b/wpimath/src/main/native/include/wpi/math/estimator/KalmanFilter.hpp
index 94a1dbf70d..c63e4bdff4 100644
--- a/wpimath/src/main/native/include/wpi/math/estimator/KalmanFilter.hpp
+++ b/wpimath/src/main/native/include/wpi/math/estimator/KalmanFilter.hpp
@@ -87,7 +87,7 @@ class KalmanFilter {
 
     if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(), discQ,
                                        discR)) {
-      m_initP = P.value();
+      m_initP = P.value();  // non-unit .value()
     } else if (P.error() == DAREError::QNotSymmetric ||
                P.error() == DAREError::QNotPositiveSemidefinite) {
       std::string msg =
diff --git a/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator.hpp b/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator.hpp
index 3e7e98367a..24e991d3c7 100644
--- a/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator.hpp
+++ b/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator.hpp
@@ -264,6 +264,7 @@ class WPILIB_DLLEXPORT PoseEstimator {
 
     // Step 4: Measure the transform between the old pose estimate and the
     // vision transform.
+    // next line non-unit .value()
     auto transform = visionRobotPose - visionSample.value();
 
     // Step 5: We should not trust the transform entirely, so instead we scale
diff --git a/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator3d.hpp b/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator3d.hpp
index 29bd3f3be7..089718adbc 100644
--- a/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator3d.hpp
+++ b/wpimath/src/main/native/include/wpi/math/estimator/PoseEstimator3d.hpp
@@ -273,6 +273,7 @@ class WPILIB_DLLEXPORT PoseEstimator3d {
 
     // Step 4: Measure the transform between the old pose estimate and the
     // vision pose.
+    // next line non-unit .value()
     auto transform = visionRobotPose - visionSample.value();
 
     // Step 5: We should not trust the transform entirely, so instead we scale
diff --git a/wpimath/src/main/native/include/wpi/math/estimator/SteadyStateKalmanFilter.hpp b/wpimath/src/main/native/include/wpi/math/estimator/SteadyStateKalmanFilter.hpp
index d692ac8dda..c8bb3b58f1 100644
--- a/wpimath/src/main/native/include/wpi/math/estimator/SteadyStateKalmanFilter.hpp
+++ b/wpimath/src/main/native/include/wpi/math/estimator/SteadyStateKalmanFilter.hpp
@@ -100,6 +100,7 @@ class SteadyStateKalmanFilter {
     if (auto P = DARE<States, Outputs>(discA.transpose(), C.transpose(), discQ,
                                        discR)) {
       // S = CPCᵀ + R
+      // next line non-unit .value()
       Matrixd<Outputs, Outputs> S = C * P.value() * C.transpose() + discR;
 
       // We want to put K = PCᵀS⁻¹ into Ax = b form so we can solve it more
@@ -118,7 +119,7 @@ class SteadyStateKalmanFilter {
       // Drop the transposes on symmetric matrices S and P.
       //
       // K = (S.solve(CP))ᵀ
-      m_K = S.ldlt().solve(C * P.value()).transpose();
+      m_K = S.ldlt().solve(C * P.value()).transpose();  // non-unit .value()
     } else if (P.error() == DAREError::QNotSymmetric ||
                P.error() == DAREError::QNotPositiveSemidefinite) {
       std::string msg =
diff --git a/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp b/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp
index abe1017fd5..267a50e59e 100644
--- a/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp
+++ b/wpimath/src/main/native/include/wpi/math/filter/SlewRateLimiter.hpp
@@ -45,8 +45,7 @@ class SlewRateLimiter {
       : m_positiveRateLimit{positiveRateLimit},
         m_negativeRateLimit{negativeRateLimit},
         m_prevVal{initialValue},
-        m_prevTime{wpi::units::microsecond_t{
-            wpi::math::MathSharedStore::GetTimestamp()}} {}
+        m_prevTime{wpi::math::MathSharedStore::GetTimestamp()} {}
 
   /**
    * Creates a new SlewRateLimiter with the given positive rate limit and
diff --git a/wpimath/src/main/native/include/wpi/math/geometry/Ellipse2d.hpp b/wpimath/src/main/native/include/wpi/math/geometry/Ellipse2d.hpp
index 6f9a5a4653..3606aab44c 100644
--- a/wpimath/src/main/native/include/wpi/math/geometry/Ellipse2d.hpp
+++ b/wpimath/src/main/native/include/wpi/math/geometry/Ellipse2d.hpp
@@ -4,6 +4,7 @@
 
 #pragma once
 
+#include <algorithm>
 #include <stdexcept>
 
 #include <gcem.hpp>
@@ -49,8 +50,8 @@ class WPILIB_DLLEXPORT Ellipse2d {
    */
   constexpr Ellipse2d(const Translation2d& center, double radius)
       : m_center{center, Rotation2d{}},
-        m_xSemiAxis{radius},
-        m_ySemiAxis{radius} {}
+        m_xSemiAxis{wpi::units::meter_t{radius}},
+        m_ySemiAxis{wpi::units::meter_t{radius}} {}
 
   /**
    * Returns the center of the ellipse.
@@ -88,10 +89,10 @@ class WPILIB_DLLEXPORT Ellipse2d {
    */
   constexpr wpi::util::array<Translation2d, 2> FocalPoints() const {
     // Major semi-axis
-    auto a = wpi::units::math::max(m_xSemiAxis, m_ySemiAxis);
+    auto a = std::max(m_xSemiAxis, m_ySemiAxis);
 
     // Minor semi-axis
-    auto b = wpi::units::math::min(m_xSemiAxis, m_ySemiAxis);
+    auto b = std::min(m_xSemiAxis, m_ySemiAxis);
 
     auto c = wpi::units::math::sqrt(a * a - b * b);
 
@@ -204,9 +205,9 @@ class WPILIB_DLLEXPORT Ellipse2d {
     auto y = rotPoint.Y() - m_center.Y();
 
     // NOLINTNEXTLINE (bugprone-integer-division)
-    return (x * x) / (m_xSemiAxis * m_xSemiAxis) +
-           // NOLINTNEXTLINE (bugprone-integer-division)
-           (y * y) / (m_ySemiAxis * m_ySemiAxis);
+    return double{(x * x) / (m_xSemiAxis * m_xSemiAxis) +
+                  // NOLINTNEXTLINE (bugprone-integer-division)
+                  (y * y) / (m_ySemiAxis * m_ySemiAxis)};
   }
 };
 
diff --git a/wpimath/src/main/native/include/wpi/math/geometry/Rotation2d.hpp b/wpimath/src/main/native/include/wpi/math/geometry/Rotation2d.hpp
index d4897bc93d..84029a507b 100644
--- a/wpimath/src/main/native/include/wpi/math/geometry/Rotation2d.hpp
+++ b/wpimath/src/main/native/include/wpi/math/geometry/Rotation2d.hpp
@@ -36,9 +36,8 @@ class WPILIB_DLLEXPORT Rotation2d {
    * @param value The value of the angle.
    */
   constexpr Rotation2d(wpi::units::angle_unit auto value)  // NOLINT
-      : m_cos{gcem::cos(value.template convert<wpi::units::radian>().value())},
-        m_sin{gcem::sin(value.template convert<wpi::units::radian>().value())} {
-  }
+      : m_cos{gcem::cos(wpi::units::radian_t{value}.value())},
+        m_sin{gcem::sin(wpi::units::radian_t{value}.value())} {}
 
   /**
    * Constructs a Rotation2d with the given x and y (cosine and sine)
diff --git a/wpimath/src/main/native/include/wpi/math/interpolation/TimeInterpolatableBuffer.hpp b/wpimath/src/main/native/include/wpi/math/interpolation/TimeInterpolatableBuffer.hpp
index bb6f328b30..daf3f8f84e 100644
--- a/wpimath/src/main/native/include/wpi/math/interpolation/TimeInterpolatableBuffer.hpp
+++ b/wpimath/src/main/native/include/wpi/math/interpolation/TimeInterpolatableBuffer.hpp
@@ -128,8 +128,8 @@ class TimeInterpolatableBuffer {
 
     auto lower_bound = upper_bound - 1;
 
-    double t = ((time - lower_bound->first) /
-                (upper_bound->first - lower_bound->first));
+    double t = double{((time - lower_bound->first) /
+                       (upper_bound->first - lower_bound->first))};
 
     return m_interpolatingFunc(lower_bound->second, upper_bound->second, t);
   }
diff --git a/wpimath/src/main/native/include/wpi/math/kinematics/DifferentialDriveWheelSpeeds.hpp b/wpimath/src/main/native/include/wpi/math/kinematics/DifferentialDriveWheelSpeeds.hpp
index b0d25b317e..03f7c90b92 100644
--- a/wpimath/src/main/native/include/wpi/math/kinematics/DifferentialDriveWheelSpeeds.hpp
+++ b/wpimath/src/main/native/include/wpi/math/kinematics/DifferentialDriveWheelSpeeds.hpp
@@ -4,6 +4,8 @@
 
 #pragma once
 
+#include <algorithm>
+
 #include "wpi/units/math.hpp"
 #include "wpi/units/velocity.hpp"
 #include "wpi/util/SymbolExports.hpp"
@@ -37,8 +39,8 @@ struct WPILIB_DLLEXPORT DifferentialDriveWheelSpeeds {
    */
   constexpr void Desaturate(
       wpi::units::meters_per_second_t attainableMaxSpeed) {
-    auto realMaxSpeed = wpi::units::math::max(wpi::units::math::abs(left),
-                                              wpi::units::math::abs(right));
+    auto realMaxSpeed =
+        std::max(wpi::units::math::abs(left), wpi::units::math::abs(right));
 
     if (realMaxSpeed > attainableMaxSpeed) {
       left = left / realMaxSpeed * attainableMaxSpeed;
diff --git a/wpimath/src/main/native/include/wpi/math/kinematics/SwerveDriveKinematics.hpp b/wpimath/src/main/native/include/wpi/math/kinematics/SwerveDriveKinematics.hpp
index 0d347b2509..4da1afb467 100644
--- a/wpimath/src/main/native/include/wpi/math/kinematics/SwerveDriveKinematics.hpp
+++ b/wpimath/src/main/native/include/wpi/math/kinematics/SwerveDriveKinematics.hpp
@@ -190,8 +190,10 @@ class SwerveDriveKinematics
         m_inverseKinematics * chassisSpeedsVector;
 
     for (size_t i = 0; i < NumModules; i++) {
-      wpi::units::meters_per_second_t x{moduleStateMatrix(i * 2, 0)};
-      wpi::units::meters_per_second_t y{moduleStateMatrix(i * 2 + 1, 0)};
+      wpi::units::meters_per_second_t x =
+          wpi::units::meters_per_second_t{moduleStateMatrix(i * 2, 0)};
+      wpi::units::meters_per_second_t y =
+          wpi::units::meters_per_second_t{moduleStateMatrix(i * 2 + 1, 0)};
 
       auto speed = wpi::units::math::hypot(x, y);
       auto rotation = speed > 1e-6_mps ? Rotation2d{x.value(), y.value()}
@@ -420,10 +422,10 @@ class SwerveDriveKinematics
     auto rotationalK = wpi::units::math::abs(desiredChassisSpeed.omega) /
                        attainableMaxRobotRotationSpeed;
 
-    auto k = wpi::units::math::max(translationalK, rotationalK);
+    auto k = std::max(translationalK, rotationalK);
 
-    auto scale = wpi::units::math::min(
-        k * attainableMaxModuleSpeed / realMaxSpeed, wpi::units::scalar_t{1});
+    auto scale = std::min(k * attainableMaxModuleSpeed / realMaxSpeed,
+                          wpi::units::scalar_t{1});
     for (auto& module : states) {
       module.speed = module.speed * scale;
     }
diff --git a/wpimath/src/main/native/include/wpi/math/spline/SplineParameterizer.hpp b/wpimath/src/main/native/include/wpi/math/spline/SplineParameterizer.hpp
index 7adab5952b..782fc04dd0 100644
--- a/wpimath/src/main/native/include/wpi/math/spline/SplineParameterizer.hpp
+++ b/wpimath/src/main/native/include/wpi/math/spline/SplineParameterizer.hpp
@@ -79,7 +79,7 @@ class WPILIB_DLLEXPORT SplineParameterizer {
 
     // The parameterization does not add the initial point. Let's add that.
     if (auto point = spline.GetPoint(t0)) {
-      splinePoints.push_back(point.value());
+      splinePoints.push_back(point.value());  // non-unit .value()
     } else {
       throw MalformedSplineException(kMalformedSplineExceptionMsg);
     }
@@ -105,6 +105,7 @@ class WPILIB_DLLEXPORT SplineParameterizer {
         throw MalformedSplineException(kMalformedSplineExceptionMsg);
       }
 
+      // next line non-unit .value()
       const auto twist = (end.value().first - start.value().first).Log();
 
       if (wpi::units::math::abs(twist.dy) > kMaxDy ||
@@ -113,7 +114,7 @@ class WPILIB_DLLEXPORT SplineParameterizer {
         stack.emplace(StackContents{(current.t0 + current.t1) / 2, current.t1});
         stack.emplace(StackContents{current.t0, (current.t0 + current.t1) / 2});
       } else {
-        splinePoints.push_back(end.value());
+        splinePoints.push_back(end.value());  // non-unit .value()
       }
 
       if (iterations++ >= kMaxIterations) {
diff --git a/wpimath/src/main/native/include/wpi/math/trajectory/Trajectory.hpp b/wpimath/src/main/native/include/wpi/math/trajectory/Trajectory.hpp
index 37145cd062..e6dfafa21e 100644
--- a/wpimath/src/main/native/include/wpi/math/trajectory/Trajectory.hpp
+++ b/wpimath/src/main/native/include/wpi/math/trajectory/Trajectory.hpp
@@ -44,7 +44,7 @@ class WPILIB_DLLEXPORT Trajectory {
     Pose2d pose;
 
     /// The curvature at that point of the trajectory.
-    wpi::units::curvature_t curvature{0.0};
+    wpi::units::curvature_t curvature = wpi::units::curvature_t{0.0};
 
     /**
      * Checks equality between this State and another object.
@@ -94,7 +94,8 @@ class WPILIB_DLLEXPORT Trajectory {
       // distance between the two endpoints.
       const double interpolationFrac =
           // NOLINTNEXTLINE (bugprone-integer-division)
-          newS / endValue.pose.Translation().Distance(pose.Translation());
+          double{newS /
+                 endValue.pose.Translation().Distance(pose.Translation())};
 
       return {
           newT, newV, acceleration,
@@ -172,7 +173,7 @@ class WPILIB_DLLEXPORT Trajectory {
     }
     // Interpolate between the two states for the state that we want.
     return prevSample->Interpolate(
-        *sample, (t - prevSample->t) / (sample->t - prevSample->t));
+        *sample, double{(t - prevSample->t) / (sample->t - prevSample->t)});
   }
 
   /**
diff --git a/wpimath/src/main/native/include/wpi/math/trajectory/TrajectoryGenerator.hpp b/wpimath/src/main/native/include/wpi/math/trajectory/TrajectoryGenerator.hpp
index 5e7ea6ead3..05d37feea4 100644
--- a/wpimath/src/main/native/include/wpi/math/trajectory/TrajectoryGenerator.hpp
+++ b/wpimath/src/main/native/include/wpi/math/trajectory/TrajectoryGenerator.hpp
@@ -98,6 +98,7 @@ class WPILIB_DLLEXPORT TrajectoryGenerator {
     std::vector<PoseWithCurvature> splinePoints;
 
     // Add the first point to the vector.
+    // next line non-unit .value()
     splinePoints.push_back(splines.front().GetPoint(0.0).value());
 
     // Iterate through the vector and parameterize each spline, adding the
diff --git a/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp b/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp
index 27eb091564..788f85de47 100644
--- a/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp
+++ b/wpimath/src/main/native/include/wpi/math/trajectory/TrapezoidProfile.hpp
@@ -4,6 +4,7 @@
 
 #pragma once
 
+#include <algorithm>
 #include <type_traits>
 
 #include "wpi/math/util/MathShared.hpp"
@@ -222,8 +223,8 @@ class TrapezoidProfile {
       velocity *= -1.0;
     }
 
-    endAccel = wpi::units::math::max(endAccel, 0_s);
-    endFullSpeed = wpi::units::math::max(endFullSpeed, 0_s);
+    endAccel = std::max(endAccel, 0_s);
+    endFullSpeed = std::max(endFullSpeed, 0_s);
 
     const Acceleration_t acceleration = m_constraints.maxAcceleration;
     const Acceleration_t deceleration = -m_constraints.maxAcceleration;
diff --git a/wpimath/src/main/native/include/wpi/math/trajectory/constraint/TrajectoryConstraint.hpp b/wpimath/src/main/native/include/wpi/math/trajectory/constraint/TrajectoryConstraint.hpp
index d39cf3650f..92c0ce5174 100644
--- a/wpimath/src/main/native/include/wpi/math/trajectory/constraint/TrajectoryConstraint.hpp
+++ b/wpimath/src/main/native/include/wpi/math/trajectory/constraint/TrajectoryConstraint.hpp
@@ -37,14 +37,16 @@ class WPILIB_DLLEXPORT TrajectoryConstraint {
     /**
      * The minimum acceleration.
      */
-    wpi::units::meters_per_second_squared_t minAcceleration{
-        -std::numeric_limits<double>::max()};
+    wpi::units::meters_per_second_squared_t minAcceleration =
+        wpi::units::meters_per_second_squared_t{
+            -std::numeric_limits<double>::max()};
 
     /**
      * The maximum acceleration.
      */
-    wpi::units::meters_per_second_squared_t maxAcceleration{
-        std::numeric_limits<double>::max()};
+    wpi::units::meters_per_second_squared_t maxAcceleration =
+        wpi::units::meters_per_second_squared_t{
+            std::numeric_limits<double>::max()};
   };
 
   /**
diff --git a/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp b/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp
index 40aa51cdea..c398dffd9c 100644
--- a/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp
+++ b/wpimath/src/main/native/include/wpi/math/util/MathUtil.hpp
@@ -206,11 +206,11 @@ constexpr T InputModulus(T input, T minimumInput, T maximumInput) {
   T modulus = maximumInput - minimumInput;
 
   // Wrap input if it's above the maximum input
-  int numMax = (input - minimumInput) / modulus;
+  int numMax = static_cast<int>((input - minimumInput) / modulus);
   input -= numMax * modulus;
 
   // Wrap input if it's below the minimum input
-  int numMin = (input - maximumInput) / modulus;
+  int numMin = static_cast<int>((input - maximumInput) / modulus);
   input -= numMin * modulus;
 
   return input;
@@ -344,7 +344,7 @@ constexpr Translation2d SlewRateLimit(
   if (dist > maxVelocity * dt) {
     // Move maximum allowed amount in direction of the difference
     // NOLINTNEXTLINE(bugprone-integer-division)
-    return current + diff * (maxVelocity * dt / dist);
+    return current + diff * double{maxVelocity * dt / dist};
   }
   return next;
 }
@@ -374,7 +374,7 @@ constexpr Translation3d SlewRateLimit(
   if (dist > maxVelocity * dt) {
     // Move maximum allowed amount in direction of the difference
     // NOLINTNEXTLINE(bugprone-integer-division)
-    return current + diff * (maxVelocity * dt / dist);
+    return current + diff * double{maxVelocity * dt / dist};
   }
   return next;
 }
diff --git a/wpimath/src/test/native/cpp/DARETest.cpp b/wpimath/src/test/native/cpp/DARETest.cpp
index 9ed2af0de9..a53f3c8a9d 100644
--- a/wpimath/src/test/native/cpp/DARETest.cpp
+++ b/wpimath/src/test/native/cpp/DARETest.cpp
@@ -157,7 +157,7 @@ TEST(DARETest, NonInvertibleA_ABQR) {
 
   auto ret = wpi::math::DARE<4, 1>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -183,7 +183,7 @@ TEST(DARETest, NonInvertibleA_ABQRN) {
 
   auto ret = wpi::math::DARE<4, 1>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -198,7 +198,7 @@ TEST(DARETest, InvertibleA_ABQR) {
 
   auto ret = wpi::math::DARE<2, 1>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -218,7 +218,7 @@ TEST(DARETest, InvertibleA_ABQRN) {
 
   auto ret = wpi::math::DARE<2, 1>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -235,7 +235,7 @@ TEST(DARETest, FirstGeneralizedEigenvalueOfSTIsStable_ABQR) {
 
   auto ret = wpi::math::DARE<2, 1>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -257,7 +257,7 @@ TEST(DARETest, FirstGeneralizedEigenvalueOfSTIsStable_ABQRN) {
 
   auto ret = wpi::math::DARE<2, 1>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -272,7 +272,7 @@ TEST(DARETest, IdentitySystem_ABQR) {
 
   auto ret = wpi::math::DARE<2, 2>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -288,7 +288,7 @@ TEST(DARETest, IdentitySystem_ABQRN) {
 
   auto ret = wpi::math::DARE<2, 2>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -303,7 +303,7 @@ TEST(DARETest, MoreInputsThanStates_ABQR) {
 
   auto ret = wpi::math::DARE<2, 3>(A, B, Q, R);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
@@ -319,7 +319,7 @@ TEST(DARETest, MoreInputsThanStates_ABQRN) {
 
   auto ret = wpi::math::DARE<2, 3>(A, B, Q, R, N);
   EXPECT_TRUE(ret);
-  auto X = ret.value();
+  auto X = ret.value();  // non-unit .value()
 
   ExpectMatrixEqual(X, X.transpose(), 1e-10);
   ExpectPositiveSemidefinite(X);
diff --git a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
index f30ababa58..9df3feb752 100644
--- a/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/DifferentialDriveAccelerationLimiterTest.cpp
@@ -32,14 +32,16 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
   {
     Vectord<2> accels =
         plant.A() * xAccelLimiter + plant.B() * Vectord<2>{12.0, 12.0};
-    wpi::units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+    wpi::units::meters_per_second_squared_t a =
+        wpi::units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GT(wpi::units::math::abs(a), maxA);
   }
   {
     Vectord<2> accels =
         plant.A() * xAccelLimiter + plant.B() * Vectord<2>{-12.0, 12.0};
-    wpi::units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
-                                                   trackwidth.value()};
+    wpi::units::radians_per_second_squared_t alpha =
+        wpi::units::radians_per_second_squared_t{(accels(1) - accels(0)) /
+                                                 trackwidth.value()};
     EXPECT_GT(wpi::units::math::abs(alpha), maxAlpha);
   }
 
@@ -51,14 +53,16 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
-
-    Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    wpi::units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
-    wpi::units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
-                                                   trackwidth.value()};
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
+
+    Vectord<2> accels = plant.A() * xAccelLimiter +
+                        plant.B() * Vectord<2>{left.value(), right.value()};
+    wpi::units::meters_per_second_squared_t a =
+        wpi::units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
+    wpi::units::radians_per_second_squared_t alpha =
+        wpi::units::radians_per_second_squared_t{(accels(1) - accels(0)) /
+                                                 trackwidth.value()};
     EXPECT_LE(wpi::units::math::abs(a), maxA);
     EXPECT_LE(wpi::units::math::abs(alpha), maxAlpha);
   }
@@ -71,14 +75,16 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
-
-    Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    wpi::units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
-    wpi::units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
-                                                   trackwidth.value()};
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
+
+    Vectord<2> accels = plant.A() * xAccelLimiter +
+                        plant.B() * Vectord<2>{left.value(), right.value()};
+    wpi::units::meters_per_second_squared_t a =
+        wpi::units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
+    wpi::units::radians_per_second_squared_t alpha =
+        wpi::units::radians_per_second_squared_t{(accels(1) - accels(0)) /
+                                                 trackwidth.value()};
     EXPECT_LE(wpi::units::math::abs(a), maxA);
     EXPECT_LE(wpi::units::math::abs(alpha), maxAlpha);
   }
@@ -91,14 +97,16 @@ TEST(DifferentialDriveAccelerationLimiterTest, LowLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
-
-    Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    wpi::units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
-    wpi::units::radians_per_second_squared_t alpha{(accels(1) - accels(0)) /
-                                                   trackwidth.value()};
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
+
+    Vectord<2> accels = plant.A() * xAccelLimiter +
+                        plant.B() * Vectord<2>{left.value(), right.value()};
+    wpi::units::meters_per_second_squared_t a =
+        wpi::units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
+    wpi::units::radians_per_second_squared_t alpha =
+        wpi::units::radians_per_second_squared_t{(accels(1) - accels(0)) /
+                                                 trackwidth.value()};
     EXPECT_LE(wpi::units::math::abs(a), maxA);
     EXPECT_LE(wpi::units::math::abs(alpha), maxAlpha);
   }
@@ -130,8 +138,8 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     EXPECT_DOUBLE_EQ(x(0), xAccelLimiter(0));
     EXPECT_DOUBLE_EQ(x(1), xAccelLimiter(1));
@@ -147,8 +155,8 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     EXPECT_DOUBLE_EQ(x(0), xAccelLimiter(0));
     EXPECT_DOUBLE_EQ(x(1), xAccelLimiter(1));
@@ -164,8 +172,8 @@ TEST(DifferentialDriveAccelerationLimiterTest, HighLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
     EXPECT_DOUBLE_EQ(x(0), xAccelLimiter(0));
     EXPECT_DOUBLE_EQ(x(1), xAccelLimiter(1));
@@ -194,7 +202,8 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
   {
     Vectord<2> accels =
         plant.A() * xAccelLimiter + plant.B() * Vectord<2>{12.0, 12.0};
-    wpi::units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+    wpi::units::meters_per_second_squared_t a =
+        wpi::units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GT(wpi::units::math::abs(a), maxA);
     EXPECT_GT(wpi::units::math::abs(a), -minA);
   }
@@ -208,12 +217,13 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
-    Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    wpi::units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+    Vectord<2> accels = plant.A() * xAccelLimiter +
+                        plant.B() * Vectord<2>{left.value(), right.value()};
+    wpi::units::meters_per_second_squared_t a =
+        wpi::units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GE(a, minA);
     EXPECT_LE(a, maxA);
   }
@@ -226,12 +236,13 @@ TEST(DifferentialDriveAccelerationLimiterTest, SeparateMinMaxLowLimits) {
         wpi::units::meters_per_second_t{xAccelLimiter(0)},
         wpi::units::meters_per_second_t{xAccelLimiter(1)},
         wpi::units::volt_t{u(0)}, wpi::units::volt_t{u(1)});
-    xAccelLimiter =
-        plant.CalculateX(xAccelLimiter, Vectord<2>{left, right}, dt);
+    xAccelLimiter = plant.CalculateX(
+        xAccelLimiter, Vectord<2>{left.value(), right.value()}, dt);
 
-    Vectord<2> accels =
-        plant.A() * xAccelLimiter + plant.B() * Vectord<2>{left, right};
-    wpi::units::meters_per_second_squared_t a{(accels(0) + accels(1)) / 2.0};
+    Vectord<2> accels = plant.A() * xAccelLimiter +
+                        plant.B() * Vectord<2>{left.value(), right.value()};
+    wpi::units::meters_per_second_squared_t a =
+        wpi::units::meters_per_second_squared_t{(accels(0) + accels(1)) / 2.0};
     EXPECT_GE(a, minA);
     EXPECT_LE(a, maxA);
   }
diff --git a/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp b/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp
index ef481e1f97..abe7aa3f56 100644
--- a/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/DifferentialDriveFeedforwardTest.cpp
@@ -40,8 +40,9 @@ TEST(DifferentialDriveFeedforwardTest, CalculateWithTrackwidth) {
               currentLeftVelocity, nextLeftVelocity, currentRightVelocity,
               nextRightVelocity, dt);
           Eigen::Vector2d nextX = plant.CalculateX(
-              Eigen::Vector2d{currentLeftVelocity, currentRightVelocity},
-              Eigen::Vector2d{left, right}, dt);
+              Eigen::Vector2d{currentLeftVelocity.value(),
+                              currentRightVelocity.value()},
+              Eigen::Vector2d{left.value(), right.value()}, dt);
           EXPECT_NEAR(nextX(0), nextLeftVelocity.value(), 1e-6);
           EXPECT_NEAR(nextX(1), nextRightVelocity.value(), 1e-6);
         }
@@ -74,8 +75,9 @@ TEST(DifferentialDriveFeedforwardTest, CalculateWithoutTrackwidth) {
               currentLeftVelocity, nextLeftVelocity, currentRightVelocity,
               nextRightVelocity, dt);
           Eigen::Vector2d nextX = plant.CalculateX(
-              Eigen::Vector2d{currentLeftVelocity, currentRightVelocity},
-              Eigen::Vector2d{left, right}, dt);
+              Eigen::Vector2d{currentLeftVelocity.value(),
+                              currentRightVelocity.value()},
+              Eigen::Vector2d{left.value(), right.value()}, dt);
           EXPECT_NEAR(nextX(0), nextLeftVelocity.value(), 1e-6);
           EXPECT_NEAR(nextX(1), nextRightVelocity.value(), 1e-6);
         }
diff --git a/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp b/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp
index a9161790c1..7f76b14c84 100644
--- a/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/LTVDifferentialDriveControllerTest.cpp
@@ -17,9 +17,9 @@
 #define EXPECT_NEAR_UNITS(val1, val2, eps) \
   EXPECT_LE(wpi::units::math::abs(val1 - val2), eps)
 
-static constexpr wpi::units::meter_t kTolerance{1 / 12.0};
-static constexpr wpi::units::radian_t kAngularTolerance{2.0 * std::numbers::pi /
-                                                        180.0};
+static constexpr wpi::units::meter_t kTolerance = wpi::units::meter_t{1 / 12.0};
+static constexpr wpi::units::radian_t kAngularTolerance =
+    wpi::units::radian_t{2.0 * std::numbers::pi / 180.0};
 
 /**
  * States of the drivetrain system.
diff --git a/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp b/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp
index 51f8a9a977..1431c43ec0 100644
--- a/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/LTVUnicycleControllerTest.cpp
@@ -13,9 +13,9 @@
 #define EXPECT_NEAR_UNITS(val1, val2, eps) \
   EXPECT_LE(wpi::units::math::abs(val1 - val2), eps)
 
-static constexpr wpi::units::meter_t kTolerance{1 / 12.0};
-static constexpr wpi::units::radian_t kAngularTolerance{2.0 * std::numbers::pi /
-                                                        180.0};
+static constexpr wpi::units::meter_t kTolerance = wpi::units::meter_t{1 / 12.0};
+static constexpr wpi::units::radian_t kAngularTolerance =
+    wpi::units::radian_t{2.0 * std::numbers::pi / 180.0};
 
 TEST(LTVUnicycleControllerTest, ReachesReference) {
   constexpr wpi::units::second_t kDt = 20_ms;
diff --git a/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp b/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp
index aa0fb9a227..49f17f4123 100644
--- a/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/PIDInputOutputTest.cpp
@@ -46,8 +46,9 @@ TEST(PIDInputOutputTest, DerivativeGainOutput) {
 
   controller.Calculate(0, 0);
 
-  EXPECT_DOUBLE_EQ(-10_ms / controller.GetPeriod(),
-                   controller.Calculate(0.0025, 0));
+  EXPECT_DOUBLE_EQ(
+      double{wpi::units::second_t{-10_ms} / controller.GetPeriod()},
+      controller.Calculate(0.0025, 0));
 }
 
 TEST(PIDInputOutputTest, IZoneNoOutput) {
diff --git a/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp b/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp
index a1fdd7400b..8f6a1a8f02 100644
--- a/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/ProfiledPIDInputOutputTest.cpp
@@ -18,9 +18,11 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput1) {
   controller.SetP(1);
   controller.EnableContinuousInput(-180_deg, 180_deg);
 
-  static constexpr wpi::units::degree_t kSetpoint{-179.0};
-  static constexpr wpi::units::degree_t kMeasurement{-179.0};
-  static constexpr wpi::units::degree_t kGoal{179.0};
+  static constexpr wpi::units::degree_t kSetpoint =
+      wpi::units::degree_t{-179.0};
+  static constexpr wpi::units::degree_t kMeasurement =
+      wpi::units::degree_t{-179.0};
+  static constexpr wpi::units::degree_t kGoal = wpi::units::degree_t{179.0};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -39,9 +41,12 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput2) {
   controller.EnableContinuousInput(-wpi::units::radian_t{std::numbers::pi},
                                    wpi::units::radian_t{std::numbers::pi});
 
-  static constexpr wpi::units::radian_t kSetpoint{-3.4826633343199735};
-  static constexpr wpi::units::radian_t kMeasurement{-3.1352207333939606};
-  static constexpr wpi::units::radian_t kGoal{-3.534162788601621};
+  static constexpr wpi::units::radian_t kSetpoint =
+      wpi::units::degree_t{-3.4826633343199735};
+  static constexpr wpi::units::radian_t kMeasurement =
+      wpi::units::degree_t{-3.1352207333939606};
+  static constexpr wpi::units::radian_t kGoal =
+      wpi::units::degree_t{-3.534162788601621};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -60,9 +65,12 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput3) {
   controller.EnableContinuousInput(-wpi::units::radian_t{std::numbers::pi},
                                    wpi::units::radian_t{std::numbers::pi});
 
-  static constexpr wpi::units::radian_t kSetpoint{-3.5176604690006377};
-  static constexpr wpi::units::radian_t kMeasurement{3.1191729343822456};
-  static constexpr wpi::units::radian_t kGoal{2.709680418117445};
+  static constexpr wpi::units::radian_t kSetpoint =
+      wpi::units::degree_t{-3.5176604690006377};
+  static constexpr wpi::units::radian_t kMeasurement =
+      wpi::units::degree_t{3.1191729343822456};
+  static constexpr wpi::units::radian_t kGoal =
+      wpi::units::degree_t{2.709680418117445};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -81,9 +89,10 @@ TEST(ProfiledPIDInputOutputTest, ContinuousInput4) {
   controller.EnableContinuousInput(
       0_rad, wpi::units::radian_t{2.0 * std::numbers::pi});
 
-  static constexpr wpi::units::radian_t kSetpoint{2.78};
-  static constexpr wpi::units::radian_t kMeasurement{3.12};
-  static constexpr wpi::units::radian_t kGoal{2.71};
+  static constexpr wpi::units::radian_t kSetpoint = wpi::units::degree_t{2.78};
+  static constexpr wpi::units::radian_t kMeasurement =
+      wpi::units::degree_t{3.12};
+  static constexpr wpi::units::radian_t kGoal = wpi::units::degree_t{2.71};
 
   controller.Reset(kSetpoint);
   EXPECT_LT(controller.Calculate(kMeasurement, kGoal), 0.0);
@@ -126,6 +135,7 @@ TEST(ProfiledPIDInputOutputTest, DerivativeGainOutput) {
 
   controller.Calculate(0_deg, 0_deg);
 
-  EXPECT_DOUBLE_EQ(-10_ms / controller.GetPeriod(),
-                   controller.Calculate(0.0025_deg, 0_deg));
+  EXPECT_DOUBLE_EQ(
+      double{wpi::units::second_t{-10_ms} / controller.GetPeriod()},
+      controller.Calculate(0.0025_deg, 0_deg));
 }
diff --git a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
index 86254c57f2..2776649d35 100644
--- a/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/proto/SimpleMotorFeedforwardProtoTest.cpp
@@ -35,7 +35,7 @@ INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardProtoTestData<wpi::units::meters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardFeet, ProtoTest,
-    SimpleMotorFeedforwardProtoTestData<wpi::units::feet>);
+    SimpleMotorFeedforwardProtoTestData<wpi::units::centimeters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardRadians, ProtoTest,
     SimpleMotorFeedforwardProtoTestData<wpi::units::radians>);
diff --git a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
index 41395d0c6e..bd4efac352 100644
--- a/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
+++ b/wpimath/src/test/native/cpp/controller/struct/SimpleMotorFeedforwardStructTest.cpp
@@ -35,7 +35,7 @@ INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardStructTestData<wpi::units::meters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardFeet, StructTest,
-    SimpleMotorFeedforwardStructTestData<wpi::units::feet>);
+    SimpleMotorFeedforwardStructTestData<wpi::units::centimeters>);
 INSTANTIATE_TYPED_TEST_SUITE_P(
     SimpleMotorFeedforwardRadians, StructTest,
     SimpleMotorFeedforwardStructTestData<wpi::units::radians>);
diff --git a/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp b/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp
index 85b2e20ccb..6254827797 100644
--- a/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/ExtendedKalmanFilterTest.cpp
@@ -36,10 +36,10 @@ wpi::math::Vectord<5> Dynamics(const wpi::math::Vectord<5>& x,
   auto k1 = (1 / m + wpi::units::math::pow<2>(rb) / J);
   auto k2 = (1 / m - wpi::units::math::pow<2>(rb) / J);
 
-  wpi::units::meters_per_second_t vl{x(3)};
-  wpi::units::meters_per_second_t vr{x(4)};
-  wpi::units::volt_t Vl{u(0)};
-  wpi::units::volt_t Vr{u(1)};
+  wpi::units::meters_per_second_t vl = wpi::units::meters_per_second_t{x(3)};
+  wpi::units::meters_per_second_t vr = wpi::units::meters_per_second_t{x(4)};
+  wpi::units::volt_t Vl = wpi::units::volt_t{u(0)};
+  wpi::units::volt_t Vr = wpi::units::volt_t{u(1)};
 
   auto v = 0.5 * (vl + vr);
   return wpi::math::Vectord<5>{
diff --git a/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp b/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
index b61c147aa2..0cd4b26c46 100644
--- a/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/MerweUKFTest.cpp
@@ -43,10 +43,10 @@ wpi::math::Vectord<5> DriveDynamics(const wpi::math::Vectord<5>& x,
   auto k1 = (1 / m + wpi::units::math::pow<2>(rb) / J);
   auto k2 = (1 / m - wpi::units::math::pow<2>(rb) / J);
 
-  wpi::units::meters_per_second_t vl{x(3)};
-  wpi::units::meters_per_second_t vr{x(4)};
-  wpi::units::volt_t Vl{u(0)};
-  wpi::units::volt_t Vr{u(1)};
+  wpi::units::meters_per_second_t vl = wpi::units::meters_per_second_t{x(3)};
+  wpi::units::meters_per_second_t vr = wpi::units::meters_per_second_t{x(4)};
+  wpi::units::volt_t Vl = wpi::units::volt_t{u(0)};
+  wpi::units::volt_t Vr = wpi::units::volt_t{u(1)};
 
   auto v = 0.5 * (vl + vr);
   return wpi::math::Vectord<5>{
diff --git a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
index c03fb1007f..6b11255967 100644
--- a/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
+++ b/wpimath/src/test/native/cpp/estimator/S3UKFTest.cpp
@@ -43,10 +43,10 @@ wpi::math::Vectord<5> DriveDynamics(const wpi::math::Vectord<5>& x,
   auto k1 = (1 / m + wpi::units::math::pow<2>(rb) / J);
   auto k2 = (1 / m - wpi::units::math::pow<2>(rb) / J);
 
-  wpi::units::meters_per_second_t vl{x(3)};
-  wpi::units::meters_per_second_t vr{x(4)};
-  wpi::units::volt_t Vl{u(0)};
-  wpi::units::volt_t Vr{u(1)};
+  wpi::units::meters_per_second_t vl = wpi::units::meters_per_second_t{x(3)};
+  wpi::units::meters_per_second_t vr = wpi::units::meters_per_second_t{x(4)};
+  wpi::units::volt_t Vl = wpi::units::volt_t{u(0)};
+  wpi::units::volt_t Vr = wpi::units::volt_t{u(1)};
 
   auto v = 0.5 * (vl + vr);
   return wpi::math::Vectord<5>{
diff --git a/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp b/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp
index 5921f5bd71..25f273a75e 100644
--- a/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp
+++ b/wpimath/src/test/native/cpp/filter/DebouncerTest.cpp
@@ -14,8 +14,9 @@ static wpi::units::second_t now = 0_s;
 class DebouncerTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    WPI_SetNowImpl(
-        [] { return wpi::units::microsecond_t{now}.to<uint64_t>(); });
+    WPI_SetNowImpl([] {
+      return static_cast<uint64_t>(wpi::units::microsecond_t{now}.value());
+    });
   }
 
   void TearDown() override { WPI_SetNowImpl(nullptr); }
diff --git a/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp b/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp
index ee4254fb80..0dffe8de86 100644
--- a/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp
+++ b/wpimath/src/test/native/cpp/filter/SlewRateLimiterTest.cpp
@@ -16,15 +16,18 @@ static wpi::units::second_t now = 0_s;
 class SlewRateLimiterTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    WPI_SetNowImpl(
-        [] { return wpi::units::microsecond_t{now}.to<uint64_t>(); });
+    WPI_SetNowImpl([] {
+      return static_cast<uint64_t>(wpi::units::microsecond_t{now}.value());
+    });
   }
 
   void TearDown() override { WPI_SetNowImpl(nullptr); }
 };
 
 TEST_F(SlewRateLimiterTest, SlewRateLimit) {
-  WPI_SetNowImpl([] { return wpi::units::microsecond_t{now}.to<uint64_t>(); });
+  WPI_SetNowImpl([] {
+    return static_cast<uint64_t>(wpi::units::microsecond_t{now}.value());
+  });
 
   wpi::math::SlewRateLimiter<wpi::units::meters> limiter(1_mps);
 
diff --git a/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp b/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp
index 340379f1ba..fd4a2f67a9 100644
--- a/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp
+++ b/wpimath/src/test/native/cpp/interpolation/TimeInterpolatableBufferTest.cpp
@@ -17,31 +17,31 @@ TEST(TimeInterpolatableBufferTest, AddSample) {
 
   // No entries
   buffer.AddSample(1_s, 0_rad);
-  EXPECT_TRUE(buffer.Sample(1_s).value() == 0_rad);
+  EXPECT_TRUE(buffer.Sample(1_s).value() == 0_rad);  // non-unit .value()
 
   // New entry at start of container
   buffer.AddSample(0_s, 1_rad);
-  EXPECT_TRUE(buffer.Sample(0_s).value() == 1_rad);
+  EXPECT_TRUE(buffer.Sample(0_s).value() == 1_rad);  // non-unit .value()
 
   // New entry in middle of container
   buffer.AddSample(0.5_s, 0.5_rad);
-  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 0.5_rad);
+  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 0.5_rad);  // non-unit .value()
 
   // Override sample
   buffer.AddSample(0.5_s, 1_rad);
-  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 1_rad);
+  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 1_rad);  // non-unit .value()
 }
 
 TEST(TimeInterpolatableBufferTest, Interpolation) {
   wpi::math::TimeInterpolatableBuffer<wpi::math::Rotation2d> buffer{10_s};
 
   buffer.AddSample(0_s, 0_rad);
-  EXPECT_TRUE(buffer.Sample(0_s).value() == 0_rad);
+  EXPECT_TRUE(buffer.Sample(0_s).value() == 0_rad);  // non-unit .value()
   buffer.AddSample(1_s, 1_rad);
-  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 0.5_rad);
-  EXPECT_TRUE(buffer.Sample(1_s).value() == 1_rad);
+  EXPECT_TRUE(buffer.Sample(0.5_s).value() == 0.5_rad);  // non-unit .value()
+  EXPECT_TRUE(buffer.Sample(1_s).value() == 1_rad);      // non-unit .value()
   buffer.AddSample(3_s, 2_rad);
-  EXPECT_TRUE(buffer.Sample(2_s).value() == 1.5_rad);
+  EXPECT_TRUE(buffer.Sample(2_s).value() == 1.5_rad);  // non-unit .value()
 
   buffer.AddSample(10.5_s, 2_rad);
   EXPECT_TRUE(buffer.Sample(0_s) == 1_rad);
@@ -53,7 +53,7 @@ TEST(TimeInterpolatableBufferTest, Pose2d) {
   // We expect to be at (1 - 1/std::sqrt(2), 1/std::sqrt(2), 45deg) at t=0.5
   buffer.AddSample(0_s, wpi::math::Pose2d{0_m, 0_m, 90_deg});
   buffer.AddSample(1_s, wpi::math::Pose2d{1_m, 1_m, 0_deg});
-  wpi::math::Pose2d sample = buffer.Sample(0.5_s).value();
+  wpi::math::Pose2d sample = buffer.Sample(0.5_s).value();  // non-unit .value()
 
   EXPECT_TRUE(std::abs(sample.X().value() - (1.0 - 1.0 / std::sqrt(2.0))) <
               0.01);
diff --git a/wpimath/src/test/native/cpp/optimization/NonlinearProblemTest.cpp b/wpimath/src/test/native/cpp/optimization/NonlinearProblemTest.cpp
index eb1f0c345b..78bb5e4faa 100644
--- a/wpimath/src/test/native/cpp/optimization/NonlinearProblemTest.cpp
+++ b/wpimath/src/test/native/cpp/optimization/NonlinearProblemTest.cpp
@@ -34,7 +34,7 @@ TEST(ProblemTest, Quartic) {
 
   EXPECT_EQ(problem.solve({.diagnostics = true}), slp::ExitStatus::SUCCESS);
 
-  EXPECT_NEAR(x.value(), 1.0, 1e-6);
+  EXPECT_NEAR(x.value(), 1.0, 1e-6);  // non-unit .value()
 
   if (auto output = testing::internal::GetCapturedStdout(); HasFailure()) {
     fmt::println("{}", output);
@@ -72,7 +72,9 @@ TEST(ProblemTest, RosenbrockWithCubicAndLineConstraint) {
 
       // Local minimum at (0.0, 0.0)
       // Global minimum at (1.0, 1.0)
+      // next line non-unit .value()
       EXPECT_TRUE((near(0.0, x.value(), 1e-2) || near(1.0, x.value(), 1e-2)));
+      // next line non-unit .value()
       EXPECT_TRUE((near(0.0, y.value(), 1e-2) || near(1.0, y.value(), 1e-2)));
     }
   }
@@ -106,8 +108,8 @@ TEST(ProblemTest, RosenbrockWithDiskConstraint) {
 
       EXPECT_EQ(problem.solve({.diagnostics = true}), slp::ExitStatus::SUCCESS);
 
-      EXPECT_NEAR(x.value(), 1.0, 1e-3);
-      EXPECT_NEAR(y.value(), 1.0, 1e-3);
+      EXPECT_NEAR(x.value(), 1.0, 1e-3);  // non-unit .value()
+      EXPECT_NEAR(y.value(), 1.0, 1e-3);  // non-unit .value()
     }
   }
 
@@ -144,8 +146,8 @@ TEST(ProblemTest, Minimum2DDistanceWithLinearConstraint) {
   EXPECT_EQ(problem.solve({.diagnostics = true}), slp::ExitStatus::SUCCESS);
 #endif
 
-  EXPECT_NEAR(x.value(), 2.5, 1e-2);
-  EXPECT_NEAR(y.value(), 2.5, 1e-2);
+  EXPECT_NEAR(x.value(), 2.5, 1e-2);  // non-unit .value()
+  EXPECT_NEAR(y.value(), 2.5, 1e-2);  // non-unit .value()
 
   if (auto output = testing::internal::GetCapturedStdout(); HasFailure()) {
     fmt::println("{}", output);
@@ -212,9 +214,9 @@ TEST(ProblemTest, WachterAndBieglerLineSearchFailure) {
   EXPECT_EQ(problem.solve({.diagnostics = true}),
             slp::ExitStatus::LINE_SEARCH_FAILED);
 
-  // EXPECT_EQ(x.value(), 1.0);
-  // EXPECT_EQ(s1.value(), 0.0);
-  // EXPECT_EQ(s2.value(), 0.5);
+  // EXPECT_EQ(x.value(), 1.0);  // non-unit .value()
+  // EXPECT_EQ(s1.value(), 0.0);  // non-unit .value()
+  // EXPECT_EQ(s2.value(), 0.5);  // non-unit .value()
 
   if (auto output = testing::internal::GetCapturedStdout(); HasFailure()) {
     fmt::println("{}", output);
diff --git a/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp b/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp
index 6e44e1b724..4cedc8617e 100644
--- a/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp
+++ b/wpimath/src/test/native/cpp/spline/CubicHermiteSplineTest.cpp
@@ -30,7 +30,7 @@ class CubicHermiteSplineTest : public ::testing::Test {
         SplineHelper::CubicSplinesFromControlVectors(startCV, waypoints, endCV);
     std::vector<Spline<3>::PoseWithCurvature> poses;
 
-    poses.push_back(splines[0].GetPoint(0.0).value());
+    poses.push_back(splines[0].GetPoint(0.0).value());  // non-unit .value()
 
     for (auto&& spline : splines) {
       auto x = SplineParameterizer::Parameterize(spline);
diff --git a/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp b/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp
index 101967f532..6a92305dc9 100644
--- a/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp
+++ b/wpimath/src/test/native/cpp/trajectory/ExponentialProfileTest.cpp
@@ -4,6 +4,7 @@
 
 #include "wpi/math/trajectory/ExponentialProfile.hpp"
 
+#include <algorithm>
 #include <chrono>
 #include <cmath>
 #include <tuple>
@@ -189,7 +190,7 @@ TEST(ExponentialProfileTest, TopSpeed) {
 
   for (int i = 0; i < 900; ++i) {
     state = CheckDynamics(profile, constraints, feedforward, state, goal);
-    maxSpeed = wpi::units::math::max(state.velocity, maxSpeed);
+    maxSpeed = std::max(state.velocity, maxSpeed);
   }
 
   EXPECT_NEAR_UNITS(constraints.MaxVelocity(), maxSpeed, 1e-5_mps);
@@ -214,7 +215,7 @@ TEST(ExponentialProfileTest, TopSpeedBackward) {
 
   for (int i = 0; i < 900; ++i) {
     state = CheckDynamics(profile, constraints, feedforward, state, goal);
-    maxSpeed = wpi::units::math::min(state.velocity, maxSpeed);
+    maxSpeed = std::min(state.velocity, maxSpeed);
   }
 
   EXPECT_NEAR_UNITS(-constraints.MaxVelocity(), maxSpeed, 1e-5_mps);
diff --git a/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp b/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp
index e040d0aa02..1d883f65ed 100644
--- a/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp
+++ b/wpimath/src/test/native/cpp/trajectory/TrapezoidProfileTest.cpp
@@ -142,8 +142,6 @@ TEST(TrapezoidProfileTest, TimingToCurrent) {
 }
 
 TEST(TrapezoidProfileTest, TimingToGoal) {
-  using wpi::units::unit_cast;
-
   wpi::math::TrapezoidProfile<wpi::units::meter>::Constraints constraints{
       0.75_mps, 0.75_mps_sq};
   wpi::math::TrapezoidProfile<wpi::units::meter>::State goal{2_m, 0_mps};
@@ -159,15 +157,13 @@ TEST(TrapezoidProfileTest, TimingToGoal) {
     if (!reachedGoal && state == goal) {
       // Expected value using for loop index is just an approximation since the
       // time left in the profile doesn't increase linearly at the endpoints
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 0.25);
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 0.25);
       reachedGoal = true;
     }
   }
 }
 
 TEST(TrapezoidProfileTest, TimingBeforeGoal) {
-  using wpi::units::unit_cast;
-
   wpi::math::TrapezoidProfile<wpi::units::meter>::Constraints constraints{
       0.75_mps, 0.75_mps_sq};
   wpi::math::TrapezoidProfile<wpi::units::meter>::State goal{2_m, 0_mps};
@@ -182,15 +178,13 @@ TEST(TrapezoidProfileTest, TimingBeforeGoal) {
     state = profile.Calculate(kDt, state, goal);
     if (!reachedGoal &&
         (wpi::units::math::abs(state.velocity - 1_mps) < 10e-5_mps)) {
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 2e-2);
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 2e-2);
       reachedGoal = true;
     }
   }
 }
 
 TEST(TrapezoidProfileTest, TimingToNegativeGoal) {
-  using wpi::units::unit_cast;
-
   wpi::math::TrapezoidProfile<wpi::units::meter>::Constraints constraints{
       0.75_mps, 0.75_mps_sq};
   wpi::math::TrapezoidProfile<wpi::units::meter>::State goal{-2_m, 0_mps};
@@ -206,15 +200,13 @@ TEST(TrapezoidProfileTest, TimingToNegativeGoal) {
     if (!reachedGoal && state == goal) {
       // Expected value using for loop index is just an approximation since the
       // time left in the profile doesn't increase linearly at the endpoints
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 0.25);
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 0.25);
       reachedGoal = true;
     }
   }
 }
 
 TEST(TrapezoidProfileTest, TimingBeforeNegativeGoal) {
-  using wpi::units::unit_cast;
-
   wpi::math::TrapezoidProfile<wpi::units::meter>::Constraints constraints{
       0.75_mps, 0.75_mps_sq};
   wpi::math::TrapezoidProfile<wpi::units::meter>::State goal{-2_m, 0_mps};
@@ -229,7 +221,7 @@ TEST(TrapezoidProfileTest, TimingBeforeNegativeGoal) {
     state = profile.Calculate(kDt, state, goal);
     if (!reachedGoal &&
         (wpi::units::math::abs(state.velocity + 1_mps) < 10e-5_mps)) {
-      EXPECT_NEAR(unit_cast<double>(predictedTimeLeft), i / 100.0, 2e-2);
+      EXPECT_NEAR(predictedTimeLeft.value(), i / 100.0, 2e-2);
       reachedGoal = true;
     }
   }
